{"version":3,"file":"googleMapsAerial-BCyKCIrR.js","sources":["../../../node_modules/@babylonjs/core/Behaviors/Cameras/interpolatingBehavior.js","../../../node_modules/@babylonjs/core/Behaviors/Cameras/geospatialClippingBehavior.js","../../../node_modules/@babylonjs/core/Cameras/Inputs/geospatialCameraPointersInput.js","../../../node_modules/@babylonjs/core/Cameras/geospatialCameraInputsManager.js","../../../node_modules/@babylonjs/core/Cameras/Limits/geospatialLimits.js","../../../node_modules/@babylonjs/core/Cameras/cameraMovement.js","../../../node_modules/@babylonjs/core/Cameras/geospatialCameraMovement.js","../../../node_modules/@babylonjs/core/Cameras/geospatialCamera.js","../../babylonjs/googleMapsAerial.js"],"sourcesContent":["import { CubicEase, EasingFunction } from \"../../Animations/easing.js\";\nimport { Animation } from \"../../Animations/animation.js\";\n/**\n * Animate camera property changes with an interpolation effect\n * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors\n */\nexport class InterpolatingBehavior {\n    /**\n     * Gets the name of the behavior.\n     */\n    get name() {\n        return \"Interpolating\";\n    }\n    /**\n     * Attached node of this behavior\n     */\n    get attachedNode() {\n        return this._attachedCamera;\n    }\n    /**\n     * Initializes the behavior\n     */\n    constructor() {\n        /**\n         * The easing function to use for interpolation\n         */\n        this.easingFunction = new CubicEase();\n        /**\n         * The easing mode (default is EASINGMODE_EASEINOUT)\n         */\n        this.easingMode = EasingFunction.EASINGMODE_EASEINOUT;\n        /**\n         * Duration of the animation in milliseconds\n         */\n        this.transitionDuration = 450;\n        this._attachedCamera = null;\n        this._animatables = new Map();\n        this.easingFunction.setEasingMode(this.easingMode);\n    }\n    /**\n     * Initializes the behavior\n     */\n    init() {\n        // Nothing to do on init\n    }\n    /**\n     * Attaches the behavior to a camera\n     * @param camera The camera to attach to\n     */\n    attach(camera) {\n        this._attachedCamera = camera;\n    }\n    /**\n     * Detaches the behavior from the camera\n     */\n    detach() {\n        if (!this._attachedCamera) {\n            return;\n        }\n        this.stopAllAnimations();\n        this._attachedCamera = null;\n    }\n    get isInterpolating() {\n        return this._animatables.size > 0;\n    }\n    /**\n     * Stops and removes all animations\n     */\n    stopAllAnimations() {\n        if (this._attachedCamera) {\n            this._animatables.forEach((animatable) => animatable.stop());\n        }\n        this._animatables.clear();\n        this._promiseResolve?.();\n        this._promiseResolve = undefined;\n    }\n    updateProperties(properties) {\n        properties.forEach((value, key) => {\n            if (value !== undefined) {\n                const animatable = this._animatables.get(String(key));\n                animatable && (animatable.target = value);\n            }\n        });\n    }\n    async animatePropertiesAsync(properties, transitionDuration = this.transitionDuration, easingFn = this.easingFunction, updateAnimation) {\n        const promise = new Promise((resolve) => {\n            this.stopAllAnimations();\n            this._promiseResolve = resolve;\n            if (!this._attachedCamera) {\n                this._promiseResolve = undefined;\n                return resolve();\n            }\n            const camera = this._attachedCamera;\n            const scene = camera.getScene();\n            const checkClear = (propertyName) => {\n                // Remove the associated animation from camera once the transition to target is complete so that property animations don't accumulate\n                for (let i = camera.animations.length - 1; i >= 0; --i) {\n                    if (camera.animations[i].name === propertyName + \"Animation\") {\n                        camera.animations.splice(i, 1);\n                    }\n                }\n                this._animatables.delete(propertyName);\n                if (this._animatables.size === 0) {\n                    this._promiseResolve = undefined;\n                    resolve();\n                }\n            };\n            properties.forEach((value, key) => {\n                if (value !== undefined && camera[key] !== value) {\n                    const propertyName = String(key);\n                    const animation = Animation.CreateAnimation(propertyName, GetAnimationType(value), 60, easingFn);\n                    // Optionally allow caller to further customize the animation\n                    updateAnimation?.(propertyName, animation);\n                    // Pass false for stopCurrent so that we can interpolate multiple properties at once\n                    const animatable = Animation.TransitionTo(propertyName, value, camera, scene, 60, animation, transitionDuration, () => checkClear(propertyName), false);\n                    if (animatable) {\n                        this._animatables.set(propertyName, animatable);\n                    }\n                }\n            });\n        });\n        return await promise;\n    }\n}\n// Structural type-guards (no instanceof)\nfunction IsQuaternionLike(v) {\n    return v != null && typeof v.x === \"number\" && typeof v.y === \"number\" && typeof v.z === \"number\" && typeof v.w === \"number\";\n}\nfunction IsMatrixLike(v) {\n    return v != null && (Array.isArray(v.m) || typeof v.m === \"object\");\n}\nfunction IsVector3Like(v) {\n    return v != null && typeof v.x === \"number\" && typeof v.y === \"number\" && typeof v.z === \"number\";\n}\nfunction IsVector2Like(v) {\n    return v != null && typeof v.x === \"number\" && typeof v.y === \"number\";\n}\nfunction IsColor3Like(v) {\n    return v != null && typeof v.r === \"number\" && typeof v.g === \"number\" && typeof v.b === \"number\";\n}\nfunction IsColor4Like(v) {\n    return v != null && typeof v.r === \"number\" && typeof v.g === \"number\" && typeof v.b === \"number\" && typeof v.a === \"number\";\n}\nfunction IsSizeLike(v) {\n    return v != null && typeof v.width === \"number\" && typeof v.height === \"number\";\n}\nconst GetAnimationType = (value) => {\n    if (IsQuaternionLike(value)) {\n        return Animation.ANIMATIONTYPE_QUATERNION;\n    }\n    if (IsMatrixLike(value)) {\n        return Animation.ANIMATIONTYPE_MATRIX;\n    }\n    if (IsVector3Like(value)) {\n        return Animation.ANIMATIONTYPE_VECTOR3;\n    }\n    if (IsVector2Like(value)) {\n        return Animation.ANIMATIONTYPE_VECTOR2;\n    }\n    if (IsColor3Like(value)) {\n        return Animation.ANIMATIONTYPE_COLOR3;\n    }\n    if (IsColor4Like(value)) {\n        return Animation.ANIMATIONTYPE_COLOR4;\n    }\n    if (IsSizeLike(value)) {\n        return Animation.ANIMATIONTYPE_SIZE;\n    }\n    // Fallback to float for numbers and unknown shapes\n    return Animation.ANIMATIONTYPE_FLOAT;\n};\n//# sourceMappingURL=interpolatingBehavior.js.map","/**\n * The GeospatialClippingBehavior automatically adjusts the near and far clip planes of a GeospatialCamera\n * based on altitude to optimize depth buffer precision for geospatial applications.\n *\n * The near plane scales with altitude (distance to planet surface) to maintain good depth precision.\n * The far plane is calculated based on the visible horizon distance.\n */\nexport class GeospatialClippingBehavior {\n    constructor() {\n        this._attachedCamera = null;\n        this._onBeforeRenderObserver = null;\n    }\n    /**\n     * Gets the name of the behavior.\n     */\n    get name() {\n        return \"GeospatialClipping\";\n    }\n    /**\n     * Gets the attached camera.\n     */\n    get attachedNode() {\n        return this._attachedCamera;\n    }\n    /**\n     * Initializes the behavior.\n     */\n    init() {\n        // Do nothing\n    }\n    /**\n     * Attaches the behavior to its geospatial camera.\n     * @param camera Defines the camera to attach the behavior to\n     */\n    attach(camera) {\n        this._attachedCamera = camera;\n        const scene = camera.getScene();\n        this._onBeforeRenderObserver = scene.onBeforeRenderObservable.add(() => {\n            this._updateCameraClipPlanes();\n        });\n    }\n    /**\n     * Detaches the behavior from its current geospatial camera.\n     */\n    detach() {\n        if (this._attachedCamera) {\n            const scene = this._attachedCamera.getScene();\n            if (this._onBeforeRenderObserver) {\n                scene.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\n                this._onBeforeRenderObserver = null;\n            }\n        }\n        this._attachedCamera = null;\n    }\n    /**\n     * Updates the camera's near and far clip planes based on altitude.\n     */\n    _updateCameraClipPlanes() {\n        const camera = this._attachedCamera;\n        if (!camera) {\n            return;\n        }\n        const planetRadius = camera.limits.planetRadius;\n        // Camera position length gives distance to world origin (planet center)\n        const altitude = Math.max(1, camera.position.length() - planetRadius);\n        // Near plane: scale with altitude to maintain depth buffer precision\n        // Use a fraction of altitude - the closest visible point on a sphere is straight down at distance = altitude\n        camera.minZ = Math.max(1, altitude * 0.001);\n        // Far plane: see to the horizon and beyond\n        // Horizon distance formula: √(2Rh + h²) where h is altitude above surface\n        const horizonDist = Math.sqrt(2 * planetRadius * altitude + altitude * altitude);\n        camera.maxZ = horizonDist + planetRadius * 0.1;\n    }\n}\n//# sourceMappingURL=geospatialClippingBehavior.js.map","import { OrbitCameraPointersInput } from \"./orbitCameraPointersInput.js\";\n/**\n * @experimental\n * Geospatial camera inputs can simulate dragging the globe around or tilting the camera around some point on the globe\n * This class will update the GeospatialCameraMovement class's movementDeltaCurrentFrame, and the camera is responsible for using these updates to calculate viewMatrix appropriately\n *\n * As of right now, the camera correction logic (to keep the camera geospatially oriented around the globe) is happening within the camera class when calculating viewmatrix\n * As this is experimental, it is possible we move that correction step to live within the input class (to enable non-corrected translations in the future), say if we want to allow the camera to move outside of the globe's orbit\n *\n * Left mouse button: drag globe\n * Middle mouse button: tilt globe\n * Right mouse button: tilt globe\n *\n */\nexport class GeospatialCameraPointersInput extends OrbitCameraPointersInput {\n    constructor() {\n        super(...arguments);\n        this._initialPinchSquaredDistance = 0;\n        this._pinchCentroid = null;\n    }\n    getClassName() {\n        return \"GeospatialCameraPointersInput\";\n    }\n    onButtonDown(evt) {\n        this.camera.movement.activeInput = true;\n        const scene = this.camera.getScene();\n        switch (evt.button) {\n            case 0: // Left button - drag/pan globe under cursor\n                this.camera.movement.startDrag(scene.pointerX, scene.pointerY);\n                break;\n            default:\n                break;\n        }\n    }\n    onTouch(point, offsetX, offsetY) {\n        // Single finger touch (no button property) or left button (button 0) = drag\n        const button = point?.button ?? 0; // Default to button 0 (drag) if undefined\n        const scene = this.camera.getScene();\n        switch (button) {\n            case 0: // Left button / single touch - drag/pan globe under cursor\n                this.camera.movement.handleDrag(scene.pointerX, scene.pointerY);\n                break;\n            case 1: // Middle button - tilt camera\n            case 2: // Right button - tilt camera\n                this._handleTilt(offsetX, offsetY);\n                break;\n        }\n    }\n    /**\n     * Move camera from multitouch (pinch) zoom distances.\n     * Zooms towards the centroid (midpoint between the two fingers).\n     * @param previousPinchSquaredDistance\n     * @param pinchSquaredDistance\n     */\n    _computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance) {\n        // Calculate zoom distance based on pinch delta\n        const previousDistance = Math.sqrt(previousPinchSquaredDistance);\n        const currentDistance = Math.sqrt(pinchSquaredDistance);\n        const pinchDelta = currentDistance - previousDistance;\n        // Try to zoom towards centroid if we have it\n        if (this._pinchCentroid) {\n            const scene = this.camera.getScene();\n            const engine = scene.getEngine();\n            const canvasRect = engine.getInputElementClientRect();\n            if (canvasRect) {\n                // Convert centroid from clientX/Y to canvas-relative coordinates (same as scene.pointerX/Y)\n                const canvasX = this._pinchCentroid.x - canvasRect.left;\n                const canvasY = this._pinchCentroid.y - canvasRect.top;\n                // Pick at centroid\n                const pickResult = scene.pick(canvasX, canvasY, this.camera.movement.pickPredicate);\n                if (pickResult?.pickedPoint) {\n                    // Scale zoom by distance to picked point\n                    const distanceToPoint = this.camera.position.subtract(pickResult.pickedPoint).length();\n                    const zoomDistance = pinchDelta * distanceToPoint * 0.005;\n                    const clampedZoom = this.camera.limits.clampZoomDistance(zoomDistance, this.camera.radius, distanceToPoint);\n                    this.camera.zoomToPoint(pickResult.pickedPoint, clampedZoom);\n                    return;\n                }\n            }\n        }\n        // Fallback: scale zoom by camera radius along lookat vector\n        const zoomDistance = pinchDelta * this.camera.radius * 0.005;\n        const clampedZoom = this.camera.limits.clampZoomDistance(zoomDistance, this.camera.radius);\n        this.camera.zoomAlongLookAt(clampedZoom);\n    }\n    /**\n     * Move camera from multi touch panning positions.\n     * In geospatialcamera, multi touch panning tilts the globe (whereas single touch will pan/drag it)\n     * @param previousMultiTouchPanPosition\n     * @param multiTouchPanPosition\n     */\n    _computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition) {\n        if (previousMultiTouchPanPosition && multiTouchPanPosition) {\n            const moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;\n            const moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;\n            this._handleTilt(moveDeltaX, moveDeltaY);\n        }\n    }\n    onDoubleTap(type) {\n        const pickResult = this.camera._scene.pick(this.camera._scene.pointerX, this.camera._scene.pointerY, this.camera.movement.pickPredicate);\n        if (pickResult.pickedPoint) {\n            void this.camera.flyToPointAsync(pickResult.pickedPoint);\n        }\n    }\n    onMultiTouch(pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {\n        // Store centroid for use in _computePinchZoom (it's already calculated by parent)\n        this._pinchCentroid = multiTouchPanPosition;\n        // Reset on gesture end\n        if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {\n            this._initialPinchSquaredDistance = 0;\n            this._pinchCentroid = null;\n            super.onMultiTouch(pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition);\n            return;\n        }\n        // Track initial distance at gesture start for cumulative threshold detection\n        if (this._initialPinchSquaredDistance === 0 && pinchSquaredDistance !== 0) {\n            this._initialPinchSquaredDistance = pinchSquaredDistance;\n        }\n        // Use cumulative delta from gesture start for threshold detection (more forgiving than frame-to-frame)\n        const cumulativeDelta = Math.abs(Math.sqrt(pinchSquaredDistance) - Math.sqrt(this._initialPinchSquaredDistance));\n        this._shouldStartPinchZoom = this._twoFingerActivityCount < 20 && cumulativeDelta > this.camera.limits.pinchToPanMax;\n        super.onMultiTouch(pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition);\n    }\n    onButtonUp(_evt) {\n        this.camera.movement.stopDrag();\n        this.camera.movement.activeInput = false;\n        this._initialPinchSquaredDistance = 0;\n        this._pinchCentroid = null;\n        super.onButtonUp(_evt);\n    }\n    onLostFocus() {\n        this._initialPinchSquaredDistance = 0;\n        this._pinchCentroid = null;\n        super.onLostFocus();\n    }\n    _handleTilt(deltaX, deltaY) {\n        this.camera.movement.rotationAccumulatedPixels.y -= deltaX; // yaw - looking side to side\n        this.camera.movement.rotationAccumulatedPixels.x -= deltaY; // pitch - look up towards sky / down towards ground\n    }\n}\n//# sourceMappingURL=geospatialCameraPointersInput.js.map","import { CameraInputsManager } from \"./cameraInputsManager.js\";\nimport { GeospatialCameraPointersInput } from \"./Inputs/geospatialCameraPointersInput.js\";\nimport { GeospatialCameraMouseWheelInput } from \"./Inputs/geospatialCameraMouseWheelInput.js\";\nimport { GeospatialCameraKeyboardInput } from \"./Inputs/geospatialCameraKeyboardInput.js\";\n/**\n * Default Inputs manager for the GeospatialCamera.\n * It groups all the default supported inputs for ease of use.\n */\nexport class GeospatialCameraInputsManager extends CameraInputsManager {\n    /**\n     * Instantiates a new GeospatialCameraInputsManager.\n     * @param camera Defines the camera the inputs belong to\n     */\n    constructor(camera) {\n        super(camera);\n    }\n    /**\n     * Add mouse input support to the input manager\n     * @returns the current input manager\n     */\n    addMouse() {\n        this.add(new GeospatialCameraPointersInput());\n        return this;\n    }\n    /**\n     * Add mouse wheel input support to the input manager\n     * @returns the current input manager\n     */\n    addMouseWheel() {\n        this.add(new GeospatialCameraMouseWheelInput());\n        return this;\n    }\n    /**\n     * Add mouse wheel input support to the input manager\n     * @returns the current input manager\n     */\n    addKeyboard() {\n        this.add(new GeospatialCameraKeyboardInput());\n        return this;\n    }\n}\n//# sourceMappingURL=geospatialCameraInputsManager.js.map","import { Epsilon } from \"../../Maths/math.constants.js\";\nimport { Vector2 } from \"../../Maths/math.vector.js\";\nimport { Clamp } from \"../../Maths/math.scalar.functions.js\";\n/**\n * Limits for geospatial camera\n */\nexport class GeospatialLimits {\n    /**\n     * @param planetRadius The radius of the planet\n     */\n    constructor(planetRadius) {\n        this._radiusMin = 10;\n        this._radiusMax = Infinity;\n        /** Gets the minimum pitch angle (angle from horizon) -- 0 means looking straight down at planet */\n        this.pitchMin = Epsilon;\n        /**  Gets the maximum pitch angle (angle from horizon) -- Pi/2 means looking at horizon */\n        this.pitchMax = Math.PI / 2 - 0.01;\n        /**\n         * Controls how pitch is disabled as the camera zooms out.\n         * x = radius scale at which full pitch is allowed (e.g., 1.5 means 1.5 * planetRadius)\n         * y = radius scale at which pitch is fully disabled (forced to pitchMin)\n         * Set to undefined to disable this feature.\n         */\n        this.pitchDisabledRadiusScale = new Vector2(2, 4);\n        /** Gets the minimum yaw angle (rotation around up axis) */\n        this.yawMin = -Infinity;\n        /** Gets the maximum yaw angle (rotation around up axis) */\n        this.yawMax = Infinity;\n        /**\n         * Defines the distance used to consider the camera in pan mode vs pinch/zoom.\n         * Basically if your fingers moves away from more than this distance you will be considered\n         * in pinch mode.\n         */\n        this.pinchToPanMax = 20;\n        this._planetRadius = planetRadius;\n        this.radiusMax = planetRadius * 4;\n    }\n    get radiusMin() {\n        return this._radiusMin;\n    }\n    /**\n     * Sets the minimum radius\n     */\n    set radiusMin(value) {\n        this._radiusMin = value;\n    }\n    get radiusMax() {\n        return this._radiusMax;\n    }\n    /**\n     * Sets the maximum radius\n     */\n    set radiusMax(value) {\n        this._radiusMax = value;\n    }\n    /**\n     * Gets the planet radius used for altitude/radius conversions\n     */\n    get planetRadius() {\n        return this._planetRadius;\n    }\n    /** Sets the planet radius and updates the radius limits to maintain current altitude */\n    set planetRadius(value) {\n        this._planetRadius = value;\n    }\n    /**\n     * Clamps a zoom distance to respect the radius limits.\n     * @param zoomDistance The requested zoom distance (positive = zoom in, negative = zoom out)\n     * @param currentRadius The current camera radius\n     * @param distanceToTarget Optional distance to the zoom target point (used for zoom-in clamping)\n     * @returns The clamped zoom distance\n     */\n    clampZoomDistance(zoomDistance, currentRadius, distanceToTarget) {\n        if (zoomDistance > 0) {\n            // Zooming IN - don't zoom past the surface or below radiusMin\n            const maxZoomIn = (distanceToTarget ?? currentRadius) - this._radiusMin;\n            return Math.min(zoomDistance, Math.max(0, maxZoomIn));\n        }\n        else {\n            // Zooming OUT - don't exceed radiusMax\n            const maxZoomOut = this._radiusMax - currentRadius;\n            return Math.max(zoomDistance, -Math.max(0, maxZoomOut));\n        }\n    }\n    /**\n     * Computes the effective maximum pitch based on the current camera radius.\n     * When pitchDisabledRadiusScale is set, pitch is interpolated from pitchMax to pitchMin\n     * as the camera zooms out from x*planetRadius to y*planetRadius.\n     * @param currentRadius The current camera radius (distance from planet center)\n     * @returns The effective maximum pitch angle\n     */\n    getEffectivePitchMax(currentRadius) {\n        if (!this.pitchDisabledRadiusScale) {\n            return this.pitchMax;\n        }\n        const fullPitchRadius = this.pitchDisabledRadiusScale.x * this._planetRadius;\n        const noPitchRadius = this.pitchDisabledRadiusScale.y * this._planetRadius;\n        if (currentRadius <= fullPitchRadius) {\n            // Full pitch allowed\n            return this.pitchMax;\n        }\n        else if (currentRadius >= noPitchRadius) {\n            // No pitch allowed\n            return this.pitchMin;\n        }\n        else {\n            // Interpolate between pitchMax and pitchMin\n            const t = (currentRadius - fullPitchRadius) / (noPitchRadius - fullPitchRadius);\n            const clampedT = Clamp(t, 0, 1);\n            return this.pitchMax * (1 - clampedT) + this.pitchMin * clampedT;\n        }\n    }\n}\n//# sourceMappingURL=geospatialLimits.js.map","import { Vector3 } from \"../Maths/math.vector.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\nconst FrameDurationAt60FPS = 1000 / 60;\n/**\n * @experimental\n * This class is subject to change as geospatial camera evolves.\n *\n * It is intended to hold all logic related to converting input pixel deltas into current frame deltas, taking speed / framerate into account\n * to ensure smooth frame-rate-independent movement\n */\nexport class CameraMovement {\n    constructor(scene, _cameraPosition, _behavior) {\n        this._cameraPosition = _cameraPosition;\n        this._behavior = _behavior;\n        /**\n         * Should be set by input classes to indicates whether there is active input this frame\n         * This helps us differentiate between 0 pixel delta due to no input vs user actively holding still\n         */\n        this.activeInput = false;\n        /**\n         * ------------ Speed ----------------\n         * Speed defines the amount of camera movement expected per input pixel movement\n         * -----------------------------------\n         */\n        /**\n         * Desired coordinate unit movement per input pixel when zooming\n         */\n        this.zoomSpeed = 1;\n        /**\n         * Desired coordinate unit movement per input pixel when panning\n         */\n        this.panSpeed = 1;\n        /**\n         * Desired radians movement per input pixel when rotating along x axis\n         */\n        this.rotationXSpeed = 1;\n        /**\n         * Desired radians movement per input pixel when rotating along y axis\n         */\n        this.rotationYSpeed = 1;\n        /**\n         * ----------- Speed multipliers ---------------\n         * Multipliers allow movement classes to modify the effective speed dynamically per-frame\n         * (ex: scale zoom based on distance from target)\n         * -----------------------------------\n         */\n        /**\n         * Multiplied atop zoom speed. Used to dynamically adjust zoom speed based on per-frame context (ex: zoom faster when further from target)\n         */\n        this._zoomSpeedMultiplier = 1;\n        /**\n         * Multiplied atop pan speed. Used to dynamically adjust pan speed based on per-frame context (ex: pan slowly when close to target)\n         */\n        this._panSpeedMultiplier = 1;\n        /**\n         * ---------- Inertia ----------------\n         * Inertia represents the decay factor per-frame applied to the velocity when there is no user input.\n         * 0 = No inertia, instant stop (velocity immediately becomes 0)\n         * 0.5 = Strong decay, velocity halves every frame at 60fps\n         * 0.9 = Moderate inertia, velocity retains 90% per frame at 60fps\n         * 0.95 = High inertia, smooth glide, velocity retains 95% per frame at 60fps\n         * 1 = Infinite inertia, never stops (velocity never decays)\n         * -----------------------------------\n         */\n        /**\n         * Inertia applied to the zoom velocity when there is no user input.\n         * Higher inertia === slower decay, velocity retains more of its value each frame\n         */\n        this.zoomInertia = 0.9;\n        /**\n         * Inertia applied to the panning velocity when there is no user input.\n         * Higher inertia === slower decay, velocity retains more of its value each frame\n         */\n        this.panInertia = 0.9;\n        /**\n         * Inertia applied to the rotation velocity when there is no user input.\n         * Higher inertia === slower decay, velocity retains more of its value each frame\n         */\n        this.rotationInertia = 0.9;\n        /**\n         * ---------- Accumulated Pixel Deltas -----------\n         * Pixel inputs accumulated throughout the frame by input classes (reset each frame after processing)\n         * -----------------------------------\n         */\n        /**\n         * Accumulated pixel delta (by input classes) for zoom this frame\n         * Read by computeCurrentFrameDeltas() function and converted into zoomDeltaCurrentFrame (taking speed into account)\n         * Reset to zero after each frame\n         */\n        this.zoomAccumulatedPixels = 0;\n        /**\n         * Accumulated pixel delta (by input classes) for panning this frame\n         * Read by computeCurrentFrameDeltas() function and converted into panDeltaCurrentFrame (taking speed into account)\n         * Reset to zero after each frame\n         */\n        this.panAccumulatedPixels = new Vector3();\n        /**\n         * Accumulated pixel delta (by input classes) for rotation this frame\n         * Read by computeCurrentFrameDeltas() function and converted into rotationDeltaCurrentFrame (taking speed into account)\n         * Reset to zero after each frame\n         */\n        this.rotationAccumulatedPixels = new Vector3();\n        /**\n         * ---------- Current Frame Movement Deltas -----------\n         * Deltas read on each frame by camera class in order to move the camera\n         * -----------------------------------\n         */\n        /**\n         * Zoom delta to apply to camera this frame, computed by computeCurrentFrameDeltas() from zoomPixelDelta (taking speed into account)\n         */\n        this.zoomDeltaCurrentFrame = 0;\n        /**\n         * Pan delta to apply to camera this frame, computed by computeCurrentFrameDeltas() from panPixelDelta (taking speed into account)\n         */\n        this.panDeltaCurrentFrame = Vector3.Zero();\n        /**\n         * Rotation delta to apply to camera this frame, computed by computeCurrentFrameDeltas() from rotationPixelDelta (taking speed into account)\n         */\n        this.rotationDeltaCurrentFrame = Vector3.Zero();\n        /**\n         * ---------- Velocity -----------\n         * Used to track velocity between frames for inertia calculation\n         * -----------------------------------\n         */\n        /**\n         * Zoom pixel velocity used for inertia calculations (pixels / ms).\n         */\n        this._zoomVelocity = 0;\n        /**\n         * Pan velocity used for inertia calculations (movement / time)\n         */\n        this._panVelocity = new Vector3();\n        /**\n         * Rotation velocity used for inertia calculations (movement / time)\n         */\n        this._rotationVelocity = new Vector3();\n        /**\n         * Used when calculating inertial decay. Default to 60fps\n         */\n        this._prevFrameTimeMs = FrameDurationAt60FPS;\n        this._scene = scene;\n    }\n    /**\n     * When called, will take the accumulated pixel deltas set by input classes and convert them into current frame deltas, stored in currentFrameMovementDelta properties\n     * Takes speed, scaling, inertia, and framerate into account to ensure smooth movement\n     * Zeros out pixelDeltas before returning\n     */\n    computeCurrentFrameDeltas() {\n        const deltaTimeMs = this._scene.getEngine().getDeltaTime();\n        this.panDeltaCurrentFrame.setAll(0);\n        this.rotationDeltaCurrentFrame.setAll(0);\n        this.zoomDeltaCurrentFrame = 0;\n        const hasUserInput = this.panAccumulatedPixels.lengthSquared() > 0 || this.rotationAccumulatedPixels.lengthSquared() > 0 || this.zoomAccumulatedPixels !== 0;\n        if (hasUserInput && this._behavior?.isInterpolating) {\n            this._behavior.stopAllAnimations();\n        }\n        this._panVelocity.copyFromFloats(this._calculateCurrentVelocity(this._panVelocity.x, this.panAccumulatedPixels.x, this.panInertia), this._calculateCurrentVelocity(this._panVelocity.y, this.panAccumulatedPixels.y, this.panInertia), this._calculateCurrentVelocity(this._panVelocity.z, this.panAccumulatedPixels.z, this.panInertia));\n        this._panVelocity.scaleToRef(this.panSpeed * this._panSpeedMultiplier * deltaTimeMs, this.panDeltaCurrentFrame);\n        this._rotationVelocity.copyFromFloats(this._calculateCurrentVelocity(this._rotationVelocity.x, this.rotationAccumulatedPixels.x, this.rotationInertia), this._calculateCurrentVelocity(this._rotationVelocity.y, this.rotationAccumulatedPixels.y, this.rotationInertia), this._calculateCurrentVelocity(this._rotationVelocity.z, this.rotationAccumulatedPixels.z, this.rotationInertia));\n        this.rotationDeltaCurrentFrame.copyFromFloats(this._rotationVelocity.x * this.rotationXSpeed * deltaTimeMs, this._rotationVelocity.y * this.rotationYSpeed * deltaTimeMs, this._rotationVelocity.z * this.rotationYSpeed * deltaTimeMs);\n        this._zoomVelocity = this._calculateCurrentVelocity(this._zoomVelocity, this.zoomAccumulatedPixels, this.zoomInertia);\n        this.zoomDeltaCurrentFrame = this._zoomVelocity * (this.zoomSpeed * this._zoomSpeedMultiplier) * deltaTimeMs;\n        this._prevFrameTimeMs = deltaTimeMs;\n        this.zoomAccumulatedPixels = 0;\n        this.panAccumulatedPixels.setAll(0);\n        this.rotationAccumulatedPixels.setAll(0);\n    }\n    get isInterpolating() {\n        return !!this._behavior?.isInterpolating;\n    }\n    _calculateCurrentVelocity(velocityRef, pixelDelta, inertialDecayFactor) {\n        let inputVelocity = velocityRef;\n        const deltaTimeMs = this._scene.getEngine().getDeltaTime();\n        // If we are actively receiving input or have accumulated some pixel delta since last frame, calculate inputVelocity (inertia doesn't kick in yet)\n        if (pixelDelta !== 0 || this.activeInput) {\n            inputVelocity = pixelDelta / deltaTimeMs;\n        }\n        else if (!this.activeInput && inputVelocity !== 0) {\n            // If we are not receiving input and velocity isn't already zero, apply inertial decay to decelerate velocity\n            const frameIndependentDecay = Math.pow(inertialDecayFactor, this._prevFrameTimeMs / FrameDurationAt60FPS);\n            inputVelocity *= frameIndependentDecay;\n            if (Math.abs(inputVelocity) <= Epsilon) {\n                inputVelocity = 0;\n            }\n        }\n        return inputVelocity;\n    }\n}\n//# sourceMappingURL=cameraMovement.js.map","import { CameraMovement } from \"./cameraMovement.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\nimport { Matrix, TmpVectors, Vector3 } from \"../Maths/math.vector.js\";\nimport { Plane } from \"../Maths/math.plane.js\";\nimport { Ray } from \"../Culling/ray.js\";\nimport { Vector3Distance } from \"../Maths/math.vector.functions.js\";\nimport { Clamp } from \"../Maths/math.scalar.functions.js\";\n/**\n * Geospatial-specific camera movement system that extends the base movement with\n * raycasting and altitude-aware zoom constraints.\n *\n * This class encapsulates geospatial camera movement logic:\n * - Dragging in a way which keeps cursor anchored to globe\n * - Latitude-based pan speed dampening\n * - Zoom speed scaling based on distance to center\n * - Raycasting to determine zoom constraints based on terrain/globe\n * - Altitude-based zoom clamping\n * - Zoom direction calculation (towards cursor vs along look vector)\n */\nexport class GeospatialCameraMovement extends CameraMovement {\n    constructor(scene, limits, cameraPosition, _cameraCenter, _cameraLookAt, pickPredicate, behavior) {\n        super(scene, cameraPosition, behavior);\n        this.limits = limits;\n        this._cameraCenter = _cameraCenter;\n        this._cameraLookAt = _cameraLookAt;\n        this.zoomToCursor = true;\n        this._hitPointRadius = undefined;\n        this._dragPlane = new Plane(0, 0, 0, 0);\n        this._dragPlaneNormal = Vector3.Zero();\n        this._dragPlaneOriginPointEcef = Vector3.Zero();\n        this._dragPlaneHitPointLocal = Vector3.Zero();\n        this._previousDragPlaneHitPointLocal = Vector3.Zero();\n        this.pickPredicate = pickPredicate;\n        this._tempPickingRay = new Ray(this._cameraPosition, this._cameraLookAt);\n        this.panInertia = 0;\n        this.rotationInertia = 0;\n        this.rotationXSpeed = Math.PI / 500; // Move 1/500th of a half circle per pixel\n        this.rotationYSpeed = Math.PI / 500; // Move 1/500th of a half circle per pixel\n        this.zoomSpeed = 2; // Base zoom speed; actual speed is scaled based on altitude\n    }\n    startDrag(pointerX, pointerY) {\n        const pickResult = this._scene.pick(pointerX, pointerY, this.pickPredicate);\n        if (pickResult.pickedPoint && pickResult.ray) {\n            // Store radius from earth center to pickedPoint, used when calculating drag plane\n            this._hitPointRadius = pickResult.pickedPoint.length();\n            this._recalculateDragPlaneHitPoint(this._hitPointRadius, pickResult.ray, TmpVectors.Matrix[0]);\n            this._previousDragPlaneHitPointLocal.copyFrom(this._dragPlaneHitPointLocal);\n        }\n        else {\n            this._hitPointRadius = undefined; // can't drag without a hit on the globe\n        }\n    }\n    stopDrag() {\n        this._hitPointRadius = undefined;\n    }\n    /**\n     * The previous drag plane hit point in local space is stored to compute the movement delta.\n     * As the drag movement occurs, we will continuously recalculate this point. The delta between the previous and current hit points is the delta we will apply to the camera's localtranslation\n     * @param hitPointRadius The distance between the world origin (center of globe) and the initial drag hit point\n     * @param ray The ray from the camera to the new cursor location\n     * @param localToEcefResult The matrix to convert from local to ECEF space\n     */\n    _recalculateDragPlaneHitPoint(hitPointRadius, ray, localToEcefResult) {\n        // Use the camera's geocentric normal to find the dragPlaneOriginPoint which lives at hitPointRadius along the camera's geocentric normal\n        this._cameraPosition.normalizeToRef(this._dragPlaneNormal);\n        this._dragPlaneNormal.scaleToRef(hitPointRadius, this._dragPlaneOriginPointEcef);\n        // The dragPlaneOffsetVector will later be recalculated when drag occurs, and the delta between the offset vectors will be applied to localTranslation\n        ComputeLocalBasisToRefs(this._dragPlaneOriginPointEcef, TmpVectors.Vector3[0], TmpVectors.Vector3[1], TmpVectors.Vector3[2]);\n        const localToEcef = Matrix.FromXYZAxesToRef(TmpVectors.Vector3[0], TmpVectors.Vector3[1], TmpVectors.Vector3[2], localToEcefResult);\n        localToEcef.setTranslationFromFloats(this._dragPlaneOriginPointEcef.x, this._dragPlaneOriginPointEcef.y, this._dragPlaneOriginPointEcef.z);\n        const ecefToLocal = localToEcef.invertToRef(TmpVectors.Matrix[1]);\n        // Now create a plane at that point, perpendicular to the camera's geocentric normal\n        Plane.FromPositionAndNormalToRef(this._dragPlaneOriginPointEcef, this._dragPlaneNormal, this._dragPlane);\n        // Lastly, find the _dragPlaneHitPoint where the ray intersects the _dragPlane.\n        if (IntersectRayWithPlaneToRef(ray, this._dragPlane, this._dragPlaneHitPointLocal)) {\n            // If hit, convert the drag plane hit point into the local space.\n            Vector3.TransformCoordinatesToRef(this._dragPlaneHitPointLocal, ecefToLocal, this._dragPlaneHitPointLocal);\n        }\n    }\n    handleDrag(pointerX, pointerY) {\n        if (this._hitPointRadius) {\n            const pickResult = this._scene.pick(pointerX, pointerY, this.pickPredicate);\n            if (pickResult.ray) {\n                const localToEcef = TmpVectors.Matrix[0];\n                this._recalculateDragPlaneHitPoint(this._hitPointRadius, pickResult.ray, localToEcef);\n                const delta = this._dragPlaneHitPointLocal.subtractToRef(this._previousDragPlaneHitPointLocal, TmpVectors.Vector3[6]);\n                // When the camera is pitched nearly parallel to the drag plane, ray-plane intersection\n                // can produce enormous deltas. Clamp the delta to avoid massive jumps.\n                const maxDragDelta = this._hitPointRadius * 0.1; // Max 10% of hit radius per frame\n                const deltaLength = delta.length();\n                if (deltaLength > maxDragDelta) {\n                    delta.scaleInPlace(maxDragDelta / deltaLength);\n                }\n                this._previousDragPlaneHitPointLocal.copyFrom(this._dragPlaneHitPointLocal);\n                Vector3.TransformNormalToRef(delta, localToEcef, delta);\n                this._dragPlaneOriginPointEcef.addInPlace(delta);\n                this.panAccumulatedPixels.subtractInPlace(delta);\n            }\n        }\n    }\n    /** @override */\n    computeCurrentFrameDeltas() {\n        const cameraCenter = this._cameraCenter;\n        // Slows down panning near the poles\n        if (this.panAccumulatedPixels.lengthSquared() > Epsilon) {\n            const centerRadius = cameraCenter.length(); // distance from planet origin to camera center\n            const currentRadius = this._cameraPosition.length();\n            // Dampen the pan speed based on latitude (slower near poles)\n            const sineOfSphericalLat = centerRadius === 0 ? 0 : cameraCenter.z / centerRadius;\n            const cosOfSphericalLat = Math.sqrt(1 - Math.min(1, sineOfSphericalLat * sineOfSphericalLat));\n            const latitudeDampening = Math.sqrt(Math.abs(cosOfSphericalLat)); // sqrt here reduces effect near equator\n            // Reduce the dampening effect near surface (so that at ground level, pan speed is not affected by latitude)\n            const height = Math.max(currentRadius - centerRadius, Epsilon);\n            const latitudeDampeningScale = Math.max(1, centerRadius / height);\n            this._panSpeedMultiplier = Clamp(latitudeDampeningScale * latitudeDampening, 0, 1);\n        }\n        else {\n            this._panSpeedMultiplier = 1;\n        }\n        // If a pan drag or rotate is occurring, stop zooming.\n        let zoomTargetDistance;\n        if (this.isDragging || this.rotationAccumulatedPixels.lengthSquared() > Epsilon) {\n            this._zoomSpeedMultiplier = 0;\n            this._zoomVelocity = 0;\n        }\n        else {\n            zoomTargetDistance = this.computedPerFrameZoomPickPoint ? Vector3Distance(this._cameraPosition, this.computedPerFrameZoomPickPoint) : undefined;\n            // Scales zoom movement speed based on camera distance to zoom target.\n            this._zoomSpeedMultiplier = (zoomTargetDistance ?? Vector3Distance(this._cameraPosition, cameraCenter)) * 0.01;\n        }\n        super.computeCurrentFrameDeltas();\n    }\n    get isDragging() {\n        return this._hitPointRadius !== undefined;\n    }\n    handleZoom(zoomDelta, toCursor) {\n        if (zoomDelta !== 0) {\n            this.zoomAccumulatedPixels += zoomDelta;\n            const pickResult = this._scene.pick(this._scene.pointerX, this._scene.pointerY, this.pickPredicate);\n            if (toCursor && pickResult.hit && pickResult.pickedPoint && pickResult.ray && this.zoomToCursor) {\n                this.computedPerFrameZoomPickPoint = pickResult.pickedPoint;\n            }\n            else {\n                // If no hit under cursor or explicitly told not to zoom to cursor, zoom along lookVector instead\n                const lookPickResult = this.pickAlongVector(this._cameraLookAt);\n                this.computedPerFrameZoomPickPoint = lookPickResult?.pickedPoint ?? undefined;\n            }\n        }\n    }\n    pickAlongVector(vector) {\n        this._tempPickingRay.origin.copyFrom(this._cameraPosition);\n        this._tempPickingRay.direction.copyFrom(vector);\n        return this._scene.pickWithRay(this._tempPickingRay, this.pickPredicate);\n    }\n}\n/** @internal */\nexport function ClampCenterFromPolesInPlace(center) {\n    const sineOfSphericalLatitudeLimit = 0.998749218; // ~90 degrees\n    const centerMagnitude = center.length(); // distance from planet origin\n    if (centerMagnitude > Epsilon) {\n        const sineSphericalLat = centerMagnitude === 0 ? 0 : center.z / centerMagnitude;\n        if (Math.abs(sineSphericalLat) > sineOfSphericalLatitudeLimit) {\n            // Clamp the spherical latitude (and derive longitude)\n            const sineOfClampedSphericalLat = Clamp(sineSphericalLat, -sineOfSphericalLatitudeLimit, sineOfSphericalLatitudeLimit);\n            const cosineOfClampedSphericalLat = Math.sqrt(1 - sineOfClampedSphericalLat * sineOfClampedSphericalLat);\n            const longitude = Math.atan2(center.y, center.x);\n            // Spherical to Cartesian\n            const newX = centerMagnitude * Math.cos(longitude) * cosineOfClampedSphericalLat;\n            const newY = centerMagnitude * Math.sin(longitude) * cosineOfClampedSphericalLat;\n            const newZ = centerMagnitude * sineOfClampedSphericalLat;\n            center.set(newX, newY, newZ);\n        }\n    }\n    return center;\n}\nfunction IntersectRayWithPlaneToRef(ray, plane, ref) {\n    // Distance along the ray to the plane; null if no hit\n    const dist = ray.intersectsPlane(plane);\n    if (dist !== null && dist >= 0) {\n        ray.origin.addToRef(ray.direction.scaleToRef(dist, TmpVectors.Vector3[0]), ref);\n        return true;\n    }\n    return false;\n}\n/**\n * Helper to build east/north/up basis vectors at a world position.\n * @internal\n */\nexport function ComputeLocalBasisToRefs(worldPos, refEast, refNorth, refUp) {\n    // up = normalized position (geocentric normal)\n    refUp.copyFrom(worldPos).normalize();\n    // east = normalize(worldNorth × up)\n    // (cross product of Earth rotation axis with up gives east except near poles)\n    const worldNorth = Vector3.LeftHandedForwardReadOnly; // (0,0,1)\n    Vector3.CrossToRef(worldNorth, refUp, refEast);\n    // at poles, cross with worldRight instead\n    if (refEast.lengthSquared() < Epsilon) {\n        Vector3.CrossToRef(Vector3.Right(), refUp, refEast);\n    }\n    refEast.normalize();\n    // north = up × east (completes right-handed basis)\n    Vector3.CrossToRef(refUp, refEast, refNorth);\n    refNorth.normalize();\n}\n//# sourceMappingURL=geospatialCameraMovement.js.map","import { GeospatialCameraInputsManager } from \"./geospatialCameraInputsManager.js\";\nimport { Vector3, Matrix, TmpVectors, Quaternion } from \"../Maths/math.vector.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\nimport { Camera } from \"./camera.js\";\nimport { GeospatialLimits } from \"./Limits/geospatialLimits.js\";\nimport { ClampCenterFromPolesInPlace, ComputeLocalBasisToRefs, GeospatialCameraMovement } from \"./geospatialCameraMovement.js\";\nimport { Vector3CopyToRef, Vector3Distance, Vector3Dot, Vector3SubtractToRef } from \"../Maths/math.vector.functions.js\";\nimport { Clamp, NormalizeRadians } from \"../Maths/math.scalar.functions.js\";\nimport { InterpolatingBehavior } from \"../Behaviors/Cameras/interpolatingBehavior.js\";\n/**\n * Camera equipped to orbit a spherical planet centered at world origin\n */\nexport class GeospatialCamera extends Camera {\n    constructor(name, scene, options) {\n        super(name, new Vector3(), scene);\n        // Temp vars\n        this._tempPosition = new Vector3();\n        this._tempCenter = new Vector3();\n        this._viewMatrix = new Matrix();\n        this._lookAtVector = new Vector3();\n        this._flyToTargets = new Map();\n        this._collisionVelocity = new Vector3();\n        /** Public option to customize the collision offset applied each frame - vs the one calculated using internal CollisionCoordinator */\n        this.perFrameCollisionOffset = new Vector3();\n        /** Enable or disable collision checking for this camera. Default is false. */\n        this.checkCollisions = false;\n        this._center = new Vector3();\n        this._yaw = 0;\n        this._pitch = 0;\n        this._radius = 0;\n        this._tempVect = new Vector3();\n        this._tempEast = new Vector3();\n        this._tempNorth = new Vector3();\n        this._tempUp = new Vector3();\n        this._wasCenterMovingLastFrame = false;\n        this._limits = new GeospatialLimits(options.planetRadius);\n        this._resetToDefault(this._limits);\n        this._flyingBehavior = new InterpolatingBehavior();\n        this.addBehavior(this._flyingBehavior);\n        this.movement = new GeospatialCameraMovement(scene, this._limits, this.position, this.center, this._lookAtVector, options.pickPredicate, this._flyingBehavior);\n        this.inputs = new GeospatialCameraInputsManager(this);\n        this.inputs.addMouse().addMouseWheel().addKeyboard();\n    }\n    /** The point on the globe that we are anchoring around. If no alternate rotation point is supplied, this will represent the center of screen*/\n    get center() {\n        return this._center;\n    }\n    /**\n     * Sets the camera position to orbit around a new center point\n     * @param center The world position (ECEF) to orbit around\n     */\n    set center(center) {\n        this._center.copyFromFloats(center.x, center.y, center.z);\n        this._setOrientation(this._yaw, this._pitch, this._radius, this._center);\n    }\n    /**\n     * Gets the camera's yaw (rotation around the geocentric normal) in radians\n     */\n    get yaw() {\n        return this._yaw;\n    }\n    /**\n     * Sets the camera's yaw (rotation around the geocentric normal). Will wrap value to [-π, π)\n     * @param yaw The desired yaw angle in radians (0 = north, π/2 = east)\n     */\n    set yaw(yaw) {\n        yaw !== this._yaw && this._setOrientation(yaw, this.pitch, this.radius, this.center);\n    }\n    /**\n     * Gets the camera's pitch (angle from looking straight at globe)\n     * Pitch is measured from looking straight down at planet center:\n     * - zero pitch = looking straight at planet center (down)\n     * - positive pitch = tilting up away from planet\n     * - π/2 pitch = looking at horizon (perpendicular to geocentric normal)\n     */\n    get pitch() {\n        return this._pitch;\n    }\n    /**\n     * Sets the camera's pitch (angle from looking straight at globe). Will wrap value to [-π, π)\n     * @param pitch The desired pitch angle in radians (0 = looking at planet center, π/2 = looking at horizon)\n     */\n    set pitch(pitch) {\n        pitch !== this._pitch && this._setOrientation(this.yaw, pitch, this.radius, this.center);\n    }\n    get radius() {\n        return this._radius;\n    }\n    /**\n     * Sets the camera's distance from the current center point\n     * @param radius The desired radius\n     */\n    set radius(radius) {\n        radius !== this._radius && this._setOrientation(this.yaw, this.pitch, radius, this.center);\n    }\n    _checkLimits() {\n        const limits = this.limits;\n        this._yaw = Clamp(this._yaw, limits.yawMin, limits.yawMax);\n        const effectivePitchMax = limits.getEffectivePitchMax(this._radius);\n        this._pitch = Clamp(this._pitch, limits.pitchMin, effectivePitchMax);\n        this._radius = Clamp(this._radius, limits.radiusMin, limits.radiusMax);\n        ClampCenterFromPolesInPlace(this._center);\n    }\n    _setOrientation(yaw, pitch, radius, center) {\n        // Wrap yaw and pitch to [-π, π)\n        this._yaw = NormalizeRadians(yaw);\n        this._pitch = NormalizeRadians(pitch);\n        this._radius = radius;\n        Vector3CopyToRef(center, this._center);\n        // Clamp to limits\n        this._checkLimits();\n        // Refresh local basis at center (treat these as read-only for the whole call)\n        ComputeLocalBasisToRefs(this._center, this._tempEast, this._tempNorth, this._tempUp);\n        // Compute lookAt from yaw/pitch\n        ComputeLookAtFromYawPitchToRef(this._yaw, this._pitch, this._center, this._scene.useRightHandedSystem, this._lookAtVector);\n        // Build an orthonormal up aligned with geocentric Up\n        // When looking straight down (pitch ≈ 0), lookAt is parallel to Up, so use the horizontal direction as the camera's up.\n        const right = TmpVectors.Vector3[10];\n        Vector3.CrossToRef(this._tempUp, this._lookAtVector, right);\n        if (right.lengthSquared() < Epsilon) {\n            // Looking straight down (or up) - use quaternion rotation to compute horiz\n            const horiz = TmpVectors.Vector3[11];\n            const yawScale = this._scene.useRightHandedSystem ? 1 : -1;\n            const yawQuat = TmpVectors.Quaternion[1];\n            Quaternion.RotationAxisToRef(this._tempUp, this._yaw * yawScale, yawQuat);\n            this._tempNorth.rotateByQuaternionToRef(yawQuat, horiz);\n            // right = cross(horiz, lookAt)\n            Vector3.CrossToRef(horiz, this._lookAtVector, right);\n        }\n        right.normalize();\n        // up = normalize(cross(look, right))\n        Vector3.CrossToRef(this._lookAtVector, right, this.upVector);\n        this.upVector.normalize();\n        // Position = center - look * radius  (preserve unit look)\n        this._tempVect.copyFrom(this._lookAtVector).scaleInPlace(-this._radius);\n        this._tempPosition.copyFrom(this._center).addInPlace(this._tempVect);\n        // Recalculate collisionOffset to be applied later when viewMatrix is calculated (allowing camera users to modify the value in afterCheckInputsObservable)\n        if (this.checkCollisions) {\n            this.perFrameCollisionOffset = this._getCollisionOffset(this._tempPosition);\n        }\n        this._position.copyFrom(this._tempPosition);\n        this._isViewMatrixDirty = true;\n    }\n    /**\n     * If camera is actively in flight, will update the target properties and use up the remaining duration from original flyTo call\n     *\n     * To start a new flyTo curve entirely, call into flyToAsync again (it will stop the inflight animation)\n     * @param targetYaw\n     * @param targetPitch\n     * @param targetRadius\n     * @param targetCenter\n     */\n    updateFlyToDestination(targetYaw, targetPitch, targetRadius, targetCenter) {\n        this._flyToTargets.clear();\n        // For yaw, use shortest path to target.\n        const deltaYaw = targetYaw !== undefined ? NormalizeRadians(NormalizeRadians(targetYaw) - this._yaw) : 0;\n        this._flyToTargets.set(\"yaw\", deltaYaw === 0 ? undefined : this._yaw + deltaYaw);\n        this._flyToTargets.set(\"pitch\", targetPitch != undefined ? NormalizeRadians(targetPitch) : undefined);\n        this._flyToTargets.set(\"radius\", targetRadius);\n        this._flyToTargets.set(\"center\", targetCenter?.clone());\n        this._flyingBehavior.updateProperties(this._flyToTargets);\n    }\n    /**\n     * Animate camera towards passed in property values. If undefined, will use current value\n     * @param targetYaw\n     * @param targetPitch\n     * @param targetRadius\n     * @param targetCenter\n     * @param flightDurationMs\n     * @param easingFunction\n     * @param centerHopScale If supplied, will define the parabolic hop height scale for center animation to create a \"bounce\" effect\n     * @returns Promise that will return when the animation is complete (or interuppted by pointer input)\n     */\n    async flyToAsync(targetYaw, targetPitch, targetRadius, targetCenter, flightDurationMs = 1000, easingFunction, centerHopScale) {\n        this._flyToTargets.clear();\n        // For yaw, use shortest path to target.\n        const deltaYaw = targetYaw !== undefined ? NormalizeRadians(NormalizeRadians(targetYaw) - this._yaw) : 0;\n        this._flyToTargets.set(\"yaw\", deltaYaw === 0 ? undefined : this._yaw + deltaYaw);\n        this._flyToTargets.set(\"pitch\", targetPitch !== undefined ? NormalizeRadians(targetPitch) : undefined);\n        this._flyToTargets.set(\"radius\", targetRadius);\n        this._flyToTargets.set(\"center\", targetCenter?.clone());\n        let overrideAnimationFunction;\n        if (targetCenter !== undefined && !targetCenter.equals(this.center)) {\n            // Animate center directly with custom interpolation\n            overrideAnimationFunction = (key, animation) => {\n                if (key === \"center\") {\n                    // Override the Vector3 interpolation to use SLERP + hop\n                    animation.vector3InterpolateFunction = (startValue, endValue, gradient) => {\n                        // gradient is the eased value (0 to 1) after easing function is applied\n                        // Slerp between start and end\n                        const newCenter = Vector3.SlerpToRef(startValue, endValue, gradient, this._tempCenter);\n                        // Apply parabolic hop if requested\n                        if (centerHopScale && centerHopScale > 0) {\n                            // Parabolic formula: peaks at t=0.5, returns to 0 at gradient=0 and gradient=1\n                            // if hopPeakT = .5 the denominator would be hopPeakT * hopPeakT - hopPeakT, which = -.25\n                            const hopPeakOffset = centerHopScale * Vector3Distance(startValue, endValue);\n                            const hopOffset = hopPeakOffset * Clamp((gradient * gradient - gradient) / -0.25);\n                            // Scale the center outward (away from origin)\n                            newCenter.scaleInPlace(1 + hopOffset / newCenter.length());\n                        }\n                        return newCenter;\n                    };\n                }\n            };\n        }\n        return await this._flyingBehavior.animatePropertiesAsync(this._flyToTargets, flightDurationMs, easingFunction, overrideAnimationFunction);\n    }\n    /**\n     * Helper function to move camera towards a given point by `distanceScale` of the current camera-to-destination distance (by default 50%).\n     * @param destination point to move towards\n     * @param distanceScale value between 0 and 1, % of distance to move\n     * @param durationMs duration of flight, default 1s\n     * @param easingFn optional easing function for flight interpolation of properties\n     * @param centerHopScale If supplied, will define the parabolic hop height scale for center animation to create a \"bounce\" effect\n     */\n    async flyToPointAsync(destination, distanceScale = 0.5, durationMs = 1000, easingFn, centerHopScale) {\n        // Move by a fraction of the camera-to-destination distance\n        const zoomDistance = Vector3Distance(this.position, destination) * distanceScale;\n        const newRadius = this._getCenterAndRadiusFromZoomToPoint(destination, zoomDistance, this._tempCenter);\n        await this.flyToAsync(undefined, undefined, newRadius, this._tempCenter, durationMs, easingFn, centerHopScale);\n    }\n    get limits() {\n        return this._limits;\n    }\n    _resetToDefault(limits) {\n        // Camera configuration vars\n        const restingAltitude = limits.radiusMax !== Infinity ? limits.radiusMax : limits.planetRadius * 4;\n        this.position.copyFromFloats(restingAltitude, 0, 0);\n        this._center.copyFromFloats(limits.planetRadius, 0, 0);\n        this._radius = Vector3.Distance(this.position, this.center);\n        // Temp vars\n        this._tempPosition = new Vector3();\n        // View matrix calculation vars\n        this._viewMatrix = Matrix.Identity();\n        this._center.subtractToRef(this._position, this._lookAtVector).normalize(); // Lookat vector of the camera\n        this.upVector = Vector3.Up(); // Up vector of the camera (does work for -X look at)\n        this._isViewMatrixDirty = true;\n        this._setOrientation(this._yaw, this._pitch, this._radius, this._center);\n    }\n    /** @internal */\n    _getViewMatrix() {\n        if (!this._isViewMatrixDirty) {\n            return this._viewMatrix;\n        }\n        this._isViewMatrixDirty = false;\n        // Ensure vectors are normalized\n        this.upVector.normalize();\n        this._lookAtVector.normalize();\n        // Apply the same offset to both position and center to preserve orbital relationship\n        // This keeps yaw/pitch/radius intact - just lifts the whole \"rig\"\n        this._position.addInPlace(this.perFrameCollisionOffset);\n        this._center.addInPlace(this.perFrameCollisionOffset);\n        // Calculate view matrix with camera position and center\n        if (this.getScene().useRightHandedSystem) {\n            Matrix.LookAtRHToRef(this.position, this._center, this.upVector, this._viewMatrix);\n        }\n        else {\n            Matrix.LookAtLHToRef(this.position, this._center, this.upVector, this._viewMatrix);\n        }\n        return this._viewMatrix;\n    }\n    /** @internal */\n    _isSynchronizedViewMatrix() {\n        if (!super._isSynchronizedViewMatrix() || this._isViewMatrixDirty) {\n            return false;\n        }\n        return true;\n    }\n    _applyGeocentricTranslation() {\n        // Store pending position (without any corrections applied)\n        this.center.addToRef(this.movement.panDeltaCurrentFrame, this._tempPosition);\n        if (!this.movement.isInterpolating) {\n            // Calculate the position correction to keep camera at the same radius when applying translation\n            this._tempPosition.normalize().scaleInPlace(this.center.length());\n        }\n        // Set center which will call _setOrientation\n        this.center = this._tempPosition;\n    }\n    /**\n     * This rotation keeps the camera oriented towards the globe as it orbits around it. This is different from cameraCentricRotation which is when the camera rotates around its own axis\n     */\n    _applyGeocentricRotation() {\n        const rotationDeltaCurrentFrame = this.movement.rotationDeltaCurrentFrame;\n        if (rotationDeltaCurrentFrame.x !== 0 || rotationDeltaCurrentFrame.y !== 0) {\n            const pitch = rotationDeltaCurrentFrame.x !== 0 ? Clamp(this._pitch + rotationDeltaCurrentFrame.x, 0, 0.5 * Math.PI - Epsilon) : this._pitch;\n            const yaw = rotationDeltaCurrentFrame.y !== 0 ? this._yaw + rotationDeltaCurrentFrame.y : this._yaw;\n            this._setOrientation(yaw, pitch, this._radius, this._center);\n        }\n    }\n    _getCenterAndRadiusFromZoomToPoint(targetPoint, distance, newCenterResult) {\n        const directionToTarget = Vector3SubtractToRef(targetPoint, this._position, TmpVectors.Vector3[0]);\n        const distanceToTarget = directionToTarget.length();\n        // Don't zoom past the min radius limit.\n        if (distanceToTarget < this.limits.radiusMin) {\n            newCenterResult.copyFrom(this._center);\n            const requestedRadius = this._radius - distance;\n            const newRadius = Clamp(requestedRadius, this.limits.radiusMin, this.limits.radiusMax);\n            return newRadius;\n        }\n        // Move the camera position towards targetPoint by distanceToTarget\n        directionToTarget.scaleInPlace(distance / distanceToTarget);\n        const newPosition = this._position.addToRef(directionToTarget, TmpVectors.Vector3[1]);\n        // Project the movement onto the look vector to derive the new center/radius.\n        const projectedDistance = Vector3Dot(directionToTarget, this._lookAtVector);\n        const newRadius = this._radius - projectedDistance;\n        const newRadiusClamped = Clamp(newRadius, this.limits.radiusMin, this.limits.radiusMax);\n        newCenterResult.copyFrom(newPosition).addInPlace(this._lookAtVector.scale(newRadiusClamped));\n        return newRadiusClamped;\n    }\n    /**\n     * Apply zoom by moving the camera toward/away from a target point.\n     */\n    _applyZoom() {\n        let zoomDelta = this.movement.zoomDeltaCurrentFrame;\n        const pickedPoint = this.movement.computedPerFrameZoomPickPoint;\n        // Clamp zoom delta to limits before applying\n        zoomDelta = this._clampZoomDelta(zoomDelta, pickedPoint);\n        if (Math.abs(zoomDelta) < Epsilon) {\n            return;\n        }\n        if (pickedPoint) {\n            // Zoom toward the picked point under cursor\n            this.zoomToPoint(pickedPoint, zoomDelta);\n        }\n        else {\n            // Zoom along lookAt vector (fallback when no surface under cursor)\n            this.zoomAlongLookAt(zoomDelta);\n        }\n    }\n    _clampZoomDelta(zoomDelta, pickedPoint) {\n        if (Math.abs(zoomDelta) < Epsilon) {\n            return 0;\n        }\n        const distanceToTarget = pickedPoint ? Vector3Distance(this._position, pickedPoint) : undefined;\n        return this.limits.clampZoomDistance(zoomDelta, this._radius, distanceToTarget);\n    }\n    zoomToPoint(targetPoint, distance) {\n        const newRadius = this._getCenterAndRadiusFromZoomToPoint(targetPoint, distance, this._tempCenter);\n        // Apply the new orientation\n        this._setOrientation(this._yaw, this._pitch, newRadius, this._tempCenter);\n    }\n    zoomAlongLookAt(distance) {\n        // Clamp radius to limits\n        const requestedRadius = this._radius - distance;\n        const newRadius = Clamp(requestedRadius, this.limits.radiusMin, this.limits.radiusMax);\n        // Simply change radius without moving center\n        this._setOrientation(this._yaw, this._pitch, newRadius, this._center);\n    }\n    _checkInputs() {\n        this.inputs.checkInputs();\n        this.perFrameCollisionOffset.setAll(0);\n        // Let movement class handle all per-frame logic\n        this.movement.computeCurrentFrameDeltas();\n        let isCenterMoving = false;\n        if (this.movement.panDeltaCurrentFrame.lengthSquared() > 0) {\n            this._applyGeocentricTranslation();\n            // After a drag, recalculate the center point to ensure it's still on the surface.\n            isCenterMoving = true;\n        }\n        if (this.movement.rotationDeltaCurrentFrame.lengthSquared() > 0) {\n            this._applyGeocentricRotation();\n        }\n        if (Math.abs(this.movement.zoomDeltaCurrentFrame) > Epsilon) {\n            this._applyZoom();\n            isCenterMoving = true;\n        }\n        // After a movement impacting center or radius, recalculate the center point to ensure it's still on the surface.\n        this._recalculateCenter(isCenterMoving);\n        super._checkInputs();\n    }\n    _recalculateCenter(isCenterMoving) {\n        const shouldRecalculateCenterAfterMove = this._wasCenterMovingLastFrame && !isCenterMoving;\n        this._wasCenterMovingLastFrame = isCenterMoving;\n        // Wait until movement impacting center is complete to avoid wasted raycasting\n        if (shouldRecalculateCenterAfterMove) {\n            const newCenter = this.movement.pickAlongVector(this._lookAtVector);\n            if (newCenter?.pickedPoint) {\n                // Direction from new center to origin\n                const centerToOrigin = TmpVectors.Vector3[4];\n                centerToOrigin.copyFrom(newCenter.pickedPoint).negateInPlace().normalize();\n                // Check if this direction aligns with camera's lookAt vector\n                const dotProduct = Vector3Dot(this._lookAtVector, centerToOrigin);\n                // Only update if the center is looking toward the origin (dot product > 0) to avoid a center on the opposite side of globe\n                if (dotProduct > 0) {\n                    // Compute the new radius as distance from camera position to new center\n                    const newRadius = Vector3Distance(this._position, newCenter.pickedPoint);\n                    // Only update if the new center is in front of the camera\n                    if (newRadius > Epsilon) {\n                        // Compute yaw/pitch that correspond to current lookAt at new center\n                        const yawPitch = TmpVectors.Vector2[0];\n                        ComputeYawPitchFromLookAtToRef(this._lookAtVector, newCenter.pickedPoint, this._scene.useRightHandedSystem, this._yaw, yawPitch);\n                        // Call _setOrientation with the computed yaw/pitch and new center\n                        this._setOrientation(yawPitch.x, yawPitch.y, newRadius, newCenter.pickedPoint);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Allows extended classes to override how collision offset is calculated\n     * @param newPosition\n     * @returns\n     */\n    _getCollisionOffset(newPosition) {\n        const collisionOffset = TmpVectors.Vector3[6].setAll(0);\n        if (!this.checkCollisions || !this._scene.collisionsEnabled) {\n            return collisionOffset;\n        }\n        const coordinator = this.getScene().collisionCoordinator;\n        if (!coordinator) {\n            return collisionOffset;\n        }\n        if (!this._collider) {\n            this._collider = coordinator.createCollider();\n        }\n        this._collider._radius.setAll(this.limits.radiusMin);\n        // Calculate velocity from old position to new position\n        newPosition.subtractToRef(this._position, this._collisionVelocity);\n        // Get the collision-adjusted position\n        const adjustedPosition = coordinator.getNewPosition(this._position, this._collisionVelocity, this._collider, 3, null, () => { }, this.uniqueId);\n        // Calculate the collision offset (how much the position was pushed)\n        adjustedPosition.subtractToRef(newPosition, collisionOffset);\n        return collisionOffset;\n    }\n    attachControl(noPreventDefault) {\n        this.inputs.attachElement(noPreventDefault);\n    }\n    detachControl() {\n        this.inputs.detachElement();\n    }\n}\n/**\n * Compute the lookAt direction vector from yaw and pitch angles at a given center point.\n * This is the forward formula used by GeospatialCamera._setOrientation.\n * @param yaw - The yaw angle in radians (0 = north, π/2 = east)\n * @param pitch - The pitch angle in radians (0 = looking at planet center, π/2 = looking at horizon)\n * @param center - The center point on the globe\n * @param useRightHandedSystem - Whether the scene uses a right-handed coordinate system\n * @param result - The vector to store the result in\n * @returns The normalized lookAt direction vector (same as result)\n */\nexport function ComputeLookAtFromYawPitchToRef(yaw, pitch, center, useRightHandedSystem, result) {\n    const east = TmpVectors.Vector3[0];\n    const north = TmpVectors.Vector3[1];\n    const up = TmpVectors.Vector3[2];\n    ComputeLocalBasisToRefs(center, east, north, up);\n    const sinPitch = Math.sin(pitch);\n    const cosPitch = Math.cos(pitch);\n    // Use quaternion rotation to compute horiz = rotate(north, up, yaw * yawScale)\n    const yawScale = useRightHandedSystem ? 1 : -1;\n    const yawQuat = TmpVectors.Quaternion[0];\n    Quaternion.RotationAxisToRef(up, yaw * yawScale, yawQuat);\n    const horiz = TmpVectors.Vector3[3];\n    north.rotateByQuaternionToRef(yawQuat, horiz);\n    // lookAt = horiz * sinPitch - up * cosPitch\n    const t2 = TmpVectors.Vector3[4];\n    result.copyFrom(horiz).scaleInPlace(sinPitch).addInPlace(t2.copyFrom(up).scaleInPlace(-cosPitch));\n    return result.normalize();\n}\n/**\n * Given a lookAt direction and center, compute the yaw and pitch angles that would produce that lookAt.\n * This is the inverse of ComputeLookAtFromYawPitchToRef.\n * @param lookAt - The normalized lookAt direction vector\n * @param center - The center point on the globe\n * @param useRightHandedSystem - Whether the scene uses a right-handed coordinate system\n * @param currentYaw - The current yaw value to use as fallback when pitch is near 0 (looking straight down/up)\n * @param result - The Vector2 to store the result in (x = yaw, y = pitch)\n * @returns The result Vector2\n */\nexport function ComputeYawPitchFromLookAtToRef(lookAt, center, useRightHandedSystem, currentYaw, result) {\n    // Compute local basis at center\n    const east = TmpVectors.Vector3[6];\n    const north = TmpVectors.Vector3[7];\n    const up = TmpVectors.Vector3[8];\n    ComputeLocalBasisToRefs(center, east, north, up);\n    // lookAt = horiz*sinPitch - up*cosPitch\n    // where horiz = rotate(north, up, yaw * yawScale) via quaternion\n    //\n    // The vertical component of lookAt (along up) gives us cosPitch:\n    // lookAt · up = -cosPitch\n    const lookDotUp = Vector3Dot(lookAt, up);\n    const cosPitch = -lookDotUp;\n    // Clamp cosPitch to valid range to avoid NaN from acos\n    const clampedCosPitch = Clamp(cosPitch, -1, 1);\n    const pitch = Math.acos(clampedCosPitch);\n    // The horizontal component gives us yaw\n    // lookHorizontal = lookAt + up*cosPitch = horiz*sinPitch\n    const lookHorizontal = TmpVectors.Vector3[9];\n    const scaledUp = TmpVectors.Vector3[10];\n    scaledUp.copyFrom(up).scaleInPlace(cosPitch);\n    lookHorizontal.copyFrom(lookAt).addInPlace(scaledUp);\n    const sinPitch = Math.sin(pitch);\n    if (Math.abs(sinPitch) < Epsilon) {\n        // Looking straight down or up, yaw is undefined - keep current\n        result.x = currentYaw;\n        result.y = pitch;\n        return result;\n    }\n    // horiz = lookHorizontal / sinPitch\n    const horiz = lookHorizontal.scaleInPlace(1 / sinPitch);\n    // The quaternion rotation produces: horiz = rotate(north, up, angle)\n    // This is equivalent to: horiz = north*cos(angle) + cross(up, north)*sin(angle) = north*cos(angle) - east*sin(angle)\n    // (since cross(up, north) = -east in our basis)\n    // So: cosYaw = horiz · north, sinYaw = -(horiz · east)\n    const cosYaw = Vector3Dot(horiz, north);\n    const sinYaw = -Vector3Dot(horiz, east);\n    const yawScale = useRightHandedSystem ? 1 : -1;\n    result.x = Math.atan2(sinYaw, cosYaw) * yawScale;\n    result.y = pitch;\n    return result;\n}\n//# sourceMappingURL=geospatialCamera.js.map","import { Scene, Engine, GeospatialCamera, Vector3, Color4 } from '@babylonjs/core';\nimport { GeospatialClippingBehavior } from '@babylonjs/core/Behaviors/Cameras';\nimport { TilesRenderer } from '3d-tiles-renderer/babylonjs';\nimport { CesiumIonAuthPlugin } from '3d-tiles-renderer/core/plugins';\nimport GUI from 'lil-gui';\n\nconst GOOGLE_TILES_ASSET_ID = 2275207;\n\nconst PLANET_RADIUS = 6378137;\n\n// gui\nconst params = {\n\tenabled: true,\n\tvisibleTiles: 0,\n\terrorTarget: 20,\n\tminZ: 0,\n\tmaxZ: 0,\n};\n\nconst gui = new GUI();\ngui.add( params, 'enabled' );\ngui.add( params, 'visibleTiles' ).name( 'Visible Tiles' ).listen().disable();\ngui.add( params, 'errorTarget', 1, 100 );\ngui.add( params, 'minZ' ).name( 'Camera MinZ' ).listen().disable();\ngui.add( params, 'maxZ' ).name( 'Camera MaxZ' ).listen().disable();\n\n// engine\nconst canvas = document.getElementById( 'renderCanvas' );\nconst engine = new Engine( canvas, true, { useLargeWorldRendering: true } );\nengine.setHardwareScalingLevel( 1 / window.devicePixelRatio );\n\n// scene\nconst scene = new Scene( engine );\nscene.clearColor = new Color4( 0.05, 0.05, 0.05, 1 );\n\n// 3D Tiles data uses right-handed coordinate system\nscene.useRightHandedSystem = true;\n\n// camera\nconst camera = new GeospatialCamera( 'geo', scene, { planetRadius: PLANET_RADIUS } );\n\ncamera.attachControl( true );\nconst clippingBehavior = new GeospatialClippingBehavior();\ncamera.addBehavior( clippingBehavior );\n\n// Start farther out, then fly in once tiles are loaded\ncamera.radius = 50000;\n\n// Set center to Tokyo Tower location (ECEF coordinates)\n// Tokyo Tower: 35.6586° N, 139.7454° E\ncamera.center = new Vector3( - 3959611.825621192, 3352599.0363458656, 3697549.0362687325 );\ncamera.pitch = 1.167625429373872;\ncamera.yaw = - 0.2513281792775774;\n\ncamera.checkCollisions = true;\nscene.collisionsEnabled = true;\n\n// Fly to close view once tiles load\nlet hasZoomedIn = false;\n\n// tiles\nconst tiles = new TilesRenderer( null, scene );\ntiles.registerPlugin( new CesiumIonAuthPlugin( {\n\tapiToken: import.meta.env.VITE_ION_KEY,\n\tassetId: GOOGLE_TILES_ASSET_ID,\n\tautoRefreshToken: true,\n} ) );\ntiles.errorTarget = params.errorTarget;\n\n// Babylon render loop\n\nscene.onBeforeRenderObservable.add( () => {\n\n\tif ( params.enabled ) {\n\n\t\ttiles.errorTarget = params.errorTarget;\n\t\ttiles.update();\n\t\tparams.visibleTiles = tiles.visibleTiles.size;\n\t\tparams.minZ = camera.minZ;\n\t\tparams.maxZ = camera.maxZ;\n\n\n\t\t// Once we have some tiles visible, fly in to target\n\t\tif ( ! hasZoomedIn && tiles.visibleTiles.size > 5 ) {\n\n\t\t\thasZoomedIn = true;\n\t\t\tcamera.flyToAsync( undefined, undefined, 300, undefined, 2000 );\n\n\t\t}\n\n\t}\n\n\t// update attributions\n\tconst attributions = tiles.getAttributions();\n\tconst creditsEl = document.getElementById( 'credits' );\n\tcreditsEl.innerText = attributions[ 0 ]?.value || '';\n\n} );\n\nengine.runRenderLoop( () => {\n\n\tscene.render();\n\n} );\n\n// Handle window resize\nwindow.addEventListener( 'resize', () => {\n\n\tengine.resize();\n\n} );\n"],"names":["InterpolatingBehavior","CubicEase","EasingFunction","camera","animatable","_a","properties","value","key","transitionDuration","easingFn","updateAnimation","resolve","scene","checkClear","propertyName","i","animation","Animation","GetAnimationType","IsQuaternionLike","v","IsMatrixLike","IsVector3Like","IsVector2Like","IsColor3Like","IsColor4Like","IsSizeLike","GeospatialClippingBehavior","planetRadius","altitude","horizonDist","GeospatialCameraPointersInput","OrbitCameraPointersInput","evt","point","offsetX","offsetY","button","previousPinchSquaredDistance","pinchSquaredDistance","previousDistance","pinchDelta","canvasRect","canvasX","canvasY","pickResult","distanceToPoint","zoomDistance","clampedZoom","previousMultiTouchPanPosition","multiTouchPanPosition","moveDeltaX","moveDeltaY","type","pointA","pointB","cumulativeDelta","_evt","deltaX","deltaY","GeospatialCameraInputsManager","CameraInputsManager","GeospatialCameraMouseWheelInput","GeospatialCameraKeyboardInput","GeospatialLimits","Epsilon","Vector2","currentRadius","distanceToTarget","maxZoomIn","maxZoomOut","fullPitchRadius","noPitchRadius","t","clampedT","Clamp","FrameDurationAt60FPS","CameraMovement","_cameraPosition","_behavior","Vector3","deltaTimeMs","velocityRef","pixelDelta","inertialDecayFactor","inputVelocity","frameIndependentDecay","GeospatialCameraMovement","limits","cameraPosition","_cameraCenter","_cameraLookAt","pickPredicate","behavior","Plane","Ray","pointerX","pointerY","TmpVectors","hitPointRadius","ray","localToEcefResult","ComputeLocalBasisToRefs","localToEcef","Matrix","ecefToLocal","IntersectRayWithPlaneToRef","delta","maxDragDelta","deltaLength","cameraCenter","centerRadius","sineOfSphericalLat","cosOfSphericalLat","latitudeDampening","height","latitudeDampeningScale","zoomTargetDistance","Vector3Distance","zoomDelta","toCursor","lookPickResult","vector","ClampCenterFromPolesInPlace","center","sineOfSphericalLatitudeLimit","centerMagnitude","sineSphericalLat","sineOfClampedSphericalLat","cosineOfClampedSphericalLat","longitude","newX","newY","newZ","plane","ref","dist","worldPos","refEast","refNorth","refUp","worldNorth","GeospatialCamera","Camera","name","options","yaw","pitch","radius","effectivePitchMax","NormalizeRadians","Vector3CopyToRef","ComputeLookAtFromYawPitchToRef","right","horiz","yawScale","yawQuat","Quaternion","targetYaw","targetPitch","targetRadius","targetCenter","deltaYaw","flightDurationMs","easingFunction","centerHopScale","overrideAnimationFunction","startValue","endValue","gradient","newCenter","hopOffset","destination","distanceScale","durationMs","newRadius","restingAltitude","rotationDeltaCurrentFrame","targetPoint","distance","newCenterResult","directionToTarget","Vector3SubtractToRef","requestedRadius","newPosition","projectedDistance","Vector3Dot","newRadiusClamped","pickedPoint","isCenterMoving","shouldRecalculateCenterAfterMove","centerToOrigin","yawPitch","ComputeYawPitchFromLookAtToRef","collisionOffset","coordinator","noPreventDefault","useRightHandedSystem","result","east","north","up","sinPitch","cosPitch","t2","lookAt","currentYaw","clampedCosPitch","lookHorizontal","scaledUp","cosYaw","sinYaw","GOOGLE_TILES_ASSET_ID","PLANET_RADIUS","params","gui","GUI","canvas","engine","Engine","Scene","Color4","clippingBehavior","hasZoomedIn","tiles","TilesRenderer","CesiumIonAuthPlugin","attributions","creditsEl"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7]}