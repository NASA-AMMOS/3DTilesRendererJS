import{M as P,as as B,m as p,l as O,d as Q,ae as tt,aO as et}from"./three.module-DBfedTbk.js";const y=new B,I=new p,it={};function ot(r){const{x:e,y:t,z:i}=r;r.x=i,r.y=e,r.z=t}function st(r){return-(r-Math.PI/2)}function H(r){return-r+Math.PI/2}function nt(r,e,t={}){return y.theta=e,y.phi=H(r),I.setFromSpherical(y),y.setFromVector3(I),t.lat=st(y.phi),t.lon=y.theta,t}function X(r,e="E",t="W"){const i=r<0?t:e;r=Math.abs(r);const o=~~r,s=(r-o)*60,n=~~s,u=~~((s-n)*60);return`${o}° ${n}' ${u}" ${i}`}function lt(r,e,t=!1){const i=nt(r,e,it);let o,s;return t?(o=`${(P.RAD2DEG*i.lat).toFixed(4)}°`,s=`${(P.RAD2DEG*i.lon).toFixed(4)}°`):(o=X(P.RAD2DEG*i.lat,"N","S"),s=X(P.RAD2DEG*i.lon,"E","W")),`${o} ${s}`}const Y=new B,d=new p,c=new p,b=new p,h=new O,m=new O,Z=new O,D=new Q,l=new et,G=new p,V=new p,L=new p,M=new p,S=new tt,rt=1e-12,at=.1,f=0,W=1,g=2;class ht{constructor(e=1,t=1,i=1){this.name="",this.radius=new p(e,t,i)}intersectRay(e,t){return h.makeScale(...this.radius).invert(),D.center.set(0,0,0),D.radius=1,S.copy(e).applyMatrix4(h),S.intersectSphere(D,t)?(h.makeScale(...this.radius),t.applyMatrix4(h),t):null}getEastNorthUpFrame(e,t,i,o){return i.isMatrix4&&(o=i,i=0,console.warn('Ellipsoid: The signature for "getEastNorthUpFrame" has changed.')),this.getEastNorthUpAxes(e,t,G,V,L),this.getCartographicToPosition(e,t,i,M),o.makeBasis(G,V,L).setPosition(M)}getOrientedEastNorthUpFrame(e,t,i,o,s,n,a){return this.getObjectFrame(e,t,i,o,s,n,a,f)}getObjectFrame(e,t,i,o,s,n,a,u=g){return this.getEastNorthUpFrame(e,t,i,h),l.set(s,n,-o,"ZXY"),a.makeRotationFromEuler(l).premultiply(h),u===W?(l.set(Math.PI/2,0,0,"XYZ"),m.makeRotationFromEuler(l),a.multiply(m)):u===g&&(l.set(-Math.PI/2,0,Math.PI,"XYZ"),m.makeRotationFromEuler(l),a.multiply(m)),a}getCartographicFromObjectFrame(e,t,i=g){return i===W?(l.set(-Math.PI/2,0,0,"XYZ"),m.makeRotationFromEuler(l).premultiply(e)):i===g?(l.set(-Math.PI/2,0,Math.PI,"XYZ"),m.makeRotationFromEuler(l).premultiply(e)):m.copy(e),M.setFromMatrixPosition(m),this.getPositionToCartographic(M,t),this.getEastNorthUpFrame(t.lat,t.lon,0,h).invert(),m.premultiply(h),l.setFromRotationMatrix(m,"ZXY"),t.azimuth=-l.z,t.elevation=l.x,t.roll=l.y,t}getEastNorthUpAxes(e,t,i,o,s,n=M){this.getCartographicToPosition(e,t,0,n),this.getCartographicToNormal(e,t,s),i.set(-n.y,n.x,0).normalize(),o.crossVectors(s,i).normalize()}getAzElRollFromRotationMatrix(e,t,i,o,s=f){return console.warn('Ellipsoid: "getAzElRollFromRotationMatrix" is deprecated. Use "getCartographicFromObjectFrame", instead.'),this.getCartographicToPosition(e,t,0,M),Z.copy(i).setPosition(M),this.getCartographicFromObjectFrame(Z,o,s),delete o.height,delete o.lat,delete o.lon,o}getRotationMatrixFromAzElRoll(e,t,i,o,s,n,a=f){return console.warn('Ellipsoid: "getRotationMatrixFromAzElRoll" function has been deprecated. Use "getObjectFrame", instead.'),this.getObjectFrame(e,t,0,i,o,s,n,a),n.setPosition(0,0,0),n}getFrame(e,t,i,o,s,n,a,u=f){return console.warn('Ellipsoid: "getFrame" function has been deprecated. Use "getObjectFrame", instead.'),this.getObjectFrame(e,t,n,i,o,s,a,u)}getCartographicToPosition(e,t,i,o){this.getCartographicToNormal(e,t,d);const s=this.radius;c.copy(d),c.x*=s.x**2,c.y*=s.y**2,c.z*=s.z**2;const n=Math.sqrt(d.dot(c));return c.divideScalar(n),o.copy(c).addScaledVector(d,i)}getPositionToCartographic(e,t){this.getPositionToSurfacePoint(e,c),this.getPositionToNormal(e,d);const i=b.subVectors(e,c);return t.lon=Math.atan2(d.y,d.x),t.lat=Math.asin(d.z),t.height=Math.sign(i.dot(e))*i.length(),t}getCartographicToNormal(e,t,i){return Y.set(1,H(e),t),i.setFromSpherical(Y).normalize(),ot(i),i}getPositionToNormal(e,t){const i=this.radius;return t.copy(e),t.x/=i.x**2,t.y/=i.y**2,t.z/=i.z**2,t.normalize(),t}getPositionToSurfacePoint(e,t){const i=this.radius,o=1/i.x**2,s=1/i.y**2,n=1/i.z**2,a=e.x*e.x*o,u=e.y*e.y*s,w=e.z*e.z*n,v=a+u+w,T=Math.sqrt(1/v),R=c.copy(e).multiplyScalar(T);if(v<at)return isFinite(T)?t.copy(R):null;const J=b.set(R.x*o*2,R.y*s*2,R.z*n*2);let z=(1-T)*e.length()/(.5*J.length()),U=0,_,j,E,x,F,A,N,C,k,q,$;do{z-=U,E=1/(1+z*o),x=1/(1+z*s),F=1/(1+z*n),A=E*E,N=x*x,C=F*F,k=A*E,q=N*x,$=C*F,_=a*A+u*N+w*C-1,j=a*k*o+u*q*s+w*$*n;const K=-2*j;U=_/K}while(Math.abs(_)>rt);return t.set(e.x*E,e.y*x,e.z*F)}calculateHorizonDistance(e,t){const i=this.calculateEffectiveRadius(e);return Math.sqrt(2*i*t+t**2)}calculateEffectiveRadius(e){const t=this.radius.x,o=1-this.radius.z**2/t**2,s=e*P.DEG2RAD,n=Math.sin(s)**2;return t/Math.sqrt(1-o*n)}getPositionElevation(e){this.getPositionToSurfacePoint(e,c);const t=b.subVectors(e,c);return Math.sign(t.dot(e))*t.length()}closestPointToRayEstimate(e,t){return this.intersectRay(e,t)?t:(h.makeScale(...this.radius).invert(),S.copy(e).applyMatrix4(h),c.set(0,0,0),S.closestPointToPoint(c,t).normalize(),h.makeScale(...this.radius),t.applyMatrix4(h))}copy(e){return this.radius.copy(e.radius),this}clone(){return new this.constructor().copy(this)}}export{W as C,ht as E,g as O,lt as t};
//# sourceMappingURL=Ellipsoid-CLPX16sm.js.map
