{"version":3,"file":"GlobeControls-CXYtrMsa.js","sources":["../../../src/three/renderer/controls/GlobeControls.js"],"sourcesContent":["import {\n\tMatrix4,\n\tQuaternion,\n\tVector2,\n\tVector3,\n\tMathUtils,\n\tRay,\n\tGroup,\n} from 'three';\nimport { DRAG, ZOOM, EnvironmentControls, NONE } from './EnvironmentControls.js';\nimport { makeRotateAroundPoint, mouseToCoords, setRaycasterFromCamera } from './utils.js';\nimport { Ellipsoid } from '../math/Ellipsoid.js';\nimport { WGS84_ELLIPSOID } from '../math/GeoConstants.js';\n\nconst _invMatrix = /* @__PURE__ */ new Matrix4();\nconst _rotMatrix = /* @__PURE__ */ new Matrix4();\nconst _pos = /* @__PURE__ */ new Vector3();\nconst _vec = /* @__PURE__ */ new Vector3();\nconst _center = /* @__PURE__ */ new Vector3();\nconst _forward = /* @__PURE__ */ new Vector3();\nconst _targetRight = /* @__PURE__ */ new Vector3();\nconst _globalUp = /* @__PURE__ */ new Vector3();\nconst _quaternion = /* @__PURE__ */ new Quaternion();\nconst _zoomPointUp = /* @__PURE__ */ new Vector3();\nconst _toCenter = /* @__PURE__ */ new Vector3();\nconst _ray = /* @__PURE__ */ new Ray();\nconst _ellipsoid = /* @__PURE__ */ new Ellipsoid();\nconst _pointer = /* @__PURE__ */ new Vector2();\nconst _latLon = {};\n\n// hand picked minimum elevation to tune far plane near surface\nconst MIN_ELEVATION = 2550;\nexport class GlobeControls extends EnvironmentControls {\n\n\tget tilesGroup() {\n\n\t\tconsole.warn( 'GlobeControls: \"tilesGroup\" has been deprecated. Use \"ellipsoidGroup\", instead.' );\n\t\treturn this.ellipsoidFrame;\n\n\t}\n\n\tget ellipsoidFrame() {\n\n\t\treturn this.ellipsoidGroup.matrixWorld;\n\n\t}\n\n\tget ellipsoidFrameInverse() {\n\n\t\tconst { ellipsoidGroup, ellipsoidFrame, _ellipsoidFrameInverse } = this;\n\t\treturn ellipsoidGroup.matrixWorldInverse ?\n\t\t\tellipsoidGroup.matrixWorldInverse :\n\t\t\t_ellipsoidFrameInverse.copy( ellipsoidFrame ).invert();\n\n\t}\n\n\tconstructor( scene = null, camera = null, domElement = null, tilesRenderer = null ) {\n\n\t\t// store which mode the drag stats are in\n\t\tsuper( scene, camera, domElement );\n\n\t\tthis.isGlobeControls = true;\n\n\t\tthis._dragMode = 0;\n\t\tthis._rotationMode = 0;\n\t\tthis.maxZoom = 0.01;\n\t\tthis.nearMargin = 0.25;\n\t\tthis.farMargin = 0;\n\t\tthis.useFallbackPlane = false;\n\t\tthis.autoAdjustCameraRotation = false;\n\n\t\tthis.globeInertia = new Quaternion();\n\t\tthis.globeInertiaFactor = 0;\n\n\t\tthis.ellipsoid = WGS84_ELLIPSOID.clone();\n\t\tthis.ellipsoidGroup = new Group();\n\t\tthis._ellipsoidFrameInverse = new Matrix4();\n\n\t\tif ( tilesRenderer !== null ) {\n\n\t\t\tthis.setTilesRenderer( tilesRenderer );\n\n\t\t}\n\n\t}\n\n\tsetTilesRenderer( tilesRenderer ) {\n\n\t\tsuper.setTilesRenderer( tilesRenderer );\n\t\tif ( tilesRenderer !== null ) {\n\n\t\t\tthis.setEllipsoid( tilesRenderer.ellipsoid, tilesRenderer.group );\n\n\t\t}\n\n\t}\n\n\tsetEllipsoid( ellipsoid, ellipsoidGroup ) {\n\n\t\tthis.ellipsoid = ellipsoid || WGS84_ELLIPSOID.clone();\n\t\tthis.ellipsoidGroup = ellipsoidGroup || new Group();\n\n\t}\n\n\tgetPivotPoint( target ) {\n\n\t\tconst { camera, ellipsoidFrame, ellipsoidFrameInverse, ellipsoid } = this;\n\n\t\t// get camera values\n\t\t_forward.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\n\t\t// set a ray in the local ellipsoid frame\n\t\t_ray.origin.copy( camera.position );\n\t\t_ray.direction.copy( _forward );\n\t\t_ray.applyMatrix4( ellipsoidFrameInverse );\n\n\t\t// get the estimated closest point\n\t\tellipsoid\n\t\t\t.closestPointToRayEstimate( _ray, _vec )\n\t\t\t.applyMatrix4( ellipsoidFrame );\n\n\t\t// use the closest point if no pivot was provided or it's closer\n\t\tif (\n\t\t\tsuper.getPivotPoint( target ) === null ||\n\t\t\t_pos.subVectors( target, _ray.origin ).dot( _ray.direction ) > _pos.subVectors( _vec, _ray.origin ).dot( _ray.direction )\n\t\t) {\n\n\t\t\ttarget.copy( _vec );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\t// get the vector to the center of the provided globe\n\tgetVectorToCenter( target ) {\n\n\t\tconst { ellipsoidFrame, camera } = this;\n\t\treturn target\n\t\t\t.setFromMatrixPosition( ellipsoidFrame )\n\t\t\t.sub( camera.position );\n\n\t}\n\n\t// get the distance to the center of the globe\n\tgetDistanceToCenter() {\n\n\t\treturn this\n\t\t\t.getVectorToCenter( _vec )\n\t\t\t.length();\n\n\t}\n\n\tgetUpDirection( point, target ) {\n\n\t\t// get the \"up\" direction based on the wgs84 ellipsoid\n\t\tconst { ellipsoidFrame, ellipsoidFrameInverse, ellipsoid } = this;\n\t\t_vec.copy( point ).applyMatrix4( ellipsoidFrameInverse );\n\n\t\tellipsoid.getPositionToNormal( _vec, target );\n\t\ttarget.transformDirection( ellipsoidFrame );\n\n\t}\n\n\tgetCameraUpDirection( target ) {\n\n\t\tconst { ellipsoidFrame, ellipsoidFrameInverse, ellipsoid, camera } = this;\n\t\tif ( camera.isOrthographicCamera ) {\n\n\t\t\tthis._getVirtualOrthoCameraPosition( _vec );\n\n\t\t\t_vec.applyMatrix4( ellipsoidFrameInverse );\n\n\t\t\tellipsoid.getPositionToNormal( _vec, target );\n\t\t\ttarget.transformDirection( ellipsoidFrame );\n\n\t\t} else {\n\n\t\t\tthis.getUpDirection( camera.position, target );\n\n\t\t}\n\n\t}\n\n\tupdate( deltaTime = Math.min( this.clock.getDelta(), 64 / 1000 ) ) {\n\n\t\tif ( ! this.enabled || ! this.camera || deltaTime === 0 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst { camera, pivotMesh } = this;\n\n\t\t// if we're outside the transition threshold then we toggle some reorientation behavior\n\t\t// when adjusting the up frame while moving the camera\n\t\tif ( this._isNearControls() ) {\n\n\t\t\tthis.scaleZoomOrientationAtEdges = this.zoomDelta < 0;\n\n\t\t} else {\n\n\t\t\tif ( this.state !== NONE && this._dragMode !== 1 && this._rotationMode !== 1 ) {\n\n\t\t\t\tpivotMesh.visible = false;\n\n\t\t\t}\n\t\t\tthis.scaleZoomOrientationAtEdges = false;\n\n\t\t}\n\n\t\tconst adjustCameraRotation = this.needsUpdate || this._inertiaNeedsUpdate();\n\n\t\t// fire basic controls update\n\t\tsuper.update( deltaTime );\n\n\t\t// update the camera planes and the ortho camera position\n\t\tthis.adjustCamera( camera );\n\n\t\t// align the camera up vector if the camera as updated\n\t\tif ( adjustCameraRotation && this._isNearControls() ) {\n\n\t\t\tthis.getCameraUpDirection( _globalUp );\n\t\t\tthis._alignCameraUp( _globalUp, 1 );\n\n\t\t\tthis.getCameraUpDirection( _globalUp );\n\t\t\tthis._clampRotation( _globalUp );\n\n\t\t}\n\n\t}\n\n\n\t// Updates the passed camera near and far clip planes to encapsulate the ellipsoid from the\n\t// current position in addition to adjusting the height.\n\tadjustCamera( camera ) {\n\n\t\tsuper.adjustCamera( camera );\n\n\t\tconst { ellipsoidFrame, ellipsoidFrameInverse, ellipsoid, nearMargin, farMargin } = this;\n\t\tconst maxRadius = Math.max( ...ellipsoid.radius );\n\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t// adjust the clip planes\n\t\t\tconst distanceToCenter = _vec\n\t\t\t\t.setFromMatrixPosition( ellipsoidFrame )\n\t\t\t\t.sub( camera.position ).length();\n\n\t\t\t// update the projection matrix\n\t\t\t// interpolate from the 25% radius margin around the globe down to the surface\n\t\t\t// so we can avoid z fighting when near value is too far at a high altitude\n\t\t\tconst margin = nearMargin * maxRadius;\n\t\t\tconst alpha = MathUtils.clamp( ( distanceToCenter - maxRadius ) / margin, 0, 1 );\n\t\t\tconst minNear = MathUtils.lerp( 1, 1000, alpha );\n\t\t\tcamera.near = Math.max( minNear, distanceToCenter - maxRadius - margin );\n\n\t\t\t// update the far plane to the horizon distance\n\t\t\t_pos.copy( camera.position ).applyMatrix4( ellipsoidFrameInverse );\n\t\t\tellipsoid.getPositionToCartographic( _pos, _latLon );\n\n\t\t\t// use a minimum elevation for computing the horizon distance to avoid the far clip\n\t\t\t// plane approaching zero or clipping mountains over the horizon in the distance as\n\t\t\t// the camera goes to or below sea level.\n\t\t\tconst elevation = Math.max( ellipsoid.getPositionElevation( _pos ), MIN_ELEVATION );\n\t\t\tconst horizonDistance = ellipsoid.calculateHorizonDistance( _latLon.lat, elevation );\n\n\t\t\tcamera.far = horizonDistance + 0.1 + maxRadius * farMargin;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t} else {\n\n\t\t\tthis._getVirtualOrthoCameraPosition( camera.position, camera );\n\t\t\tcamera.updateMatrixWorld();\n\n\t\t\t_invMatrix.copy( camera.matrixWorld ).invert();\n\t\t\t_vec.setFromMatrixPosition( ellipsoidFrame ).applyMatrix4( _invMatrix );\n\n\t\t\tconst distanceToCenter = - _vec.z;\n\t\t\tcamera.near = distanceToCenter - maxRadius * ( 1 + nearMargin );\n\t\t\tcamera.far = distanceToCenter + 0.1 + maxRadius * farMargin;\n\n\t\t\t// adjust the position of the ortho camera such that the near value is 0\n\t\t\tcamera.position.addScaledVector( _forward, camera.near );\n\t\t\tcamera.far -= camera.near;\n\t\t\tcamera.near = 0;\n\n\t\t\tcamera.updateProjectionMatrix();\n\t\t\tcamera.updateMatrixWorld();\n\n\t\t}\n\n\t}\n\n\t// resets the \"stuck\" drag modes\n\tsetState( ...args ) {\n\n\t\tsuper.setState( ...args );\n\t\tthis._dragMode = 0;\n\t\tthis._rotationMode = 0;\n\n\t}\n\n\t_updateInertia( deltaTime ) {\n\n\t\tsuper._updateInertia( deltaTime );\n\n\t\tconst {\n\t\t\tglobeInertia,\n\t\t\tenableDamping,\n\t\t\tdampingFactor,\n\t\t\tcamera,\n\t\t\tcameraRadius,\n\t\t\tminDistance,\n\t\t\tinertiaTargetDistance,\n\t\t\tellipsoidFrame,\n\t\t} = this;\n\n\t\tif ( ! this.enableDamping || this.inertiaStableFrames > 1 ) {\n\n\t\t\tthis.globeInertiaFactor = 0;\n\t\t\tthis.globeInertia.identity();\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst factor = Math.pow( 2, - deltaTime / dampingFactor );\n\t\tconst stableDistance = Math.max( camera.near, cameraRadius, minDistance, inertiaTargetDistance );\n\t\tconst resolution = 2 * 1e3;\n\t\tconst pixelWidth = 2 / resolution;\n\t\tconst pixelThreshold = 0.25 * pixelWidth;\n\n\t\t_center.setFromMatrixPosition( ellipsoidFrame );\n\n\t\tif ( this.globeInertiaFactor !== 0 ) {\n\n\t\t\t// calculate two screen points at 1 pixel apart in our notional resolution so we can stop when the delta is ~ 1 pixel\n\t\t\t// projected into world space\n\t\t\tsetRaycasterFromCamera( _ray, _vec.set( 0, 0, - 1 ), camera );\n\t\t\t_ray.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t_ray.direction.normalize();\n\t\t\t_ray.recast( - _ray.direction.dot( _ray.origin ) ).at( stableDistance / _ray.direction.z, _vec );\n\t\t\t_vec.applyMatrix4( camera.matrixWorld );\n\n\t\t\tsetRaycasterFromCamera( _ray, _pos.set( pixelThreshold, pixelThreshold, - 1 ), camera );\n\t\t\t_ray.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t_ray.direction.normalize();\n\t\t\t_ray.recast( - _ray.direction.dot( _ray.origin ) ).at( stableDistance / _ray.direction.z, _pos );\n\t\t\t_pos.applyMatrix4( camera.matrixWorld );\n\n\t\t\t// get implied angle\n\t\t\t_vec.sub( _center ).normalize();\n\t\t\t_pos.sub( _center ).normalize();\n\n\t\t\tthis.globeInertiaFactor *= factor;\n\t\t\tconst threshold = _vec.angleTo( _pos ) / deltaTime;\n\t\t\tconst globeAngle = 2 * Math.acos( globeInertia.w ) * this.globeInertiaFactor;\n\t\t\tif ( globeAngle < threshold || ! enableDamping ) {\n\n\t\t\t\tthis.globeInertiaFactor = 0;\n\t\t\t\tglobeInertia.identity();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.globeInertiaFactor !== 0 ) {\n\n\t\t\t// ensure our w component is non-one if the xyz values are\n\t\t\t// non zero to ensure we can animate\n\t\t\tif (\n\t\t\t\tglobeInertia.w === 1 && (\n\t\t\t\t\tglobeInertia.x !== 0 ||\n\t\t\t\t\tglobeInertia.y !== 0 ||\n\t\t\t\t\tglobeInertia.z !== 0\n\t\t\t\t)\n\t\t\t) {\n\n\t\t\t\tglobeInertia.w = Math.min( globeInertia.w, 1 - 1e-9 );\n\n\t\t\t}\n\n\t\t\t// construct the rotation matrix\n\t\t\t_center.setFromMatrixPosition( ellipsoidFrame );\n\t\t\t_quaternion.identity().slerp( globeInertia, this.globeInertiaFactor * deltaTime );\n\t\t\tmakeRotateAroundPoint( _center, _quaternion, _rotMatrix );\n\n\t\t\t// apply the rotation\n\t\t\tcamera.matrixWorld.premultiply( _rotMatrix );\n\t\t\tcamera.matrixWorld.decompose( camera.position, camera.quaternion, _vec );\n\n\t\t}\n\n\t}\n\n\t_inertiaNeedsUpdate() {\n\n\t\treturn super._inertiaNeedsUpdate() || this.globeInertiaFactor !== 0;\n\n\t}\n\n\t_updatePosition( deltaTime ) {\n\n\t\tif ( this.state === DRAG ) {\n\n\t\t\t// save the drag mode state so we can update the pivot mesh visuals in \"update\"\n\t\t\tif ( this._dragMode === 0 ) {\n\n\t\t\t\tthis._dragMode = this._isNearControls() ? 1 : - 1;\n\n\t\t\t}\n\n\t\t\tconst {\n\t\t\t\traycaster,\n\t\t\t\tcamera,\n\t\t\t\tpivotPoint,\n\t\t\t\tpointerTracker,\n\t\t\t\tdomElement,\n\t\t\t\tellipsoidFrame,\n\t\t\t\tellipsoidFrameInverse,\n\t\t\t} = this;\n\n\t\t\t// reuse cache variables\n\t\t\tconst pivotDir = _pos;\n\t\t\tconst newPivotDir = _targetRight;\n\n\t\t\t// get the pointer and ray\n\t\t\tpointerTracker.getCenterPoint( _pointer );\n\t\t\tmouseToCoords( _pointer.x, _pointer.y, domElement, _pointer );\n\t\t\tsetRaycasterFromCamera( raycaster, _pointer, camera );\n\n\t\t\t// transform to ellipsoid frame\n\t\t\traycaster.ray.applyMatrix4( ellipsoidFrameInverse );\n\n\t\t\t// construct an ellipsoid that matches a sphere with the radius of the globe so\n\t\t\t// the drag position matches where the initial click was\n\t\t\tconst pivotRadius = _vec.copy( pivotPoint ).applyMatrix4( ellipsoidFrameInverse ).length();\n\t\t\t_ellipsoid.radius.setScalar( pivotRadius );\n\n\t\t\t// if we drag off the sphere then end the operation and follow through on the inertia\n\t\t\tif ( ! _ellipsoid.intersectRay( raycaster.ray, _vec ) ) {\n\n\t\t\t\tthis.resetState();\n\t\t\t\tthis._updateInertia( deltaTime );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t_vec.applyMatrix4( ellipsoidFrame );\n\n\t\t\t// get the point directions\n\t\t\t_center.setFromMatrixPosition( ellipsoidFrame );\n\t\t\tpivotDir.subVectors( pivotPoint, _center ).normalize();\n\t\t\tnewPivotDir.subVectors( _vec, _center ).normalize();\n\n\t\t\t// construct the rotation\n\t\t\t_quaternion.setFromUnitVectors( newPivotDir, pivotDir );\n\t\t\tmakeRotateAroundPoint( _center, _quaternion, _rotMatrix );\n\n\t\t\t// apply the rotation\n\t\t\tcamera.matrixWorld.premultiply( _rotMatrix );\n\t\t\tcamera.matrixWorld.decompose( camera.position, camera.quaternion, _vec );\n\n\t\t\tif ( pointerTracker.getMoveDistance() / deltaTime < 2 * window.devicePixelRatio ) {\n\n\t\t\t\tthis.inertiaStableFrames ++;\n\n\t\t\t} else {\n\n\t\t\t\tthis.globeInertia.copy( _quaternion );\n\t\t\t\tthis.globeInertiaFactor = 1 / deltaTime;\n\t\t\t\tthis.inertiaStableFrames = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// disable rotation once we're outside the control transition\n\t_updateRotation( ...args ) {\n\n\t\tif ( this._rotationMode === 1 || this._isNearControls() ) {\n\n\t\t\tthis._rotationMode = 1;\n\t\t\tsuper._updateRotation( ...args );\n\n\t\t} else {\n\n\t\t\tthis.pivotMesh.visible = false;\n\t\t\tthis._rotationMode = - 1;\n\n\t\t}\n\n\n\t}\n\n\t_updateZoom() {\n\n\t\tconst { zoomDelta, ellipsoid, zoomSpeed, zoomPoint, camera, maxZoom, state } = this;\n\n\t\tif ( state !== ZOOM && zoomDelta === 0 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// reset momentum\n\t\tthis.rotationInertia.set( 0, 0 );\n\t\tthis.dragInertia.set( 0, 0, 0 );\n\t\tthis.globeInertia.identity();\n\t\tthis.globeInertiaFactor = 0;\n\n\t\t// used to scale the tilt transitions based on zoom intensity\n\t\tconst deltaAlpha = MathUtils.clamp( MathUtils.mapLinear( Math.abs( zoomDelta ), 0, 20, 0, 1 ), 0, 1 );\n\t\tif ( this._isNearControls() || zoomDelta > 0 ) {\n\n\t\t\tthis._updateZoomDirection();\n\n\t\t\t// When zooming try to tilt the camera towards the center of the planet to avoid the globe\n\t\t\t// spinning as you zoom out from the horizon\n\t\t\tif ( zoomDelta < 0 && ( this.zoomPointSet || this._updateZoomPoint() ) ) {\n\n\t\t\t\t// get the forward vector and vector toward the center of the ellipsoid\n\t\t\t\t_forward.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld ).normalize();\n\t\t\t\t_toCenter.copy( this.up ).multiplyScalar( - 1 );\n\n\t\t\t\t// Calculate alpha values to use to scale the amount of tilt that occurs as the camera moves.\n\t\t\t\t// Scales based on mouse position near the horizon and current tilt.\n\t\t\t\tthis.getUpDirection( zoomPoint, _zoomPointUp );\n\t\t\t\tconst upAlpha = MathUtils.clamp( MathUtils.mapLinear( - _zoomPointUp.dot( _toCenter ), 1, 0.95, 0, 1 ), 0, 1 );\n\t\t\t\tconst forwardAlpha = 1 - _forward.dot( _toCenter );\n\t\t\t\tconst cameraAlpha = camera.isOrthographicCamera ? 0.05 : 1;\n\t\t\t\tconst adjustedDeltaAlpha = MathUtils.clamp( deltaAlpha * 3, 0, 1 );\n\n\t\t\t\t// apply scale\n\t\t\t\tconst alpha = Math.min( upAlpha * forwardAlpha * cameraAlpha * adjustedDeltaAlpha, 0.1 );\n\t\t\t\t_toCenter.lerpVectors( _forward, _toCenter, alpha ).normalize();\n\n\t\t\t\t// perform rotation\n\t\t\t\t_quaternion.setFromUnitVectors( _forward, _toCenter );\n\t\t\t\tmakeRotateAroundPoint( zoomPoint, _quaternion, _rotMatrix );\n\t\t\t\tcamera.matrixWorld.premultiply( _rotMatrix );\n\t\t\t\tcamera.matrixWorld.decompose( camera.position, camera.quaternion, _toCenter );\n\n\t\t\t\t// update zoom direction\n\t\t\t\tthis.zoomDirection.subVectors( zoomPoint, camera.position ).normalize();\n\n\t\t\t}\n\n\t\t\tsuper._updateZoom();\n\n\t\t} else if ( camera.isPerspectiveCamera ) {\n\n\t\t\t// orient the camera to focus on the earth during the zoom\n\t\t\tconst transitionDistance = this._getPerspectiveTransitionDistance();\n\t\t\tconst maxDistance = this._getMaxPerspectiveDistance();\n\t\t\tconst distanceAlpha = MathUtils.mapLinear( this.getDistanceToCenter(), transitionDistance, maxDistance, 0, 1 );\n\t\t\tthis._tiltTowardsCenter( MathUtils.lerp( 0, 0.4, distanceAlpha * deltaAlpha ) );\n\t\t\tthis._alignCameraUpToNorth( MathUtils.lerp( 0, 0.2, distanceAlpha * deltaAlpha ) );\n\n\t\t\t// calculate zoom in a similar way to environment controls so\n\t\t\t// the zoom speeds are comparable\n\t\t\tconst dist = this.getDistanceToCenter() - ellipsoid.radius.x;\n\t\t\tconst scale = zoomDelta * dist * zoomSpeed * 0.0025;\n\t\t\tconst clampedScale = Math.max( scale, Math.min( this.getDistanceToCenter() - maxDistance, 0 ) );\n\n\t\t\t// zoom out directly from the globe center\n\t\t\tthis.getVectorToCenter( _vec ).normalize();\n\t\t\tthis.camera.position.addScaledVector( _vec, clampedScale );\n\t\t\tthis.camera.updateMatrixWorld();\n\n\t\t\tthis.zoomDelta = 0;\n\n\t\t} else {\n\n\t\t\tconst transitionZoom = this._getOrthographicTransitionZoom();\n\t\t\tconst minZoom = this._getMinOrthographicZoom();\n\t\t\tconst distanceAlpha = MathUtils.mapLinear( camera.zoom, transitionZoom, minZoom, 0, 1 );\n\t\t\tthis._tiltTowardsCenter( MathUtils.lerp( 0, 0.4, distanceAlpha * deltaAlpha ) );\n\t\t\tthis._alignCameraUpToNorth( MathUtils.lerp( 0, 0.2, distanceAlpha * deltaAlpha ) );\n\n\t\t\tconst scale = this.zoomDelta;\n\t\t\tconst normalizedDelta = Math.pow( 0.95, Math.abs( scale * 0.05 ) );\n\t\t\tconst scaleFactor = scale > 0 ? 1 / Math.abs( normalizedDelta ) : normalizedDelta;\n\n\t\t\tconst maxScaleFactor = minZoom / camera.zoom;\n\t\t\tconst clampedScaleFactor = Math.max( scaleFactor * zoomSpeed, Math.min( maxScaleFactor, 1 ) );\n\n\t\t\tcamera.zoom = Math.min( maxZoom, camera.zoom * clampedScaleFactor );\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\tthis.zoomDelta = 0;\n\t\t\tthis.zoomDirectionSet = false;\n\n\t\t}\n\n\t}\n\n\t// tilt the camera to align with north\n\t_alignCameraUpToNorth( alpha ) {\n\n\t\tconst { ellipsoidFrame } = this;\n\t\t_globalUp.set( 0, 0, 1 ).transformDirection( ellipsoidFrame );\n\t\tthis._alignCameraUp( _globalUp, alpha );\n\n\t}\n\n\t// tilt the camera to look at the center of the globe\n\t_tiltTowardsCenter( alpha ) {\n\n\t\tconst {\n\t\t\tcamera,\n\t\t\tellipsoidFrame,\n\t\t} = this;\n\n\t\t_forward.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld ).normalize();\n\t\t_vec.setFromMatrixPosition( ellipsoidFrame ).sub( camera.position ).normalize();\n\t\t_vec.lerp( _forward, 1 - alpha ).normalize();\n\n\t\t_quaternion.setFromUnitVectors( _forward, _vec );\n\t\tcamera.quaternion.premultiply( _quaternion );\n\t\tcamera.updateMatrixWorld();\n\n\t}\n\n\t// returns the perspective camera transition distance can move to based on globe size and fov\n\t_getPerspectiveTransitionDistance() {\n\n\t\tconst { camera, ellipsoid } = this;\n\t\tif ( ! camera.isPerspectiveCamera ) {\n\n\t\t\tthrow new Error();\n\n\t\t}\n\n\t\t// When the smallest fov spans 65% of the ellipsoid then we use the near controls\n\t\tconst ellipsoidRadius = Math.max( ...ellipsoid.radius );\n\t\tconst fovHoriz = 2 * Math.atan( Math.tan( MathUtils.DEG2RAD * camera.fov * 0.5 ) * camera.aspect );\n\t\tconst distVert = ellipsoidRadius / Math.tan( MathUtils.DEG2RAD * camera.fov * 0.5 );\n\t\tconst distHoriz = ellipsoidRadius / Math.tan( fovHoriz * 0.5 );\n\t\tconst dist = Math.max( distVert, distHoriz );\n\n\t\treturn dist;\n\n\t}\n\n\t// returns the max distance the perspective camera can move to based on globe size and fov\n\t_getMaxPerspectiveDistance() {\n\n\t\tconst { camera, ellipsoid } = this;\n\t\tif ( ! camera.isPerspectiveCamera ) {\n\n\t\t\tthrow new Error();\n\n\t\t}\n\n\t\t// allow for zooming out such that the ellipsoid is half the size of the largest fov\n\t\tconst ellipsoidRadius = Math.max( ...ellipsoid.radius );\n\t\tconst fovHoriz = 2 * Math.atan( Math.tan( MathUtils.DEG2RAD * camera.fov * 0.5 ) * camera.aspect );\n\t\tconst distVert = ellipsoidRadius / Math.tan( MathUtils.DEG2RAD * camera.fov * 0.5 );\n\t\tconst distHoriz = ellipsoidRadius / Math.tan( fovHoriz * 0.5 );\n\t\tconst dist = 2 * Math.max( distVert, distHoriz );\n\n\t\treturn dist;\n\n\t}\n\n\t// returns the transition threshold for orthographic zoom based on the globe size and camera settings\n\t_getOrthographicTransitionZoom() {\n\n\t\tconst { camera, ellipsoid } = this;\n\t\tif ( ! camera.isOrthographicCamera ) {\n\n\t\t\tthrow new Error();\n\n\t\t}\n\n\t\tconst orthoHeight = ( camera.top - camera.bottom );\n\t\tconst orthoWidth = ( camera.right - camera.left );\n\t\tconst orthoSize = Math.max( orthoHeight, orthoWidth );\n\t\tconst ellipsoidRadius = Math.max( ...ellipsoid.radius );\n\t\tconst ellipsoidDiameter = 2 * ellipsoidRadius;\n\t\treturn 2 * orthoSize / ellipsoidDiameter;\n\n\t}\n\n\t// returns the minimum allowed orthographic zoom based on the globe size and camera settings\n\t_getMinOrthographicZoom() {\n\n\t\tconst { camera, ellipsoid } = this;\n\t\tif ( ! camera.isOrthographicCamera ) {\n\n\t\t\tthrow new Error();\n\n\t\t}\n\n\t\tconst orthoHeight = ( camera.top - camera.bottom );\n\t\tconst orthoWidth = ( camera.right - camera.left );\n\t\tconst orthoSize = Math.min( orthoHeight, orthoWidth );\n\t\tconst ellipsoidRadius = Math.max( ...ellipsoid.radius );\n\t\tconst ellipsoidDiameter = 2 * ellipsoidRadius;\n\t\treturn 0.7 * orthoSize / ellipsoidDiameter;\n\n\t}\n\n\t// returns the \"virtual position\" of the orthographic based on where it is and\n\t// where it's looking primarily so we can reasonably position the camera object\n\t// in space and derive a reasonable \"up\" value.\n\t_getVirtualOrthoCameraPosition( target, camera = this.camera ) {\n\n\t\tconst { ellipsoidFrame, ellipsoidFrameInverse, ellipsoid } = this;\n\t\tif ( ! camera.isOrthographicCamera ) {\n\n\t\t\tthrow new Error();\n\n\t\t}\n\n\t\t// get ray in globe coordinate frame\n\t\t_ray.origin.copy( camera.position );\n\t\t_ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\t_ray.applyMatrix4( ellipsoidFrameInverse );\n\n\t\t// get the closest point to the ray on the globe in the global coordinate frame\n\t\tellipsoid\n\t\t\t.closestPointToRayEstimate( _ray, _pos )\n\t\t\t.applyMatrix4( ellipsoidFrame );\n\n\t\t// get ortho camera info\n\t\tconst orthoHeight = ( camera.top - camera.bottom );\n\t\tconst orthoWidth = ( camera.right - camera.left );\n\t\tconst orthoSize = Math.max( orthoHeight, orthoWidth ) / camera.zoom;\n\t\t_forward.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\n\t\t// ensure we move the camera exactly along the forward vector to avoid shifting\n\t\t// the camera in other directions due to floating point error\n\t\tconst dist = _pos.sub( camera.position ).dot( _forward );\n\t\ttarget.copy( camera.position ).addScaledVector( _forward, dist - orthoSize * 4 );\n\n\t}\n\n\t_isNearControls() {\n\n\t\tconst { camera } = this;\n\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\treturn this.getDistanceToCenter() < this._getPerspectiveTransitionDistance();\n\n\t\t} else {\n\n\t\t\treturn camera.zoom > this._getOrthographicTransitionZoom();\n\n\t\t}\n\n\t}\n\n\t_raycast( raycaster ) {\n\n\t\tconst result = super._raycast( raycaster );\n\t\tif ( result === null ) {\n\n\t\t\t// if there was no hit then fallback to intersecting the ellipsoid.\n\t\t\tconst { ellipsoid, ellipsoidFrame, ellipsoidFrameInverse } = this;\n\t\t\t_ray.copy( raycaster.ray ).applyMatrix4( ellipsoidFrameInverse );\n\n\t\t\tconst point = ellipsoid.intersectRay( _ray, _vec );\n\t\t\tif ( point !== null ) {\n\n\t\t\t\tpoint.applyMatrix4( ellipsoidFrame );\n\t\t\t\treturn {\n\t\t\t\t\tpoint: point.clone(),\n\t\t\t\t\tdistance: point.distanceTo( raycaster.ray.origin ),\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\n\t\t} else {\n\n\t\t\treturn result;\n\n\t\t}\n\n\t}\n\n}\n"],"names":["_invMatrix","Matrix4","_rotMatrix","_pos","Vector3","_vec","_center","_forward","_targetRight","_globalUp","_quaternion","Quaternion","_zoomPointUp","_toCenter","_ray","Ray","_ellipsoid","Ellipsoid","_pointer","Vector2","_latLon","MIN_ELEVATION","GlobeControls","EnvironmentControls","ellipsoidGroup","ellipsoidFrame","_ellipsoidFrameInverse","scene","camera","domElement","tilesRenderer","WGS84_ELLIPSOID","Group","ellipsoid","target","ellipsoidFrameInverse","point","deltaTime","pivotMesh","NONE","adjustCameraRotation","nearMargin","farMargin","maxRadius","distanceToCenter","margin","alpha","MathUtils","minNear","elevation","horizonDistance","args","globeInertia","enableDamping","dampingFactor","cameraRadius","minDistance","inertiaTargetDistance","factor","stableDistance","pixelThreshold","setRaycasterFromCamera","threshold","makeRotateAroundPoint","DRAG","raycaster","pivotPoint","pointerTracker","pivotDir","newPivotDir","mouseToCoords","pivotRadius","zoomDelta","zoomSpeed","zoomPoint","maxZoom","state","ZOOM","deltaAlpha","upAlpha","forwardAlpha","cameraAlpha","adjustedDeltaAlpha","transitionDistance","maxDistance","distanceAlpha","dist","scale","clampedScale","transitionZoom","minZoom","normalizedDelta","scaleFactor","maxScaleFactor","clampedScaleFactor","ellipsoidRadius","fovHoriz","distVert","distHoriz","orthoHeight","orthoWidth","orthoSize","ellipsoidDiameter","result"],"mappings":"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"}