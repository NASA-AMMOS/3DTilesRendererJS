{"version":3,"file":"ImageOverlayPlugin-C0MePglr.js","sources":["../../../src/three/plugins/images/sources/QuadKeyImageSource.js","../../../src/three/plugins/images/overlays/utils.js","../../../src/three/plugins/images/overlays/wrapOverlaysMaterial.js","../../../src/three/plugins/images/overlays/TiledTextureComposer.js","../../../src/three/plugins/images/sources/RegionImageSource.js","../../../src/three/plugins/images/sources/GeoJSONImageSource.js","../../../src/three/plugins/images/ImageOverlayPlugin.js"],"sourcesContent":["import { XYZImageSource } from './XYZImageSource.js';\n\n// Bing Maps Tile System\n// https://learn.microsoft.com/en-us/bingmaps/articles/bing-maps-tile-system\nexport class QuadKeyImageSource extends XYZImageSource {\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\tsubdomains = [ 't0' ],\n\t\t\t...rest\n\t\t} = options;\n\n\t\tsuper( rest );\n\n\t\tthis.subdomains = subdomains;\n\t\tthis.subDomainIndex = 0;\n\n\t}\n\n\tgetUrl( x, y, level ) {\n\n\t\treturn this.url\n\t\t\t.replace( /{\\s*subdomain\\s*}/gi, this._getSubdomain() )\n\t\t\t.replace( /{\\s*quadkey\\s*}/gi, this._tileToQuadKey( x, y, level ) );\n\n\t}\n\n\t_tileToQuadKey( x, y, level ) {\n\n\t\tlet quadKey = '';\n\t\tfor ( let i = level; i > 0; i -- ) {\n\n\t\t\tlet digit = 0;\n\t\t\tconst mask = 1 << ( i - 1 );\n\t\t\tif ( ( x & mask ) !== 0 ) digit += 1;\n\t\t\tif ( ( y & mask ) !== 0 ) digit += 2;\n\t\t\tquadKey += digit.toString();\n\n\t\t}\n\n\t\treturn quadKey;\n\n\t}\n\n\t_getSubdomain() {\n\n\t\t// Spread requests among different subdomains to circumvent browser URL request limits per domain\n\t\t// https://learn.microsoft.com/en-us/bingmaps/rest-services/directly-accessing-the-bing-maps-tiles\n\t\tthis.subDomainIndex = ( this.subDomainIndex + 1 ) % this.subdomains.length;\n\t\treturn this.subdomains[ this.subDomainIndex ];\n\n\t}\n\n}\n","import { Vector3, Matrix4, MathUtils } from 'three';\n\n// iterates over all present tiles in the given tileset at the given level in the given range\nexport function forEachTileInBounds( range, level, tiling, callback ) {\n\n\t// pull the bounds in a bit to avoid loading unnecessary tiles. 1e-8 was chosen since smaller values\n\t// are not larger enough and cause extra tiles to load in cases where 1-to-1 tile-to-image should occur\n\tlet [ minLon, minLat, maxLon, maxLat ] = range;\n\tminLat += 1e-8;\n\tminLon += 1e-8;\n\tmaxLat -= 1e-8;\n\tmaxLon -= 1e-8;\n\n\tconst clampedLevel = Math.max( Math.min( level, tiling.maxLevel ), tiling.minLevel );\n\tconst [ minX, minY, maxX, maxY ] = tiling.getTilesInRange( minLon, minLat, maxLon, maxLat, clampedLevel, true );\n\tfor ( let x = minX; x <= maxX; x ++ ) {\n\n\t\tfor ( let y = minY; y <= maxY; y ++ ) {\n\n\t\t\tcallback( x, y, clampedLevel );\n\n\t\t}\n\n\t}\n\n}\n\n// functions for generating UVs for cartographic-projected UVs\nfunction getGeometryCartographicChannel( geometry, geomToEllipsoidMatrix, ellipsoid ) {\n\n\tconst _vec = new Vector3();\n\tconst _cart = {};\n\tconst uv = [];\n\tconst posAttr = geometry.getAttribute( 'position' );\n\n\tgeometry.computeBoundingBox();\n\tgeometry.boundingBox.getCenter( _vec ).applyMatrix4( geomToEllipsoidMatrix );\n\n\t// find a rough mid lat / lon point\n\tellipsoid.getPositionToCartographic( _vec, _cart );\n\tconst centerLat = _cart.lat;\n\tconst centerLon = _cart.lon;\n\n\tlet minLat = Infinity;\n\tlet minLon = Infinity;\n\tlet minHeight = Infinity;\n\tlet maxLat = - Infinity;\n\tlet maxLon = - Infinity;\n\tlet maxHeight = - Infinity;\n\tfor ( let i = 0; i < posAttr.count; i ++ ) {\n\n\t\t// get the lat / lon values per vertex\n\t\t_vec.fromBufferAttribute( posAttr, i ).applyMatrix4( geomToEllipsoidMatrix );\n\t\tellipsoid.getPositionToCartographic( _vec, _cart );\n\n\t\t// The latitude calculations are not so stable at the poles so force the lat value to\n\t\t// the mid point to ensure we don't load an unnecessarily large of tiles\n\t\t// NOTE: this can distort the texture a bit at the poles\n\t\tif ( Math.abs( Math.abs( _cart.lat ) - Math.PI / 2 ) < 1e-5 ) {\n\n\t\t\t_cart.lon = centerLon;\n\n\t\t}\n\n\t\t// ensure we're not wrapping on the same geometry\n\t\tif ( Math.abs( centerLon - _cart.lon ) > Math.PI ) {\n\n\t\t\t_cart.lon += Math.sign( centerLon - _cart.lon ) * Math.PI * 2;\n\n\t\t}\n\n\t\tif ( Math.abs( centerLat - _cart.lat ) > Math.PI ) {\n\n\t\t\t_cart.lat += Math.sign( centerLat - _cart.lat ) * Math.PI * 2;\n\n\t\t}\n\n\t\tuv.push( _cart.lon, _cart.lat, _cart.height );\n\n\t\tminLat = Math.min( minLat, _cart.lat );\n\t\tmaxLat = Math.max( maxLat, _cart.lat );\n\n\t\tminLon = Math.min( minLon, _cart.lon );\n\t\tmaxLon = Math.max( maxLon, _cart.lon );\n\n\t\tminHeight = Math.min( minHeight, _cart.height );\n\t\tmaxHeight = Math.max( maxHeight, _cart.height );\n\n\t}\n\n\tconst range = [ minLon, minLat, maxLon, maxLat ];\n\tconst region = [ ...range, minHeight, maxHeight ];\n\treturn {\n\t\tuv,\n\t\trange,\n\t\tregion,\n\t};\n\n}\n\nexport function getMeshesCartographicRange( meshes, ellipsoid, meshToEllipsoidMatrix = null, projection = null ) {\n\n\t// find the lat / lon ranges\n\tlet minLat = Infinity;\n\tlet minLon = Infinity;\n\tlet minHeight = Infinity;\n\tlet maxLat = - Infinity;\n\tlet maxLon = - Infinity;\n\tlet maxHeight = - Infinity;\n\tconst uvs = [];\n\n\tconst _matrix = new Matrix4();\n\tmeshes.forEach( mesh => {\n\n\t\t// multiply in the ellipsoid matrix if necessary\n\t\t_matrix.copy( mesh.matrixWorld );\n\t\tif ( meshToEllipsoidMatrix ) {\n\n\t\t\t_matrix.premultiply( meshToEllipsoidMatrix );\n\n\t\t}\n\n\t\tconst { uv, region } = getGeometryCartographicChannel( mesh.geometry, _matrix, ellipsoid );\n\t\tuvs.push( uv );\n\n\t\t// save the min and max values\n\t\tminLat = Math.min( minLat, region[ 1 ] );\n\t\tmaxLat = Math.max( maxLat, region[ 3 ] );\n\n\t\tminLon = Math.min( minLon, region[ 0 ] );\n\t\tmaxLon = Math.max( maxLon, region[ 2 ] );\n\n\t\tminHeight = Math.min( minHeight, region[ 4 ] );\n\t\tmaxHeight = Math.max( maxHeight, region[ 5 ] );\n\n\t} );\n\n\tlet clampedRange = [ minLon, minLat, maxLon, maxLat ];\n\tif ( projection !== null ) {\n\n\t\t// Clamp the lat lon range to the bounds of the projection scheme. Note that clamping the data\n\t\t// allows for \"stretching\" the texture look at the edges of the projection which leads to a nicer\n\t\t// looking overlay. Eg at the poles of a web-mercator projection - otherwise there will be gaps\n\t\t// that show the underlying tile data. It's arguable which one is better but in all supported\n\t\t// ellipsoid projections (Web mercator, equirect) the projection ranges always span the entire\n\t\t// globe range.\n\t\t// const clampedRange = [ minLon, minLat, maxLon, maxLat ];\n\t\tclampedRange = projection.clampToBounds( [ minLon, minLat, maxLon, maxLat ] );\n\t\tconst [ minU, minV, maxU, maxV ] = projection.toNormalizedRange( clampedRange );\n\t\tuvs.forEach( uv => {\n\n\t\t\tfor ( let i = 0, l = uv.length; i < l; i += 3 ) {\n\n\t\t\t\tconst lon = uv[ i + 0 ];\n\t\t\t\tconst lat = uv[ i + 1 ];\n\t\t\t\tconst h = uv[ i + 2 ];\n\n\t\t\t\tconst [ u, v ] = projection.toNormalizedPoint( lon, lat );\n\t\t\t\tuv[ i + 0 ] = MathUtils.mapLinear( u, minU, maxU, 0, 1 );\n\t\t\t\tuv[ i + 1 ] = MathUtils.mapLinear( v, minV, maxV, 0, 1 );\n\t\t\t\tuv[ i + 2 ] = MathUtils.mapLinear( h, minHeight, maxHeight, 0, 1 );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\treturn {\n\t\tuvs,\n\t\trange: clampedRange,\n\t\tregion: [ minLon, minLat, maxLon, maxLat, minHeight, maxHeight ],\n\t};\n\n}\n\n// functions for generating UVs for planar-projected UVs\nfunction getGeometryPlanarChannel( geometry, meshToFrame ) {\n\n\tconst _vec = new Vector3();\n\tconst uv = [];\n\tconst posAttr = geometry.getAttribute( 'position' );\n\n\tlet minU = Infinity;\n\tlet minV = Infinity;\n\tlet minW = Infinity;\n\tlet maxU = - Infinity;\n\tlet maxV = - Infinity;\n\tlet maxW = - Infinity;\n\tfor ( let i = 0; i < posAttr.count; i ++ ) {\n\n\t\t_vec.fromBufferAttribute( posAttr, i ).applyMatrix4( meshToFrame );\n\n\t\tuv.push( _vec.x, _vec.y, _vec.z );\n\n\t\tminU = Math.min( minU, _vec.x );\n\t\tmaxU = Math.max( maxU, _vec.x );\n\n\t\tminV = Math.min( minV, _vec.y );\n\t\tmaxV = Math.max( maxV, _vec.y );\n\n\t\tminW = Math.min( minW, _vec.z );\n\t\tmaxW = Math.max( maxW, _vec.z );\n\n\t}\n\n\t// TODO: output a more complete bounds definition relative to the frame\n\tconst range = [ minU, minV, maxU, maxV ];\n\treturn {\n\t\tuv,\n\t\trange,\n\t\theightRange: [ minW, maxW ],\n\t};\n\n}\n\nexport function getMeshesPlanarRange( meshes, worldToFrame ) {\n\n\t// find the U / V ranges\n\tlet minU = Infinity;\n\tlet minV = Infinity;\n\tlet minW = Infinity;\n\tlet maxU = - Infinity;\n\tlet maxV = - Infinity;\n\tlet maxW = - Infinity;\n\tconst uvs = [];\n\n\tconst _matrix = new Matrix4();\n\tmeshes.forEach( mesh => {\n\n\t\t// multiply in the ellipsoid matrix if necessary\n\t\t_matrix.copy( mesh.matrixWorld );\n\t\tif ( worldToFrame ) {\n\n\t\t\t_matrix.premultiply( worldToFrame );\n\n\t\t}\n\n\t\tconst { uv, range, heightRange } = getGeometryPlanarChannel( mesh.geometry, _matrix );\n\t\tuvs.push( uv );\n\n\t\t// save the min and max values\n\t\tminU = Math.min( minU, range[ 0 ] );\n\t\tmaxU = Math.max( maxU, range[ 2 ] );\n\n\t\tminV = Math.min( minV, range[ 1 ] );\n\t\tmaxV = Math.max( maxV, range[ 3 ] );\n\n\t\tminW = Math.min( minW, heightRange[ 0 ] );\n\t\tmaxW = Math.max( maxW, heightRange[ 1 ] );\n\n\t} );\n\n\tuvs.forEach( uv => {\n\n\t\tfor ( let i = 0, l = uv.length; i < l; i += 3 ) {\n\n\t\t\tconst u = uv[ i + 0 ];\n\t\t\tconst v = uv[ i + 1 ];\n\n\t\t\tuv[ i + 0 ] = MathUtils.mapLinear( u, minU, maxU, 0, 1 );\n\t\t\tuv[ i + 1 ] = MathUtils.mapLinear( v, minV, maxV, 0, 1 );\n\n\t\t}\n\n\t} );\n\n\t// TODO: output a more complete bounds definition relative to the frame\n\treturn {\n\t\tuvs,\n\t\trange: [ minU, minV, maxU, maxV ],\n\t\theightRange: [ minW, maxW ],\n\t};\n\n}\n","const OVERLAY_PARAMS = Symbol( 'OVERLAY_PARAMS' );\n\n// before compile can be used to chain shader adjustments. Returns the added uniforms used for fading.\nexport function wrapOverlaysMaterial( material, previousOnBeforeCompile ) {\n\n\t// if the material has already been wrapped then return the params\n\tif ( material[ OVERLAY_PARAMS ] ) {\n\n\t\treturn material[ OVERLAY_PARAMS ];\n\n\t}\n\n\tconst params = {\n\t\tlayerMaps: { value: [] },\n\t\tlayerInfo: { value: [] },\n\t};\n\n\tmaterial[ OVERLAY_PARAMS ] = params;\n\n\tmaterial.defines = {\n\t\t...( material.defines || {} ),\n\t\tLAYER_COUNT: 0,\n\t};\n\n\tmaterial.onBeforeCompile = shader => {\n\n\t\tif ( previousOnBeforeCompile ) {\n\n\t\t\tpreviousOnBeforeCompile( shader );\n\n\t\t}\n\n\t\tshader.uniforms = {\n\t\t\t...shader.uniforms,\n\t\t\t...params,\n\t\t};\n\n\t\tshader.vertexShader = shader\n\t\t\t.vertexShader\n\t\t\t.replace( /void main\\(\\s*\\)\\s*{/, value => /* glsl */`\n\n\t\t\t\t#pragma unroll_loop_start\n\t\t\t\t\tfor ( int i = 0; i < 10; i ++ ) {\n\n\t\t\t\t\t\t#if UNROLLED_LOOP_INDEX < LAYER_COUNT\n\n\t\t\t\t\t\t\tattribute vec3 layer_uv_UNROLLED_LOOP_INDEX;\n\t\t\t\t\t\t\tvarying vec3 v_layer_uv_UNROLLED_LOOP_INDEX;\n\n\t\t\t\t\t\t#endif\n\n\n\t\t\t\t\t}\n\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t\t${ value }\n\n\t\t\t\t#pragma unroll_loop_start\n\t\t\t\t\tfor ( int i = 0; i < 10; i ++ ) {\n\n\t\t\t\t\t\t#if UNROLLED_LOOP_INDEX < LAYER_COUNT\n\n\t\t\t\t\t\t\tv_layer_uv_UNROLLED_LOOP_INDEX = layer_uv_UNROLLED_LOOP_INDEX;\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t}\n\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t` );\n\n\t\tshader.fragmentShader = shader\n\t\t\t.fragmentShader\n\t\t\t.replace( /void main\\(/, value => /* glsl */`\n\n\t\t\t\t#if LAYER_COUNT != 0\n\t\t\t\t\tstruct LayerInfo {\n\t\t\t\t\t\tvec3 color;\n\t\t\t\t\t\tfloat opacity;\n\n\t\t\t\t\t\tint alphaMask;\n\t\t\t\t\t\tint alphaInvert;\n\t\t\t\t\t};\n\n\t\t\t\t\tuniform sampler2D layerMaps[ LAYER_COUNT ];\n\t\t\t\t\tuniform LayerInfo layerInfo[ LAYER_COUNT ];\n\t\t\t\t#endif\n\n\t\t\t\t#pragma unroll_loop_start\n\t\t\t\t\tfor ( int i = 0; i < 10; i ++ ) {\n\n\t\t\t\t\t\t#if UNROLLED_LOOP_INDEX < LAYER_COUNT\n\n\t\t\t\t\t\t\tvarying vec3 v_layer_uv_UNROLLED_LOOP_INDEX;\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t}\n\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t\t${ value }\n\n\t\t\t` )\n\t\t\t.replace( /#include <color_fragment>/, value => /* glsl */`\n\n\t\t\t\t${ value }\n\n\t\t\t\t#if LAYER_COUNT != 0\n\t\t\t\t{\n\t\t\t\t\tvec4 tint;\n\t\t\t\t\tvec3 layerUV;\n\t\t\t\t\tfloat layerOpacity;\n\t\t\t\t\tfloat wOpacity;\n\t\t\t\t\tfloat wDelta;\n\t\t\t\t\t#pragma unroll_loop_start\n\t\t\t\t\t\tfor ( int i = 0; i < 10; i ++ ) {\n\n\t\t\t\t\t\t\t#if UNROLLED_LOOP_INDEX < LAYER_COUNT\n\n\t\t\t\t\t\t\t\tlayerUV = v_layer_uv_UNROLLED_LOOP_INDEX;\n\t\t\t\t\t\t\t\ttint = texture( layerMaps[ i ], layerUV.xy );\n\n\t\t\t\t\t\t\t\t// discard texture outside 0, 1 on w - offset the stepped value by an epsilon to avoid cases\n\t\t\t\t\t\t\t\t// where wDelta is near 0 (eg a flat surface) at the w boundary, resulting in artifacts on some\n\t\t\t\t\t\t\t\t// hardware.\n\t\t\t\t\t\t\t\twDelta = max( fwidth( layerUV.z ), 1e-7 );\n\t\t\t\t\t\t\t\twOpacity =\n\t\t\t\t\t\t\t\t\tsmoothstep( - wDelta, 0.0, layerUV.z ) *\n\t\t\t\t\t\t\t\t\tsmoothstep( 1.0 + wDelta, 1.0, layerUV.z );\n\n\t\t\t\t\t\t\t\t// apply tint & opacity\n\t\t\t\t\t\t\t\ttint.rgb *= layerInfo[ i ].color;\n\t\t\t\t\t\t\t\ttint.rgba *= layerInfo[ i ].opacity * wOpacity;\n\n\t\t\t\t\t\t\t\t// invert the alpha\n\t\t\t\t\t\t\t\tif ( layerInfo[ i ].alphaInvert > 0 ) {\n\n\t\t\t\t\t\t\t\t\ttint.a = 1.0 - tint.a;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// apply the alpha across all existing layers if alpha mask is true\n\t\t\t\t\t\t\t\tif ( layerInfo[ i ].alphaMask > 0 ) {\n\n\t\t\t\t\t\t\t\t\tdiffuseColor.a *= tint.a;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\ttint.rgb *= tint.a;\n\t\t\t\t\t\t\t\t\tdiffuseColor = tint + diffuseColor * ( 1.0 - tint.a );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t}\n\t\t\t\t\t#pragma unroll_loop_end\n\t\t\t\t}\n\t\t\t\t#endif\n\t\t\t` );\n\n\t};\n\n\treturn params;\n\n}\n","import { MathUtils } from 'three';\n\n// Utility for composing a series of tiled textures together onto a target texture in a given range\nexport class TiledTextureComposer {\n\n\tconstructor() {\n\n\t\tthis.canvas = null;\n\t\tthis.context = null;\n\t\tthis.range = [ 0, 0, 1, 1 ];\n\n\t}\n\n\t// set the target render texture and the range that represents the full span\n\tsetTarget( canvas, range ) {\n\n\t\tthis.canvas = canvas.image;\n\t\tthis.context = canvas.image.getContext( '2d' );\n\t\tthis.range = [ ...range ];\n\n\t}\n\n\t// draw the given texture at the given span with the provided projection\n\tdraw( texture, span ) {\n\n\t\tconst { canvas, range, context } = this;\n\t\tconst { width, height } = canvas;\n\t\tconst { image } = texture;\n\t\tconst minX = Math.round( MathUtils.mapLinear( span[ 0 ], range[ 0 ], range[ 2 ], 0, width ) );\n\t\tconst minY = Math.round( MathUtils.mapLinear( span[ 1 ], range[ 1 ], range[ 3 ], 0, height ) );\n\t\tconst maxX = Math.round( MathUtils.mapLinear( span[ 2 ], range[ 0 ], range[ 2 ], 0, width ) );\n\t\tconst maxY = Math.round( MathUtils.mapLinear( span[ 3 ], range[ 1 ], range[ 3 ], 0, height ) );\n\n\t\tconst imageWidth = maxX - minX;\n\t\tconst imageHeight = maxY - minY;\n\t\tif ( ! ( image instanceof ImageBitmap ) ) {\n\n\t\t\tcontext.drawImage( image, minX, height - minY, imageWidth, - imageHeight );\n\n\t\t} else {\n\n\t\t\tcontext.save();\n\t\t\tcontext.translate( minX, height - minY );\n\t\t\tcontext.scale( 1, - 1 );\n\t\t\tcontext.drawImage( image, 0, 0, imageWidth, imageHeight );\n\t\t\tcontext.restore();\n\n\t\t}\n\n\t}\n\n\t// clear the set target\n\tclear() {\n\n\t\tconst { context, canvas } = this;\n\t\tcontext.clearRect( 0, 0, canvas.width, canvas.height );\n\n\t}\n\n}\n","import { TiledTextureComposer } from '../overlays/TiledTextureComposer.js';\nimport { forEachTileInBounds } from '../overlays/utils.js';\nimport { DataCache } from '../utils/DataCache.js';\nimport { SRGBColorSpace, CanvasTexture } from 'three';\n\nexport class RegionImageSource extends DataCache {\n\n\thasContent( ...tokens ) {\n\n\t\treturn true;\n\n\t}\n\n}\n\nexport class TiledRegionImageSource extends RegionImageSource {\n\n\tconstructor( tiledImageSource ) {\n\n\t\tsuper();\n\t\tthis.tiledImageSource = tiledImageSource;\n\t\tthis.tileComposer = new TiledTextureComposer();\n\t\tthis.resolution = 256;\n\n\t}\n\n\thasContent( minX, minY, maxX, maxY, level ) {\n\n\t\tconst tiling = this.tiledImageSource.tiling;\n\t\tlet total = 0;\n\t\tforEachTileInBounds( [ minX, minY, maxX, maxY ], level, tiling, () => {\n\n\t\t\ttotal ++;\n\n\t\t} );\n\n\t\treturn total !== 0;\n\n\t}\n\n\tasync fetchItem( [ minX, minY, maxX, maxY, level ], signal ) {\n\n\t\tconst range = [ minX, minY, maxX, maxY ];\n\t\tconst imageSource = this.tiledImageSource;\n\t\tconst tileComposer = this.tileComposer;\n\t\tconst tiling = imageSource.tiling;\n\n\t\tconst canvas = document.createElement( 'canvas' );\n\t\tcanvas.width = this.resolution;\n\t\tcanvas.height = this.resolution;\n\n\t\tconst target = new CanvasTexture( canvas );\n\t\ttarget.colorSpace = SRGBColorSpace;\n\t\ttarget.generateMipmaps = false;\n\t\ttarget.tokens = [ ...range, level ];\n\n\t\t// Start locking tiles for the requested level\n\t\tawait this._markImages( range, level, false );\n\n\t\t// TODO: we could draw the parent tile data here if it's available just to make sure we\n\t\t// have something to display but the texture is not usable until it returns. Though it\n\t\t// may also have minimal impact. Something to consider for the future.\n\n\t\t// Draw the requested level tiles\n\t\ttileComposer.setTarget( target, range );\n\t\ttileComposer.clear( 0xffffff, 0 );\n\n\t\tforEachTileInBounds( range, level, tiling, ( tx, ty, tl ) => {\n\n\t\t\t// draw using normalized bounds since the mercator bounds are non-linear\n\t\t\tconst span = tiling.getTileBounds( tx, ty, tl, true, false );\n\t\t\tconst tex = imageSource.get( tx, ty, tl );\n\t\t\ttileComposer.draw( tex, span );\n\n\t\t} );\n\n\t\treturn target;\n\n\t}\n\n\tdisposeItem( target ) {\n\n\t\ttarget.dispose();\n\n\t\t// Unlock the component tiles using the tokens stored on the target\n\t\tconst [ minX, minY, maxX, maxY, level ] = target.tokens;\n\t\tthis._markImages( [ minX, minY, maxX, maxY ], level, true );\n\n\t}\n\n\tdispose() {\n\n\t\tsuper.dispose();\n\t\tthis.tiledImageSource.dispose();\n\n\t}\n\n\t_markImages( range, level, release = false ) {\n\n\t\tconst imageSource = this.tiledImageSource;\n\t\tconst tiling = imageSource.tiling;\n\n\t\tconst promises = [];\n\t\tforEachTileInBounds( range, level, tiling, ( tx, ty, tl ) => {\n\n\t\t\tif ( release ) {\n\n\t\t\t\timageSource.release( tx, ty, tl );\n\n\t\t\t} else {\n\n\t\t\t\tpromises.push( imageSource.lock( tx, ty, tl ) );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tconst filteredPromises = promises.filter( p => p instanceof Promise );\n\t\tif ( filteredPromises.length !== 0 ) {\n\n\t\t\treturn Promise.all( filteredPromises );\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n}\n","import { CanvasTexture, MathUtils, Vector3, SRGBColorSpace } from 'three';\nimport { RegionImageSource } from './RegionImageSource.js';\nimport { ProjectionScheme } from '../utils/ProjectionScheme.js';\nimport { WGS84_ELLIPSOID } from '3d-tiles-renderer/three';\n\n// TODO: Consider option to support world-space thickness definitions. Eg world-space point size or line thickness in meters.\n\n// function for calculating the the change in arc length at a given cartographic point\n// in order to preserve a circular look when drawing points\nconst _v0 = /* @__PURE__ */ new Vector3();\nconst _v1 = /* @__PURE__ */ new Vector3();\nfunction calculateArcRatioAtPoint( ellipsoid, lat, lon ) {\n\n\tconst DELTA = 0.01;\n\tellipsoid.getCartographicToPosition( lat, lon, 0, _v0 );\n\tellipsoid.getCartographicToPosition( lat + DELTA, lon, 0, _v1 );\n\n\tconst latDelta = _v0.distanceTo( _v1 );\n\tellipsoid.getCartographicToPosition( lat, lon + DELTA, 0, _v1 );\n\n\tconst lonDelta = _v0.distanceTo( _v1 );\n\treturn lonDelta / latDelta;\n\n}\n\nexport class GeoJSONImageSource extends RegionImageSource {\n\n\tconstructor( {\n\t\tgeojson = null,\n\t\turl = null, // URL or GeoJson object can be provided\n\t\tresolution = 256,\n\t\tpointRadius = 6,\n\t\tstrokeStyle = 'white',\n\t\tstrokeWidth = 2,\n\t\tfillStyle = 'rgba( 255, 255, 255, 0.5 )',\n\t\t...rest\n\t} = {} ) {\n\n\t\tsuper( rest );\n\t\tthis.geojson = geojson;\n\t\tthis.url = url;\n\t\tthis.resolution = resolution;\n\n\t\tthis.pointRadius = pointRadius;\n\t\tthis.strokeStyle = strokeStyle;\n\t\tthis.strokeWidth = strokeWidth;\n\t\tthis.fillStyle = fillStyle;\n\n\t\tthis.features = null;\n\t\tthis.featureBounds = new Map();\n\t\tthis.contentBounds = null;\n\n\t\tthis.projection = new ProjectionScheme();\n\t\tthis.fetchData = ( ...args ) => fetch( ...args );\n\n\t}\n\n\tasync init() {\n\n\t\tconst { geojson, url } = this;\n\n\t\t// If a URL was provided and no geojson object yet, fetch it now (use fetchData so overlay can inject headers)\n\t\tif ( ! geojson && url ) {\n\n\t\t\tconst res = await this.fetchData( url );\n\t\t\tthis.geojson = await res.json();\n\n\t\t}\n\n\t\tthis._updateCache( true );\n\n\t}\n\n\thasContent( minX, minY, maxX, maxY ) {\n\n\t\t// TODO: only return true if there are features within the range\n\t\t// TODO: this won't get \"dirtied\" - no textures will be generated for those cases\n\t\t// where \"false\" has already been returned on redraw. How to fix? Return a \"false\"\n\t\t// target to fill in later if needed?\n\n\t\tconst boundsDeg = [ minX, minY, maxX, maxY ].map( v => v * Math.RAD2DEG );\n\t\treturn this._boundsIntersectBounds( boundsDeg, this.contentBounds );\n\n\t}\n\n\t// main fetch per region -> returns CanvasTexture\n\tasync fetchItem( tokens, signal ) {\n\n\t\t// create canvas\n\t\tconst canvas = document.createElement( 'canvas' );\n\t\tconst tex = new CanvasTexture( canvas );\n\t\ttex.colorSpace = SRGBColorSpace;\n\t\ttex.generateMipmaps = false;\n\n\t\tthis._drawToCanvas( canvas, tokens );\n\t\ttex.needsUpdate = true;\n\n\t\treturn tex;\n\n\t}\n\n\tdisposeItem( texture ) {\n\n\t\ttexture.dispose();\n\n\t}\n\n\tredraw() {\n\n\t\tthis._updateCache( true );\n\t\tthis.forEachItem( ( tex, args ) => {\n\n\t\t\tthis._drawToCanvas( tex.image, args );\n\t\t\ttex.needsUpdate = true;\n\n\t\t} );\n\n\t}\n\n\t_updateCache( force = false ) {\n\n\t\tconst { geojson, featureBounds } = this;\n\t\tif ( ! geojson || ( this.features && ! force ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tfeatureBounds.clear();\n\n\t\tlet minLon = Infinity;\n\t\tlet minLat = Infinity;\n\t\tlet maxLon = - Infinity;\n\t\tlet maxLat = - Infinity;\n\n\t\t// extract the relevant features\n\t\tthis.features = this._featuresFromGeoJSON( geojson );\n\t\tthis.features.forEach( feature => {\n\n\t\t\t// save the feature bounds\n\t\t\tconst bounds = this._getFeatureBounds( feature );\n\t\t\tfeatureBounds.set( feature, bounds );\n\n\t\t\t// expand full content bounds\n\t\t\tconst [ fMinLon, fMinLat, fMaxLon, fMaxLat ] = bounds;\n\t\t\tminLon = Math.min( minLon, fMinLon );\n\t\t\tminLat = Math.min( minLat, fMinLat );\n\t\t\tmaxLon = Math.max( maxLon, fMaxLon );\n\t\t\tmaxLat = Math.max( maxLat, fMaxLat );\n\n\t\t} );\n\n\t\tthis.contentBounds = [ minLon, minLat, maxLon, maxLat ];\n\n\t}\n\n\t_drawToCanvas( canvas, tokens ) {\n\n\t\tthis._updateCache();\n\n\t\tconst [ minX, minY, maxX, maxY ] = tokens;\n\t\tconst { projection, resolution, features } = this;\n\n\t\tcanvas.width = resolution;\n\t\tcanvas.height = resolution;\n\n\t\t// Convert normalized range to degrees for rendering\n\t\tconst minLonRad = projection.convertNormalizedToLongitude( minX );\n\t\tconst minLatRad = projection.convertNormalizedToLatitude( minY );\n\t\tconst maxLonRad = projection.convertNormalizedToLongitude( maxX );\n\t\tconst maxLatRad = projection.convertNormalizedToLatitude( maxY );\n\t\tconst regionBoundsDeg = [\n\t\t\tminLonRad * MathUtils.RAD2DEG,\n\t\t\tminLatRad * MathUtils.RAD2DEG,\n\t\t\tmaxLonRad * MathUtils.RAD2DEG,\n\t\t\tmaxLatRad * MathUtils.RAD2DEG,\n\t\t];\n\n\t\t// draw features\n\t\tconst ctx = canvas.getContext( '2d' );\n\t\tfor ( let i = 0; i < features.length; i ++ ) {\n\n\t\t\t// TODO: Add support for padding of tiles to avoid clipping \"wide\" elements that may extend beyond\n\t\t\t// edge of the bounds like stroke, point size.\n\t\t\tconst feature = features[ i ];\n\t\t\tif ( this._featureIntersectsTile( feature, regionBoundsDeg ) ) {\n\n\t\t\t\tthis._drawFeatureOnCanvas( ctx, feature, regionBoundsDeg, canvas.width, canvas.height );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// bounding box quick test in projected units\n\t_featureIntersectsTile( feature, boundsDeg ) {\n\n\t\tconst featureBoundsDeg = this.featureBounds.get( feature );\n\t\tif ( ! featureBoundsDeg ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn this._boundsIntersectBounds( featureBoundsDeg, boundsDeg );\n\n\t}\n\n\t_boundsIntersectBounds( bounds1, bounds2 ) {\n\n\t\t// check for intersection between bounds\n\t\tconst [ minX1, minY1, maxX1, maxY1 ] = bounds1;\n\t\tconst [ minX2, minY2, maxX2, maxY2 ] = bounds2;\n\t\treturn ! ( maxX1 < minX2 || minX1 > maxX2 || maxY1 < minY2 || minY1 > maxY2 );\n\n\t}\n\n\t_getFeatureBounds( feature ) {\n\n\t\tconst { geometry } = feature;\n\t\tif ( ! geometry ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst { type, coordinates } = geometry;\n\t\tlet minLon = Infinity;\n\t\tlet minLat = Infinity;\n\t\tlet maxLon = - Infinity;\n\t\tlet maxLat = - Infinity;\n\n\t\tconst expandBoundsByPoint = ( lon, lat ) => {\n\n\t\t\tminLon = Math.min( minLon, lon );\n\t\t\tmaxLon = Math.max( maxLon, lon );\n\t\t\tminLat = Math.min( minLat, lat );\n\t\t\tmaxLat = Math.max( maxLat, lat );\n\n\t\t};\n\n\t\tif ( type === 'Point' ) {\n\n\t\t\texpandBoundsByPoint( coordinates[ 0 ], coordinates[ 1 ] );\n\n\t\t} else if ( type === 'MultiPoint' || type === 'LineString' ) {\n\n\t\t\tcoordinates.forEach( c => expandBoundsByPoint( c[ 0 ], c[ 1 ] ) );\n\n\t\t} else if ( type === 'MultiLineString' || type === 'Polygon' ) {\n\n\t\t\tcoordinates.forEach( ring => ring.forEach( c => expandBoundsByPoint( c[ 0 ], c[ 1 ] ) ) );\n\n\t\t} else if ( type === 'MultiPolygon' ) {\n\n\t\t\tcoordinates.forEach( polygon =>\n\t\t\t\tpolygon.forEach( ring => ring.forEach( c => expandBoundsByPoint( c[ 0 ], c[ 1 ] ) ) ),\n\t\t\t);\n\n\t\t}\n\n\t\treturn [ minLon, minLat, maxLon, maxLat ];\n\n\t}\n\n\t// Normalize top-level geojson into an array of Feature objects\n\t_featuresFromGeoJSON( root ) {\n\n\t\tconst type = root.type;\n\t\tconst geomTypes = new Set( [ 'Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon' ] );\n\n\t\tif ( type === 'FeatureCollection' ) {\n\n\t\t\treturn root.features;\n\n\t\t} else if ( type === 'Feature' ) {\n\n\t\t\treturn [ root ];\n\n\t\t} else if ( type === 'GeometryCollection' ) {\n\n\t\t\treturn root.geometries.map( g => ( { type: 'Feature', geometry: g, properties: {} } ) );\n\n\t\t} else if ( geomTypes.has( type ) ) {\n\n\t\t\treturn [ { type: 'Feature', geometry: root, properties: {} } ];\n\n\t\t} else {\n\n\t\t\treturn [];\n\n\t\t}\n\n\t}\n\n\t// draw feature on canvas ( assumes intersects already )\n\t_drawFeatureOnCanvas( ctx, feature, tileBoundsDeg, width, height ) {\n\n\t\tconst { geometry = null, properties = {} } = feature;\n\t\tif ( ! geometry ) {\n\n\t\t\t// A feature may have null geometry in GeoJSON\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst [ minLonDeg, minLatDeg, maxLonDeg, maxLatDeg ] = tileBoundsDeg;\n\t\tconst strokeStyle = properties.strokeStyle || this.strokeStyle;\n\t\tconst fillStyle = properties.fillStyle || this.fillStyle;\n\t\tconst pointRadius = properties.pointRadius || this.pointRadius;\n\t\tconst strokeWidth = properties.strokeWidth || this.strokeWidth;\n\n\t\tctx.save();\n\t\tctx.strokeStyle = strokeStyle;\n\t\tctx.fillStyle = fillStyle;\n\t\tctx.lineWidth = strokeWidth;\n\n\t\t// Compute pixel from cartographic coordinates and tile bounds\n\t\tconst arr = new Array( 2 );\n\t\tconst projectPoint = ( lon, lat, target = arr ) => {\n\n\t\t\t// canvas y origin is top, projection y increases north -> flip\n\t\t\tconst x = MathUtils.mapLinear( lon, minLonDeg, maxLonDeg, 0, width );\n\t\t\tconst y = height - MathUtils.mapLinear( lat, minLatDeg, maxLatDeg, 0, height );\n\n\t\t\t// round to integer to gain performance\n\t\t\t// https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas#avoid_floating-point_coordinates_and_use_integers_instead\n\t\t\ttarget[ 0 ] = Math.round( x );\n\t\t\ttarget[ 1 ] = Math.round( y );\n\t\t\treturn target;\n\n\t\t};\n\n\t\tconst calculateAspectRatio = ( lon, lat ) => {\n\n\t\t\t// calculates the aspect ratio with which to draw points\n\t\t\tconst latRad = lat * MathUtils.DEG2RAD;\n\t\t\tconst lonRad = lon * MathUtils.DEG2RAD;\n\t\t\tconst pxLat = ( maxLatDeg - minLatDeg ) / height;\n\t\t\tconst pxLon = ( maxLonDeg - minLonDeg ) / width;\n\t\t\tconst pixelRatio = pxLon / pxLat;\n\n\t\t\t// TODO: this should use the ellipsoid defined on the relevant tiles renderer\n\t\t\treturn pixelRatio * calculateArcRatioAtPoint( WGS84_ELLIPSOID, latRad, lonRad );\n\n\t\t};\n\n\t\tconst type = geometry.type;\n\t\tif ( type === 'Point' ) {\n\n\t\t\tconst [ lon, lat ] = geometry.coordinates;\n\t\t\tconst [ px, py ] = projectPoint( lon, lat );\n\t\t\tconst drawRatio = calculateAspectRatio( lon, lat );\n\n\t\t\tctx.beginPath();\n\t\t\tctx.ellipse( px, py, pointRadius / drawRatio, pointRadius, 0, 0, Math.PI * 2 );\n\t\t\tctx.fill();\n\t\t\tctx.stroke();\n\n\t\t} else if ( type === 'MultiPoint' ) {\n\n\t\t\tgeometry.coordinates.forEach( ( [ lon, lat ] ) => {\n\n\t\t\t\tconst [ px, py ] = projectPoint( lon, lat );\n\t\t\t\tconst drawRatio = calculateAspectRatio( lon, lat );\n\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.ellipse( px, py, pointRadius / drawRatio, pointRadius, 0, 0, Math.PI * 2 );\n\t\t\t\tctx.fill();\n\t\t\t\tctx.stroke();\n\n\t\t\t} );\n\n\t\t} else if ( type === 'LineString' ) {\n\n\t\t\tctx.beginPath();\n\t\t\tgeometry.coordinates.forEach( ( [ lon, lat ], i ) => {\n\n\t\t\t\tconst [ px, py ] = projectPoint( lon, lat );\n\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\tctx.moveTo( px, py );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tctx.lineTo( px, py );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tctx.stroke();\n\n\t\t} else if ( type === 'MultiLineString' ) {\n\n\t\t\tctx.beginPath();\n\t\t\tgeometry.coordinates.forEach( ( line ) => {\n\n\t\t\t\tline.forEach( ( [ lon, lat ], i ) => {\n\n\t\t\t\t\tconst [ px, py ] = projectPoint( lon, lat );\n\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\tctx.moveTo( px, py );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tctx.lineTo( px, py );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t} );\n\t\t\tctx.stroke();\n\n\t\t} else if ( type === 'Polygon' ) {\n\n\t\t\tctx.beginPath();\n\t\t\tgeometry.coordinates.forEach( ( ring, rIndex ) => {\n\n\t\t\t\tring.forEach( ( [ lon, lat ], i ) => {\n\n\t\t\t\t\tconst [ px, py ] = projectPoint( lon, lat );\n\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\tctx.moveTo( px, py );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tctx.lineTo( px, py );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\t\t\t\tctx.closePath();\n\n\t\t\t} );\n\t\t\tctx.fill( 'evenodd' );\n\t\t\tctx.stroke();\n\n\t\t} else if ( type === 'MultiPolygon' ) {\n\n\t\t\tgeometry.coordinates.forEach( ( polygon ) => {\n\n\t\t\t\tctx.beginPath();\n\t\t\t\tpolygon.forEach( ( ring, rIndex ) => {\n\n\t\t\t\t\tring.forEach( ( [ lon, lat ], i ) => {\n\n\t\t\t\t\t\tconst [ px, py ] = projectPoint( lon, lat );\n\t\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\t\tctx.moveTo( px, py );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tctx.lineTo( px, py );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\t\t\t\t\tctx.closePath();\n\n\t\t\t\t} );\n\t\t\t\tctx.fill( 'evenodd' );\n\t\t\t\tctx.stroke();\n\n\t\t\t} );\n\n\t\t}\n\n\t\tctx.restore();\n\n\t}\n\n}\n","import { Color, BufferAttribute, Matrix4, Vector3, Box3, Triangle, CanvasTexture } from 'three';\nimport { PriorityQueue, PriorityQueueItemRemovedError } from '3d-tiles-renderer/core';\nimport { CesiumIonAuth, GoogleCloudAuth } from '3d-tiles-renderer/core/plugins';\nimport { XYZImageSource } from './sources/XYZImageSource.js';\nimport { QuadKeyImageSource } from './sources/QuadKeyImageSource.js';\nimport { TMSImageSource } from './sources/TMSImageSource.js';\nimport { getMeshesCartographicRange, getMeshesPlanarRange } from './overlays/utils.js';\nimport { wrapOverlaysMaterial } from './overlays/wrapOverlaysMaterial.js';\nimport { GeometryClipper } from '../utilities/GeometryClipper.js';\nimport { WMTSImageSource } from './sources/WMTSImageSource.js';\nimport { MemoryUtils } from '3d-tiles-renderer/three';\nimport { GeoJSONImageSource } from './sources/GeoJSONImageSource.js';\nimport { WMSImageSource } from './sources/WMSImageSource.js';\nimport { TiledRegionImageSource } from './sources/RegionImageSource.js';\nimport { TiledTextureComposer } from './overlays/TiledTextureComposer.js';\n\nconst _matrix = /* @__PURE__ */ new Matrix4();\nconst _vec = /* @__PURE__ */ new Vector3();\nconst _center = /* @__PURE__ */ new Vector3();\nconst _sphereCenter = /* @__PURE__ */ new Vector3();\nconst _normal = /* @__PURE__ */ new Vector3();\nconst _box = /* @__PURE__ */ new Box3();\nconst SPLIT_TILE_DATA = Symbol( 'SPLIT_TILE_DATA' );\nconst SPLIT_HASH = Symbol( 'SPLIT_HASH' );\n\n// Plugin for overlaying tiled image data on top of 3d tiles geometry.\nexport class ImageOverlayPlugin {\n\n\tget enableTileSplitting() {\n\n\t\treturn this._enableTileSplitting;\n\n\t}\n\n\tset enableTileSplitting( v ) {\n\n\t\tif ( this._enableTileSplitting !== v ) {\n\n\t\t\tthis._enableTileSplitting = v;\n\t\t\tthis._markNeedsUpdate();\n\n\t\t}\n\n\t}\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\toverlays = [],\n\t\t\tresolution = 256,\n\t\t\tenableTileSplitting = true,\n\t\t} = options;\n\n\t\t// plugin needs to run before other plugins that fetch data since content\n\t\t// is handled and loaded in a custom way\n\t\tthis.name = 'IMAGE_OVERLAY_PLUGIN';\n\t\tthis.priority = - 15;\n\n\t\t// options\n\t\tthis.resolution = resolution;\n\t\tthis._enableTileSplitting = enableTileSplitting;\n\t\tthis.overlays = [];\n\n\t\t// internal\n\t\tthis.needsUpdate = false;\n\t\tthis.tiles = null;\n\t\tthis.tileComposer = null;\n\t\tthis.tileControllers = new Map();\n\t\tthis.overlayInfo = new Map();\n\t\tthis.meshParams = new WeakMap();\n\t\tthis.pendingTiles = new Map();\n\t\tthis.processedTiles = new Set();\n\t\tthis.processQueue = null;\n\t\tthis._onUpdateAfter = null;\n\t\tthis._onTileDownloadStart = null;\n\t\tthis._virtualChildResetId = 0;\n\t\tthis._bytesUsed = new WeakMap();\n\n\t\toverlays.forEach( overlay => {\n\n\t\t\tthis.addOverlay( overlay );\n\n\t\t} );\n\n\t}\n\n\t// plugin functions\n\tinit( tiles ) {\n\n\t\tconst tileComposer = new TiledTextureComposer();\n\t\tconst processQueue = new PriorityQueue();\n\t\tprocessQueue.maxJobs = 10;\n\t\tprocessQueue.priorityCallback = ( a, b ) => {\n\n\t\t\tconst tileA = a.tile;\n\t\t\tconst tileB = b.tile;\n\n\t\t\tconst visibleA = tiles.visibleTiles.has( tileA );\n\t\t\tconst visibleB = tiles.visibleTiles.has( tileB );\n\t\t\tif ( visibleA !== visibleB ) {\n\n\t\t\t\t// load visible tiles first\n\t\t\t\treturn visibleA ? 1 : - 1;\n\n\t\t\t} else {\n\n\t\t\t\t// the fallback to the download queue tile priority\n\t\t\t\treturn tiles.downloadQueue.priorityCallback( tileA, tileB );\n\n\t\t\t}\n\n\t\t\t// TODO: we could prioritize by overlay order here to ensure consistency\n\n\t\t};\n\n\t\t// save variables\n\t\tthis.tiles = tiles;\n\t\tthis.tileComposer = tileComposer;\n\t\tthis.processQueue = processQueue;\n\n\t\t// init all existing tiles\n\t\ttiles.forEachLoadedModel( ( scene, tile ) => {\n\n\t\t\tthis._processTileModel( scene, tile, true );\n\n\t\t} );\n\n\t\t// update callback for when overlays have changed\n\t\tthis._onUpdateAfter = async () => {\n\n\t\t\t// check if the projection changed for any of the overlays and refresh them\n\t\t\tlet overlayChanged = false;\n\t\t\tthis.overlayInfo.forEach( ( info, overlay ) => {\n\n\t\t\t\tif (\n\t\t\t\t\tBoolean( overlay.frame ) !== Boolean( info.frame ) ||\n\t\t\t\t\toverlay.frame && info.frame && ! info.frame.equals( overlay.frame )\n\t\t\t\t) {\n\n\t\t\t\t\tconst order = info.order;\n\t\t\t\t\tthis.deleteOverlay( overlay );\n\t\t\t\t\tthis.addOverlay( overlay, order );\n\n\t\t\t\t\toverlayChanged = true;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\t// trigger redraws for visible tiles if overlays updated\n\t\t\tif ( overlayChanged ) {\n\n\t\t\t\tconst maxJobs = processQueue.maxJobs;\n\t\t\t\tlet count = 0;\n\t\t\t\tprocessQueue.items.forEach( info => {\n\n\t\t\t\t\tif ( tiles.visibleTiles.has( info.tile ) ) {\n\n\t\t\t\t\t\tcount ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tprocessQueue.maxJobs = count + processQueue.currJobs;\n\t\t\t\tprocessQueue.tryRunJobs();\n\t\t\t\tprocessQueue.maxJobs = maxJobs;\n\n\t\t\t\tthis.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\t// update all the layer uvs\n\t\t\tif ( this.needsUpdate ) {\n\n\t\t\t\tthis.needsUpdate = false;\n\n\t\t\t\tconst { overlays, overlayInfo } = this;\n\t\t\t\toverlays.sort( ( a, b ) => {\n\n\t\t\t\t\treturn overlayInfo.get( a ).order - overlayInfo.get( b ).order;\n\n\t\t\t\t} );\n\n\t\t\t\tthis.processedTiles.forEach( tile => {\n\n\t\t\t\t\tthis._updateLayers( tile );\n\n\t\t\t\t} );\n\n\t\t\t\tthis.resetVirtualChildren( ! this.enableTileSplitting );\n\t\t\t\ttiles.recalculateBytesUsed();\n\n\t\t\t\ttiles.dispatchEvent( { type: 'needs-rerender' } );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis._onTileDownloadStart = ( { tile, url } ) => {\n\n\t\t\t// TODO: it's not super straight forward to detect whether a tile is \"geometry\" or not ahead of time. Checking\n\t\t\t// for \"subtree\" or \"json\" are good broad strokes but some cases will still be missed.\n\t\t\tif ( ! /\\.json$/i.test( url ) && ! /\\.subtree/i.test( url ) ) {\n\n\t\t\t\tthis.processedTiles.add( tile );\n\t\t\t\tthis._initTileOverlayInfo( tile );\n\n\t\t\t}\n\n\t\t};\n\n\t\ttiles.addEventListener( 'update-after', this._onUpdateAfter );\n\t\ttiles.addEventListener( 'tile-download-start', this._onTileDownloadStart );\n\n\t\tthis.overlays.forEach( overlay => {\n\n\t\t\tthis._initOverlay( overlay );\n\n\t\t} );\n\n\t}\n\n\tdisposeTile( tile ) {\n\n\t\tconst { overlayInfo, tileControllers, processQueue, pendingTiles, processedTiles } = this;\n\n\t\tprocessedTiles.delete( tile );\n\n\t\t// Cancel any ongoing tasks. If a tile is cancelled while downloading\n\t\t// this will not have been created, yet.\n\t\tif ( tileControllers.has( tile ) ) {\n\n\t\t\ttileControllers.get( tile ).abort();\n\t\t\ttileControllers.delete( tile );\n\t\t\tpendingTiles.delete( tile );\n\n\t\t}\n\n\t\t// stop any tile loads\n\t\toverlayInfo.forEach( ( ( { tileInfo }, overlay ) => {\n\n\t\t\tif ( tileInfo.has( tile ) ) {\n\n\t\t\t\tconst { meshInfo, range } = tileInfo.get( tile );\n\n\t\t\t\tif ( range !== null ) {\n\n\t\t\t\t\toverlay.releaseTexture( range, tile );\n\n\t\t\t\t}\n\n\t\t\t\ttileInfo.delete( tile );\n\t\t\t\tmeshInfo.clear();\n\n\t\t\t}\n\n\t\t} ) );\n\n\t\t// Remove any items that reference the tile being disposed\n\t\tprocessQueue.removeByFilter( item => {\n\n\t\t\treturn item.tile === tile;\n\n\t\t} );\n\n\t}\n\n\tcalculateBytesUsed( tile ) {\n\n\t\tconst { overlayInfo } = this;\n\t\tconst bytesUsed = this._bytesUsed;\n\n\t\tlet bytes = null;\n\t\toverlayInfo.forEach( ( { tileInfo }, overlay ) => {\n\n\t\t\tif ( tileInfo.has( tile ) ) {\n\n\t\t\t\tconst { target } = tileInfo.get( tile );\n\t\t\t\tbytes = bytes || 0;\n\t\t\t\tbytes += MemoryUtils.getTextureByteLength( target );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( bytes !== null ) {\n\n\t\t\tbytesUsed.set( tile, bytes );\n\t\t\treturn bytes;\n\n\t\t} else if ( bytesUsed.has( tile ) ) {\n\n\t\t\treturn bytesUsed.get( tile );\n\n\t\t} else {\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\tprocessTileModel( scene, tile ) {\n\n\t\treturn this._processTileModel( scene, tile );\n\n\t}\n\n\tasync _processTileModel( scene, tile, initialization = false ) {\n\n\t\tconst { tileControllers, processedTiles, pendingTiles } = this;\n\n\t\ttileControllers.set( tile, new AbortController() );\n\n\t\tif ( ! initialization ) {\n\n\t\t\t// we save all these pending tiles so that they can be correctly initialized if an\n\t\t\t// overlay is added in the time between when this function starts and after the async\n\t\t\t// await call. Otherwise the tile could be missed. But if we're initializing the plugin\n\t\t\t// then we don't need to do this because the tiles are already included in the traversal.\n\t\t\tpendingTiles.set( tile, scene );\n\n\t\t}\n\n\t\t// track which tiles we have been processed and remove them in \"disposeTile\"\n\t\tprocessedTiles.add( tile );\n\n\t\tthis._wrapMaterials( scene );\n\t\tthis._initTileOverlayInfo( tile );\n\t\tawait this._initTileSceneOverlayInfo( scene, tile );\n\t\tthis.expandVirtualChildren( scene, tile );\n\t\tthis._updateLayers( tile );\n\n\t\tpendingTiles.delete( tile );\n\n\t}\n\n\tdispose() {\n\n\t\tconst { tiles } = this;\n\n\t\t// dispose of all overlays\n\t\tconst overlays = [ ...this.overlays ];\n\t\toverlays.forEach( overlay => {\n\n\t\t\tthis.deleteOverlay( overlay );\n\n\t\t} );\n\n\t\t// reset the textures of the meshes\n\t\tthis.processedTiles.forEach( tile => {\n\n\t\t\tthis._updateLayers( tile );\n\t\t\tthis.disposeTile( tile );\n\n\t\t\tdelete tile[ SPLIT_HASH ];\n\n\t\t} );\n\n\t\ttiles.removeEventListener( 'update-after', this._onUpdateAfter );\n\n\t\tthis.resetVirtualChildren( true );\n\n\t}\n\n\tgetAttributions( target ) {\n\n\t\tthis.overlays.forEach( overlay => {\n\n\t\t\tif ( overlay.opacity > 0 ) {\n\n\t\t\t\toverlay.getAttributions( target );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\tparseToMesh( buffer, tile, extension, uri ) {\n\n\t\tif ( extension === 'image_overlay_tile_split' ) {\n\n\t\t\treturn tile[ SPLIT_TILE_DATA ];\n\n\t\t}\n\n\t}\n\n\tasync resetVirtualChildren( fullDispose = false ) {\n\n\t\t// only run this if all the overlays are ready and tile targets have been generated, etc\n\t\t// so we can make an effort to only remove the necessary tiles.\n\t\tthis._virtualChildResetId ++;\n\t\tconst id = this._virtualChildResetId;\n\n\t\tawait Promise.all( this.overlays.map( o => o.whenReady() ) );\n\n\t\tif ( id !== this._virtualChildResetId ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// collect the tiles split into virtual tiles\n\t\tconst { tiles } = this;\n\t\tconst parents = new Set();\n\t\tthis.processedTiles.forEach( tile => {\n\n\t\t\tif ( SPLIT_HASH in tile ) {\n\n\t\t\t\tparents.add( tile );\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// dispose of the virtual children if this tile would not be split or the spilt could change\n\t\t// under the current overlays used.\n\t\tparents.forEach( parent => {\n\n\t\t\tif ( parent.parent === null ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst clone = parent.engineData.scene.clone();\n\t\t\tclone.updateMatrixWorld();\n\n\t\t\tif ( fullDispose || parent[ SPLIT_HASH ] !== this._getSplitVectors( clone, parent ).hash ) {\n\n\t\t\t\t// TODO: if are parent tile is forcibly remove then we should make sure that all the children are, too?\n\t\t\t\tconst children = collectChildren( parent );\n\t\t\t\tchildren.sort( ( a, b ) => ( b.internal.depth || 0 ) - ( a.internal.depth || 0 ) );\n\n\t\t\t\t// note that we need to remove children from the processing queue in this case\n\t\t\t\t// because we are forcibly evicting them from the cache.\n\t\t\t\tchildren.forEach( child => {\n\n\t\t\t\t\ttiles.processNodeQueue.remove( child );\n\t\t\t\t\ttiles.lruCache.remove( child );\n\t\t\t\t\tchild.parent = null;\n\n\t\t\t\t} );\n\n\t\t\t\tparent.children.length = 0;\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// re-expand tiles if needed\n\t\tif ( ! fullDispose ) {\n\n\t\t\ttiles.forEachLoadedModel( ( scene, tile ) => {\n\n\t\t\t\tthis.expandVirtualChildren( scene, tile );\n\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction collectChildren( root, target = [] ) {\n\n\t\t\troot.children.forEach( child => {\n\n\t\t\t\ttarget.push( child );\n\t\t\t\tcollectChildren( child, target );\n\n\t\t\t} );\n\t\t\treturn target;\n\n\t\t}\n\n\t}\n\n\t_getSplitVectors( scene, tile, centerTarget = _center ) {\n\n\t\tconst { tiles, overlayInfo } = this;\n\n\t\t// get the center of the content\n\t\tconst box = new Box3();\n\t\tbox.setFromObject( scene );\n\t\tbox.getCenter( centerTarget );\n\n\t\t// find the vectors that are orthogonal to every overlay projection\n\t\tconst splitDirections = [];\n\t\tconst hashTokens = [];\n\t\toverlayInfo.forEach( ( { tileInfo }, overlay ) => {\n\n\t\t\t// if the tile has a render target associated with the overlay and the last level of detail\n\t\t\t// is not being displayed, yet, then we need to split\n\t\t\tconst info = tileInfo.get( tile );\n\t\t\tif ( info && info.target && overlay.shouldSplit( info.range, tile ) ) {\n\n\t\t\t\t// get the vector representing the projection direction\n\t\t\t\tif ( overlay.frame ) {\n\n\t\t\t\t\t_normal.set( 0, 0, 1 ).transformDirection( overlay.frame );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttiles.ellipsoid.getPositionToNormal( centerTarget, _normal );\n\t\t\t\t\tif ( _normal.length() < 1e-6 ) {\n\n\t\t\t\t\t\t_normal.set( 1, 0, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// dedupe vectors in the hash\n\t\t\t\tconst token = `${ _normal.x.toFixed( 3 ) },${ _normal.y.toFixed( 3 ) },${ _normal.z.toFixed( 3 ) }_`;\n\t\t\t\tif ( ! hashTokens.includes( token ) ) {\n\n\t\t\t\t\thashTokens.push( token );\n\n\t\t\t\t}\n\n\t\t\t\t// construct the orthogonal vectors\n\t\t\t\tconst other = _vec.set( 0, 0, 1 );\n\t\t\t\tif ( Math.abs( _normal.dot( other ) ) > 1 - 1e-4 ) {\n\n\t\t\t\t\tother.set( 1, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tconst ortho0 = new Vector3().crossVectors( _normal, other ).normalize();\n\t\t\t\tconst ortho1 = new Vector3().crossVectors( _normal, ortho0 ).normalize();\n\t\t\t\tsplitDirections.push( ortho0, ortho1 );\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// Generate a reduced set of vectors by averages directions in a 45 degree cone so\n\t\t// we don't split unnecessarily\n\t\tconst directions = [];\n\t\twhile ( splitDirections.length !== 0 ) {\n\n\t\t\tconst normalized = splitDirections.pop().clone();\n\t\t\tconst average = normalized.clone();\n\t\t\tfor ( let i = 0; i < splitDirections.length; i ++ ) {\n\n\t\t\t\tconst dir = splitDirections[ i ];\n\t\t\t\tconst dotProduct = normalized.dot( dir );\n\t\t\t\tif ( Math.abs( dotProduct ) > Math.cos( Math.PI / 8 ) ) {\n\n\t\t\t\t\taverage.addScaledVector( dir, Math.sign( dotProduct ) );\n\t\t\t\t\tnormalized.copy( average ).normalize();\n\t\t\t\t\tsplitDirections.splice( i, 1 );\n\t\t\t\t\ti --;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdirections.push( average.normalize() );\n\n\t\t}\n\n\t\treturn { directions, hash: hashTokens.join( '' ) };\n\n\t}\n\n\tasync expandVirtualChildren( scene, tile ) {\n\n\t\tif ( tile.children.length !== 0 || this.enableTileSplitting === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// create a copy of the content to transform and split\n\t\tconst clone = scene.clone();\n\t\tclone.updateMatrixWorld();\n\n\t\t// get the directions to split on\n\t\tconst { directions, hash } = this._getSplitVectors( clone, tile, _center );\n\t\ttile[ SPLIT_HASH ] = hash;\n\n\t\t// if there are no directions to split on then exit early\n\t\tif ( directions.length === 0 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// set up the splitter to ignore overlay uvs\n\t\tconst clipper = new GeometryClipper();\n\t\tclipper.attributeList = key => ! /^layer_uv_\\d+/.test( key );\n\t\tdirections.map( splitDirection => {\n\n\t\t\tclipper.addSplitOperation( ( geometry, i0, i1, i2, barycoord, matrixWorld ) => {\n\n\t\t\t\tTriangle.getInterpolatedAttribute( geometry.attributes.position, i0, i1, i2, barycoord, _vec );\n\t\t\t\treturn _vec.applyMatrix4( matrixWorld ).sub( _center ).dot( splitDirection );\n\n\t\t\t} );\n\n\t\t} );\n\n\t\t// run the clipping operations by performing every permutation of sides\n\t\t// defined by the split directions\n\t\tconst children = [];\n\t\tclipper.forEachSplitPermutation( () => {\n\n\t\t\t// clip the object itself\n\t\t\tconst result = clipper.clipObject( clone );\n\n\t\t\t// remove the parent transform because it will be multiplied back in after the fact\n\t\t\tresult.matrix\n\t\t\t\t.premultiply( tile.engineData.transformInverse )\n\t\t\t\t.decompose( result.position, result.quaternion, result.scale );\n\n\t\t\t// collect the meshes\n\t\t\tconst meshes = [];\n\t\t\tresult.traverse( c => {\n\n\t\t\t\tif ( c.isMesh ) {\n\n\t\t\t\t\tconst material = c.material.clone();\n\t\t\t\t\tc.material = material;\n\t\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\t\tconst value = material[ key ];\n\t\t\t\t\t\tif ( value && value.isTexture ) {\n\n\t\t\t\t\t\t\tif ( value.source.data instanceof ImageBitmap ) {\n\n\t\t\t\t\t\t\t\t// clone any image bitmap textures using canvas because if we share the texture then when\n\t\t\t\t\t\t\t\t// the clipped child is disposed then it will dispose of the parent tile texture data, as well.\n\t\t\t\t\t\t\t\tconst canvas = document.createElement( 'canvas' );\n\t\t\t\t\t\t\t\tcanvas.width = value.image.width;\n\t\t\t\t\t\t\t\tcanvas.height = value.image.height;\n\n\t\t\t\t\t\t\t\tconst ctx = canvas.getContext( '2d' );\n\t\t\t\t\t\t\t\tctx.scale( 1, - 1 );\n\t\t\t\t\t\t\t\tctx.drawImage( value.source.data, 0, 0, canvas.width, - canvas.height );\n\n\t\t\t\t\t\t\t\tconst tex = new CanvasTexture( canvas );\n\t\t\t\t\t\t\t\ttex.mapping = value.mapping;\n\t\t\t\t\t\t\t\ttex.wrapS = value.wrapS;\n\t\t\t\t\t\t\t\ttex.wrapT = value.wrapT;\n\t\t\t\t\t\t\t\ttex.minFilter = value.minFilter;\n\t\t\t\t\t\t\t\ttex.magFilter = value.magFilter;\n\t\t\t\t\t\t\t\ttex.format = value.format;\n\t\t\t\t\t\t\t\ttex.type = value.type;\n\t\t\t\t\t\t\t\ttex.anisotropy = value.anisotropy;\n\t\t\t\t\t\t\t\ttex.colorSpace = value.colorSpace;\n\t\t\t\t\t\t\t\ttex.generateMipmaps = value.generateMipmaps;\n\n\t\t\t\t\t\t\t\tmaterial[ key ] = tex;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmeshes.push( c );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tif ( meshes.length === 0 ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// generate a region bounding volume\n\t\t\tconst boundingVolume = {};\n\t\t\tif ( tile.boundingVolume.region ) {\n\n\t\t\t\tboundingVolume.region = getMeshesCartographicRange( meshes, this.tiles.ellipsoid ).region;\n\n\t\t\t}\n\n\t\t\t// create a sphere bounding volume\n\t\t\tif ( tile.boundingVolume.box || tile.boundingVolume.sphere ) {\n\n\t\t\t\t// TODO: we create a sphere even when a region is present because currently the handling of region volumes\n\t\t\t\t// is a bit flaky especially at small scales. OBBs are generated which can be imperfect resulting rays passing\n\t\t\t\t// through tiles. The same may be the case with frustum checks. In theory, though, we should not need a sphere\n\t\t\t\t// bounds if a region bounds are present.\n\n\t\t\t\t// compute the sphere center\n\t\t\t\t_box\n\t\t\t\t\t.setFromObject( result, true )\n\t\t\t\t\t.getCenter( _sphereCenter );\n\n\t\t\t\t// calculate the sq radius from all vertices\n\t\t\t\tlet maxSqRadius = 0;\n\t\t\t\tresult.traverse( c => {\n\n\t\t\t\t\tconst geometry = c.geometry;\n\t\t\t\t\tif ( geometry ) {\n\n\t\t\t\t\t\tconst position = geometry.attributes.position;\n\t\t\t\t\t\tfor ( let i = 0, l = position.count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst sqRadius = _vec\n\t\t\t\t\t\t\t\t.fromBufferAttribute( position, i )\n\t\t\t\t\t\t\t\t.applyMatrix4( c.matrixWorld )\n\t\t\t\t\t\t\t\t.distanceToSquared( _sphereCenter );\n\n\t\t\t\t\t\t\tmaxSqRadius = Math.max( maxSqRadius, sqRadius );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tboundingVolume.sphere = [ ..._sphereCenter, Math.sqrt( maxSqRadius ) ];\n\n\t\t\t}\n\n\t\t\tchildren.push( {\n\t\t\t\trefine: 'REPLACE',\n\t\t\t\tgeometricError: tile.geometricError * 0.5,\n\t\t\t\tboundingVolume: boundingVolume,\n\t\t\t\tcontent: { uri: './child.image_overlay_tile_split' },\n\t\t\t\tchildren: [],\n\t\t\t\t[ SPLIT_TILE_DATA ]: result,\n\t\t\t} );\n\n\t\t} );\n\n\t\t// force the tile \"refine\" mode to be set to \"REPLACE\" if we're splitting tiles\n\t\t// TODO: If a tile is of type \"ADD\" refine and it has children then it will not be split\n\t\t// as expected since only geometry tiles with no children are split. Instead we'd want\n\t\t// to split this tiles geometry in addition to adding the child tiles.\n\t\ttile.refine = 'REPLACE';\n\t\ttile.children.push( ...children );\n\n\t}\n\n\tfetchData( uri, options ) {\n\n\t\t// if this is our custom url indicating a tile split then return fake response\n\t\tif ( /image_overlay_tile_split/.test( uri ) ) {\n\n\t\t\treturn new ArrayBuffer();\n\n\t\t}\n\n\t}\n\n\t// public\n\taddOverlay( overlay, order = null ) {\n\n\t\tconst { tiles, overlays, overlayInfo } = this;\n\n\t\tif ( order === null ) {\n\n\t\t\t// set the order to the next largest order value\n\t\t\torder = overlays.reduce( ( v, o ) => Math.max( v, o.order + 1 ), 0 );\n\n\t\t}\n\n\t\tconst controller = new AbortController();\n\t\toverlays.push( overlay );\n\t\toverlayInfo.set( overlay, {\n\t\t\torder: order,\n\t\t\tuniforms: {},\n\t\t\ttileInfo: new Map(),\n\t\t\tcontroller: controller,\n\t\t\tframe: overlay.frame ? overlay.frame.clone() : null,\n\t\t} );\n\n\t\tif ( tiles !== null ) {\n\n\t\t\tthis._initOverlay( overlay );\n\n\t\t}\n\n\t}\n\n\tsetOverlayOrder( overlay, order ) {\n\n\t\tconst index = this.overlays.indexOf( overlay );\n\t\tif ( index !== - 1 ) {\n\n\t\t\tthis.overlayInfo.get( overlay ).order = order;\n\t\t\tthis._markNeedsUpdate();\n\n\t\t}\n\n\t}\n\n\tdeleteOverlay( overlay ) {\n\n\t\tconst { overlays, overlayInfo, processQueue, processedTiles } = this;\n\t\tconst index = overlays.indexOf( overlay );\n\t\tif ( index !== - 1 ) {\n\n\t\t\t// delete tile info explicitly instead of blindly dispose of the full overlay\n\t\t\tconst { tileInfo, controller } = overlayInfo.get( overlay );\n\t\t\tprocessedTiles.forEach( tile => {\n\n\t\t\t\tif ( ! tileInfo.has( tile ) ) {\n\n\t\t\t\t\t// check for the case where tiles have been added but not properly initialized with the\n\t\t\t\t\t// given overlay, yet\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tconst {\n\t\t\t\t\tmeshInfo,\n\t\t\t\t\trange,\n\t\t\t\t} = tileInfo.get( tile );\n\n\t\t\t\t// release the ranges\n\t\t\t\tif ( range !== null ) {\n\n\t\t\t\t\toverlay.releaseTexture( range, tile );\n\n\t\t\t\t}\n\n\t\t\t\ttileInfo.delete( tile );\n\t\t\t\tmeshInfo.clear();\n\n\t\t\t} );\n\n\t\t\ttileInfo.clear();\n\t\t\toverlayInfo.delete( overlay );\n\t\t\tcontroller.abort();\n\n\t\t\t// Remove any items that reference the overlay being disposed\n\t\t\tprocessQueue.removeByFilter( item => {\n\n\t\t\t\treturn item.overlay === overlay;\n\n\t\t\t} );\n\n\t\t\t// remove the overlay\n\t\t\toverlays.splice( index, 1 );\n\n\t\t\t// update all tiles to truncate texture arrays and remove references immediately\n\t\t\tprocessedTiles.forEach( tile => {\n\n\t\t\t\tthis._updateLayers( tile );\n\n\t\t\t} );\n\n\t\t\tthis._markNeedsUpdate();\n\n\t\t}\n\n\t}\n\n\t// initialize the overlay to use the right fetch options, load all data for existing tiles\n\t_initOverlay( overlay ) {\n\n\t\tconst { tiles } = this;\n\n\t\tif ( ! overlay.isInitialized ) {\n\n\t\t\toverlay.init();\n\n\t\t\toverlay.whenReady().then( () => {\n\n\t\t\t\t// Set resolution on the overlay\n\t\t\t\toverlay.setResolution( this.resolution );\n\n\t\t\t\tconst overlayFetch = overlay.fetch.bind( overlay );\n\t\t\t\toverlay.fetch = ( ...args ) => tiles\n\t\t\t\t\t.downloadQueue\n\t\t\t\t\t.add( { priority: - performance.now() }, () => {\n\n\t\t\t\t\t\treturn overlayFetch( ...args );\n\n\t\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t}\n\n\t\tconst promises = [];\n\t\tconst initTile = async ( scene, tile ) => {\n\n\t\t\tthis._initTileOverlayInfo( tile, overlay );\n\n\t\t\tconst promise = this._initTileSceneOverlayInfo( scene, tile, overlay );\n\t\t\tpromises.push( promise );\n\n\t\t\t// mark tiles as needing an update after initialized so we get a trickle in of tiles\n\t\t\tawait promise;\n\t\t\tthis._updateLayers( tile );\n\n\t\t};\n\n\t\ttiles.forEachLoadedModel( ( scene, tile ) => {\n\n\t\t\tinitTile( scene, tile );\n\n\t\t} );\n\n\t\tthis.pendingTiles.forEach( ( scene, tile ) => {\n\n\t\t\tinitTile( scene, tile );\n\n\t\t} );\n\n\t\tPromise.all( promises ).then( () => {\n\n\t\t\tthis._markNeedsUpdate();\n\n\t\t} );\n\n\t}\n\n\t// wrap all materials in the given scene wit the overlay material shader\n\t_wrapMaterials( scene ) {\n\n\t\tscene.traverse( c => {\n\n\t\t\tif ( c.material ) {\n\n\t\t\t\tconst params = wrapOverlaysMaterial( c.material, c.material.onBeforeCompile );\n\t\t\t\tthis.meshParams.set( c, params );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t// Initialize per-tile overlay information. This function triggers an async function but\n\t// does not need to be awaited for use since it's just locking textures which are awaited later.\n\t_initTileOverlayInfo( tile, overlay = this.overlays ) {\n\n\t\tif ( Array.isArray( overlay ) ) {\n\n\t\t\toverlay.forEach( o => this._initTileOverlayInfo( tile, o ) );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// This function is resilient to multiple calls in case an overlay is added after a tile starts loading\n\t\t// and before it is loaded, meaning this function needs to be called twice to ensure it's initialized.\n\t\tconst { overlayInfo } = this;\n\t\tif ( overlayInfo.get( overlay ).tileInfo.has( tile ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst info = {\n\t\t\trange: null,\n\t\t\ttarget: null,\n\t\t\tmeshInfo: new Map(),\n\t\t};\n\n\t\toverlayInfo\n\t\t\t.get( overlay )\n\t\t\t.tileInfo\n\t\t\t.set( tile, info );\n\n\t\t// if the overlay isn't ready then we can't convert the range correctly, yet\n\t\tif ( overlay.isReady ) {\n\n\t\t\tif ( overlay.isPlanarProjection ) {\n\n\t\t\t\t// TODO: we could project the shape into the frame, compute 2d bounds, and then mark tiles\n\n\t\t\t} else if ( tile.boundingVolume.region ) {\n\n\t\t\t\t// If the tile has a region bounding volume then mark the tiles to preload\n\t\t\t\tconst [ minLon, minLat, maxLon, maxLat ] = tile.boundingVolume.region;\n\t\t\t\tconst range = overlay.projection.toNormalizedRange( [ minLon, minLat, maxLon, maxLat ] );\n\n\t\t\t\t// TODO: locking the texture here causes compositing to happen immediately which can be performance intensive,\n\t\t\t\t// particularly in cases like GeoJSON loader. Ideally the compositing / final drw step to \"lock\" would be deferred\n\t\t\t\t// as well, just like the tile image loads.\n\t\t\t\tinfo.range = range;\n\t\t\t\toverlay.lockTexture( range, tile );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// initialize the scene meshes\n\tasync _initTileSceneOverlayInfo( scene, tile, overlay = this.overlays ) {\n\n\t\tif ( Array.isArray( overlay ) ) {\n\n\t\t\treturn Promise.all( overlay.map( o => this._initTileSceneOverlayInfo( scene, tile, o ) ) );\n\n\t\t}\n\n\t\tconst { tiles, overlayInfo, tileControllers, processQueue } = this;\n\t\tconst { ellipsoid } = tiles;\n\t\tconst { controller, tileInfo } = overlayInfo.get( overlay );\n\t\tconst tileController = tileControllers.get( tile );\n\n\t\t// wait for the overlay to be completely loaded so projection and tiling are available\n\t\tif ( ! overlay.isReady ) {\n\n\t\t\tawait overlay.whenReady();\n\n\t\t}\n\n\t\t// check if the overlay or tile have been disposed since starting this function\n\t\t// if the tileController is not present then the tile has been disposed of already\n\t\tif ( controller.signal.aborted || tileController.signal.aborted ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// find all meshes to project on and ensure matrices are up to date\n\t\tconst meshes = [];\n\t\tscene.updateMatrixWorld();\n\t\tscene.traverse( c => {\n\n\t\t\tif ( c.isMesh ) {\n\n\t\t\t\tmeshes.push( c );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tconst { aspectRatio, projection } = overlay;\n\t\tconst info = tileInfo.get( tile );\n\t\tlet range, uvs, heightInRange;\n\n\t\t// retrieve the uvs and range for all the meshes\n\t\tif ( overlay.isPlanarProjection ) {\n\n\t\t\t// construct a matrix transforming _into_ the local frame in which the texture\n\t\t\t// will be sampled, scaling by the aspect ratio of the overlay so it is scaled\n\t\t\t// to [0, 1]\n\t\t\t_matrix\n\t\t\t\t.makeScale( 1 / aspectRatio, 1, 1 )\n\t\t\t\t.multiply( overlay.frame );\n\n\t\t\tif ( scene.parent !== null ) {\n\n\t\t\t\t_matrix.multiply( tiles.group.matrixWorldInverse );\n\n\t\t\t}\n\n\t\t\tlet heightRange;\n\t\t\t( { range, uvs, heightRange } = getMeshesPlanarRange( meshes, _matrix ) );\n\t\t\theightInRange = ! ( heightRange[ 0 ] > 1 || heightRange[ 1 ] < 0 );\n\n\t\t} else {\n\n\t\t\t_matrix.identity();\n\t\t\tif ( scene.parent !== null ) {\n\n\t\t\t\t_matrix.copy( tiles.group.matrixWorldInverse );\n\n\t\t\t}\n\n\t\t\t( { range, uvs } = getMeshesCartographicRange( meshes, ellipsoid, _matrix, projection ) );\n\t\t\trange = projection.toNormalizedRange( range );\n\t\t\theightInRange = true;\n\n\t\t}\n\n\t\t// calculate the tiling level here if not already created\n\t\tif ( info.range === null ) {\n\n\t\t\tinfo.range = range;\n\t\t\toverlay.lockTexture( range, tile );\n\n\t\t} else {\n\n\t\t\trange = info.range;\n\n\t\t}\n\n\t\t// if the image projection is outside the 0, 1 uvw range or there are no textures to draw in\n\t\t// the tiled image set the don't allocate a texture for it.\n\t\tlet target = null;\n\t\tif ( heightInRange && overlay.hasContent( range, tile ) ) {\n\n\t\t\ttarget = await processQueue\n\t\t\t\t.add( { tile, overlay }, async () => {\n\n\t\t\t\t\t// check if the overlay has been disposed since starting this function\n\t\t\t\t\tif ( controller.signal.aborted || tileController.signal.aborted ) {\n\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get the texture from the overlay\n\t\t\t\t\tconst regionTarget = await overlay.getTexture( range, tile );\n\n\t\t\t\t\t// check if the overlay has been disposed since starting this function\n\t\t\t\t\tif ( controller.signal.aborted || tileController.signal.aborted ) {\n\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn regionTarget;\n\n\t\t\t\t} )\n\t\t\t\t.catch( err => {\n\n\t\t\t\t\tif ( ! ( err instanceof PriorityQueueItemRemovedError ) ) {\n\n\t\t\t\t\t\tthrow err;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t}\n\n\t\tinfo.target = target;\n\n\t\tmeshes.forEach( ( mesh, i ) => {\n\n\t\t\tconst array = new Float32Array( uvs[ i ] );\n\t\t\tconst attribute = new BufferAttribute( array, 3 );\n\t\t\tinfo.meshInfo.set( mesh, { attribute } );\n\n\t\t} );\n\n\t}\n\n\t_updateLayers( tile ) {\n\n\t\tconst { overlayInfo, overlays, tileControllers } = this;\n\t\tconst tileController = tileControllers.get( tile );\n\n\t\t// by this point all targets should be present and we can force the memory to update\n\t\tthis.tiles.recalculateBytesUsed( tile );\n\n\t\t// if the tile has been disposed before this function is called then exit early\n\t\tif ( ! tileController || tileController.signal.aborted ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// update the uvs and texture overlays for each mesh\n\t\toverlays.forEach( ( overlay, i ) => {\n\n\t\t\tconst { tileInfo } = overlayInfo.get( overlay );\n\t\t\tconst { meshInfo, target } = tileInfo.get( tile );\n\t\t\tmeshInfo.forEach( ( { attribute }, mesh ) => {\n\n\t\t\t\tconst { geometry, material } = mesh;\n\t\t\t\tconst params = this.meshParams.get( mesh );\n\n\t\t\t\t// assign the new uvs\n\t\t\t\tconst key = `layer_uv_${ i }`;\n\t\t\t\tif ( geometry.getAttribute( key ) !== attribute ) {\n\n\t\t\t\t\tgeometry.setAttribute( key, attribute );\n\t\t\t\t\tgeometry.dispose();\n\n\t\t\t\t}\n\n\t\t\t\t// set the uniform array lengths\n\t\t\t\tparams.layerMaps.length = overlays.length;\n\t\t\t\tparams.layerInfo.length = overlays.length;\n\n\t\t\t\t// assign the uniforms\n\t\t\t\tparams.layerMaps.value[ i ] = target !== null ? target : null;\n\t\t\t\tparams.layerInfo.value[ i ] = overlay;\n\n\t\t\t\t// mark per-layer defines\n\t\t\t\tmaterial.defines[ `LAYER_${ i }_EXISTS` ] = Number( target !== null );\n\t\t\t\tmaterial.defines[ `LAYER_${ i }_ALPHA_INVERT` ] = Number( overlay.alphaInvert );\n\t\t\t\tmaterial.defines[ `LAYER_${ i }_ALPHA_MASK` ] = Number( overlay.alphaMask );\n\n\t\t\t\tmaterial.defines.LAYER_COUNT = overlays.length;\n\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\t_markNeedsUpdate() {\n\n\t\tif ( this.needsUpdate === false ) {\n\n\t\t\tthis.needsUpdate = true;\n\t\t\tif ( this.tiles !== null ) {\n\n\t\t\t\tthis.tiles.dispatchEvent( { type: 'needs-update' } );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nclass ImageOverlay {\n\n\tget isPlanarProjection() {\n\n\t\treturn Boolean( this.frame );\n\n\t}\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\topacity = 1,\n\t\t\tcolor = 0xffffff,\n\t\t\tframe = null,\n\t\t\tpreprocessURL = null,\n\t\t\talphaMask = false,\n\t\t\talphaInvert = false,\n\t\t} = options;\n\t\tthis.preprocessURL = preprocessURL;\n\t\tthis.opacity = opacity;\n\t\tthis.color = new Color( color );\n\t\tthis.frame = frame !== null ? frame.clone() : null;\n\t\tthis.alphaMask = alphaMask;\n\t\tthis.alphaInvert = alphaInvert;\n\n\t\tthis._whenReady = null;\n\t\tthis.isReady = false;\n\t\tthis.isInitialized = false;\n\n\t}\n\n\tinit() {\n\n\t\tthis.isInitialized = true;\n\t\tthis._whenReady = this._init().then( () => this.isReady = true );\n\n\t}\n\n\twhenReady() {\n\n\t\treturn this._whenReady;\n\n\t}\n\n\t// overrideable\n\t_init() {}\n\n\tfetch( url, options = {} ) {\n\n\t\tif ( this.preprocessURL ) {\n\n\t\t\turl = this.preprocessURL( url );\n\n\t\t}\n\n\t\treturn fetch( url, options );\n\n\t}\n\n\tgetAttributions( target ) {\n\n\t}\n\n\thasContent( range, tile ) {\n\n\t\treturn false;\n\n\t}\n\n\tasync getTexture( range, tile ) {\n\n\t\treturn null;\n\n\t}\n\n\tasync lockTexture( range, tile ) {\n\n\t\treturn null;\n\n\t}\n\n\treleaseTexture( range, tile ) {\n\n\t}\n\n\tsetResolution( resolution ) {\n\n\t}\n\n\tshouldSplit( range, tile ) {\n\n\t\treturn false;\n\n\t}\n\n}\n\nclass TiledImageOverlay extends ImageOverlay {\n\n\tget tiling() {\n\n\t\treturn this.imageSource.tiling;\n\n\t}\n\n\tget projection() {\n\n\t\treturn this.tiling.projection;\n\n\t}\n\n\tget aspectRatio() {\n\n\t\treturn this.tiling && this.isReady ? this.tiling.aspectRatio : 1;\n\n\t}\n\n\tget fetchOptions() {\n\n\t\treturn this.imageSource.fetchOptions;\n\n\t}\n\n\tset fetchOptions( v ) {\n\n\t\tthis.imageSource.fetchOptions = v;\n\n\t}\n\n\tconstructor( options = {} ) {\n\n\t\tconst { imageSource = null, ...rest } = options;\n\t\tsuper( rest );\n\t\tthis.imageSource = imageSource;\n\t\tthis.regionImageSource = null;\n\n\t}\n\n\t_init() {\n\n\t\treturn this\n\t\t\t._initImageSource()\n\t\t\t.then( () => {\n\n\t\t\t\tthis.imageSource.fetchData = ( ...args ) => this.fetch( ...args );\n\t\t\t\tthis.regionImageSource = new TiledRegionImageSource( this.imageSource );\n\n\t\t\t} );\n\n\t}\n\n\t_initImageSource() {\n\n\t\treturn this.imageSource.init();\n\n\t}\n\n\t// Texture acquisition API implementations\n\tcalculateLevel( range, tile ) {\n\n\t\tif ( this.isPlanarProjection ) {\n\n\t\t\tconst [ minX, minY, maxX, maxY ] = range;\n\t\t\tconst w = maxX - minX;\n\t\t\tconst h = maxY - minY;\n\n\t\t\tlet level = 0;\n\t\t\tconst resolution = this.regionImageSource.resolution;\n\t\t\tconst maxLevel = this.tiling.maxLevel;\n\t\t\tfor ( ; level < maxLevel; level ++ ) {\n\n\t\t\t\t// the number of pixels per image on each axis\n\t\t\t\tconst wProj = resolution / w;\n\t\t\t\tconst hProj = resolution / h;\n\n\t\t\t\tconst { pixelWidth, pixelHeight } = this.tiling.getLevel( level );\n\t\t\t\tif ( pixelWidth >= wProj || pixelHeight >= hProj ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// TODO: should this be one layer higher LoD?\n\t\t\treturn level;\n\n\t\t} else {\n\n\t\t\treturn tile.internal.depthFromRenderedParent - 1;\n\n\t\t}\n\n\t}\n\n\thasContent( range, tile ) {\n\n\t\treturn this.regionImageSource.hasContent( ...range, this.calculateLevel( range, tile ) );\n\n\t}\n\n\tgetTexture( range, tile ) {\n\n\t\treturn this.regionImageSource.get( ...range, this.calculateLevel( range, tile ) );\n\n\t}\n\n\tlockTexture( range, tile ) {\n\n\t\treturn this.regionImageSource.lock( ...range, this.calculateLevel( range, tile ) );\n\n\t}\n\n\treleaseTexture( range, tile ) {\n\n\t\tthis.regionImageSource.release( ...range, this.calculateLevel( range, tile ) );\n\n\t}\n\n\tsetResolution( resolution ) {\n\n\t\tthis.regionImageSource.resolution = resolution;\n\n\t}\n\n\tshouldSplit( range, tile ) {\n\n\t\t// if we haven't reached the max level yet then continue splitting\n\t\treturn this.tiling.maxLevel > this.calculateLevel( range, tile );\n\n\t}\n\n}\n\nexport class XYZTilesOverlay extends TiledImageOverlay {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( options );\n\t\tthis.imageSource = new XYZImageSource( options );\n\n\t}\n\n}\n\nexport class GeoJSONOverlay extends ImageOverlay {\n\n\tget projection() {\n\n\t\treturn this.imageSource.projection;\n\n\t}\n\n\tget aspectRatio() {\n\n\t\treturn 2;\n\n\t}\n\n\tget pointRadius() {\n\n\t\treturn this.imageSource.pointRadius;\n\n\t}\n\n\tset pointRadius( v ) {\n\n\t\tthis.imageSource.pointRadius = v;\n\n\t}\n\n\tget strokeStyle() {\n\n\t\treturn this.imageSource.strokeStyle;\n\n\t}\n\n\tset strokeStyle( v ) {\n\n\t\tthis.imageSource.strokeStyle = v;\n\n\t}\n\n\tget strokeWidth() {\n\n\t\treturn this.imageSource.strokeWidth;\n\n\t}\n\n\tset strokeWidth( v ) {\n\n\t\tthis.imageSource.strokeWidth = v;\n\n\t}\n\n\tget fillStyle() {\n\n\t\treturn this.imageSource.fillStyle;\n\n\t}\n\n\tset fillStyle( v ) {\n\n\t\tthis.imageSource.fillStyle = v;\n\n\t}\n\n\tget geojson() {\n\n\t\treturn this.imageSource.geojson;\n\n\t}\n\n\tset geojson( v ) {\n\n\t\tthis.imageSource.geojson = v;\n\n\t}\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( options );\n\t\tthis.imageSource = new GeoJSONImageSource( options );\n\n\t}\n\n\t_init() {\n\n\t\treturn this.imageSource.init();\n\n\t}\n\n\thasContent( range ) {\n\n\t\treturn this.imageSource.hasContent( ...range );\n\n\t}\n\n\tgetTexture( range ) {\n\n\t\treturn this.imageSource.get( ...range );\n\n\t}\n\n\tlockTexture( range ) {\n\n\t\treturn this.imageSource.lock( ...range );\n\n\t}\n\n\treleaseTexture( range ) {\n\n\t\tthis.imageSource.release( ...range );\n\n\t}\n\n\tsetResolution( resolution ) {\n\n\t\tthis.imageSource.resolution = resolution;\n\n\t}\n\n\tshouldSplit( range, tile ) {\n\n\t\t// geojson can always split\n\t\treturn true;\n\n\t}\n\n\tredraw() {\n\n\t\tthis.imageSource.redraw();\n\n\t}\n\n}\n\nexport class WMSTilesOverlay extends TiledImageOverlay {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( options );\n\t\tthis.imageSource = new WMSImageSource( options );\n\n\t}\n\n}\n\nexport class WMTSTilesOverlay extends TiledImageOverlay {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( options );\n\t\tthis.imageSource = new WMTSImageSource( options );\n\n\t}\n\n}\n\nexport class TMSTilesOverlay extends TiledImageOverlay {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( options );\n\t\tthis.imageSource = new TMSImageSource( options );\n\n\t}\n\n}\n\nexport class CesiumIonOverlay extends TiledImageOverlay {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( options );\n\n\t\tconst { apiToken, autoRefreshToken, assetId } = options;\n\t\tthis.options = options;\n\t\tthis.assetId = assetId;\n\t\tthis.auth = new CesiumIonAuth( { apiToken, autoRefreshToken } );\n\n\t\tthis.auth.authURL = `https://api.cesium.com/v1/assets/${ assetId }/endpoint`;\n\t\tthis._attributions = [];\n\n\t\tthis.externalType = false;\n\n\t}\n\n\t_initImageSource() {\n\n\t\treturn this\n\t\t\t.auth\n\t\t\t.refreshToken()\n\t\t\t.then( async ( json ) => {\n\n\t\t\t\tthis._attributions = json.attributions.map( att => ( {\n\t\t\t\t\tvalue: att.html,\n\t\t\t\t\ttype: 'html',\n\t\t\t\t\tcollapsible: att.collapsible,\n\t\t\t\t} ) );\n\n\t\t\t\tif ( json.type !== 'IMAGERY' ) {\n\n\t\t\t\t\tthrow new Error( 'CesiumIonOverlay: Only IMAGERY is supported as overlay type.' );\n\n\t\t\t\t}\n\n\t\t\t\tthis.externalType = Boolean( json.externalType );\n\n\t\t\t\tswitch ( json.externalType ) {\n\n\t\t\t\t\tcase 'GOOGLE_2D_MAPS': {\n\n\t\t\t\t\t\tconst { url, session, key, tileWidth } = json.options;\n\t\t\t\t\t\tconst xyzUrl = `${ url }/v1/2dtiles/{z}/{x}/{y}?session=${ session }&key=${ key }`;\n\t\t\t\t\t\tthis.imageSource = new XYZImageSource( {\n\t\t\t\t\t\t\t...this.options,\n\t\t\t\t\t\t\turl: xyzUrl,\n\t\t\t\t\t\t\ttileDimension: tileWidth,\n\n\t\t\t\t\t\t\t// Google maps tiles have a fixed depth of 22\n\t\t\t\t\t\t\t// https://developers.google.com/maps/documentation/tile/2d-tiles-overview\n\t\t\t\t\t\t\tlevels: 22,\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcase 'BING': {\n\n\t\t\t\t\t\tconst { url, mapStyle, key } = json.options;\n\t\t\t\t\t\tconst metadataUrl = `${ url }/REST/v1/Imagery/Metadata/${ mapStyle }?incl=ImageryProviders&key=${ key }&uriScheme=https`;\n\t\t\t\t\t\tconst response = await fetch( metadataUrl ).then( res => res.json() );\n\t\t\t\t\t\tconst metadata = response.resourceSets[ 0 ].resources[ 0 ];\n\n\t\t\t\t\t\tthis.imageSource = new QuadKeyImageSource( {\n\t\t\t\t\t\t\t...this.options,\n\t\t\t\t\t\t\turl: metadata.imageUrl,\n\t\t\t\t\t\t\tsubdomains: metadata.imageUrlSubdomains,\n\t\t\t\t\t\t\ttileDimension: metadata.tileWidth,\n\t\t\t\t\t\t\tlevels: metadata.zoomMax,\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthis.imageSource = new TMSImageSource( {\n\t\t\t\t\t\t\t...this.options,\n\t\t\t\t\t\t\turl: json.url,\n\t\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tthis.imageSource.fetchData = ( ...args ) => this.fetch( ...args );\n\t\t\t\treturn this.imageSource.init();\n\n\t\t\t} );\n\n\t}\n\n\tfetch( ...args ) {\n\n\t\t// bypass auth fetch if asset is external type to prevent CORS error due to wrong bearer token\n\t\treturn this.externalType ? super.fetch( ...args ) : this.auth.fetch( ...args );\n\n\t}\n\n\tgetAttributions( target ) {\n\n\t\ttarget.push( ...this._attributions );\n\n\t}\n\n}\n\nexport class GoogleMapsOverlay extends TiledImageOverlay {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( options );\n\n\t\tconst { apiToken, sessionOptions, autoRefreshToken, logoUrl } = options;\n\t\tthis.logoUrl = logoUrl;\n\t\tthis.auth = new GoogleCloudAuth( { apiToken, sessionOptions, autoRefreshToken } );\n\t\tthis.imageSource = new XYZImageSource();\n\t\tthis.imageSource.fetchData = ( ...args ) => this.fetch( ...args );\n\n\t\tthis._logoAttribution = {\n\t\t\tvalue: '',\n\t\t\ttype: 'image',\n\t\t\tcollapsible: false,\n\t\t};\n\n\t}\n\n\t_initImageSource() {\n\n\t\treturn this\n\t\t\t.auth\n\t\t\t.refreshToken()\n\t\t\t.then( json => {\n\n\t\t\t\tthis.imageSource.tileDimension = json.tileWidth;\n\t\t\t\tthis.imageSource.url = 'https://tile.googleapis.com/v1/2dtiles/{z}/{x}/{y}';\n\t\t\t\treturn this.imageSource.init();\n\n\t\t\t} );\n\n\t}\n\n\tfetch( ...args ) {\n\n\t\treturn this.auth.fetch( ...args );\n\n\t}\n\n\tgetAttributions( target ) {\n\n\t\tif ( this.logoUrl ) {\n\n\t\t\tthis._logoAttribution.value = this.logoUrl;\n\t\t\ttarget.push( this._logoAttribution );\n\n\t\t}\n\n\t}\n\n}\n"],"names":["QuadKeyImageSource","XYZImageSource","options","subdomains","rest","x","y","level","quadKey","i","digit","mask","forEachTileInBounds","range","tiling","callback","minLon","minLat","maxLon","maxLat","clampedLevel","minX","minY","maxX","maxY","getGeometryCartographicChannel","geometry","geomToEllipsoidMatrix","ellipsoid","_vec","Vector3","_cart","uv","posAttr","centerLat","centerLon","minHeight","maxHeight","region","getMeshesCartographicRange","meshes","meshToEllipsoidMatrix","projection","uvs","_matrix","Matrix4","mesh","clampedRange","minU","minV","maxU","maxV","l","lon","lat","h","u","v","MathUtils","getGeometryPlanarChannel","meshToFrame","minW","maxW","getMeshesPlanarRange","worldToFrame","heightRange","OVERLAY_PARAMS","wrapOverlaysMaterial","material","previousOnBeforeCompile","params","shader","value","TiledTextureComposer","canvas","texture","span","context","width","height","image","imageWidth","imageHeight","RegionImageSource","DataCache","tokens","TiledRegionImageSource","tiledImageSource","total","signal","imageSource","tileComposer","target","CanvasTexture","SRGBColorSpace","tx","ty","tl","tex","release","promises","filteredPromises","p","_v0","_v1","calculateArcRatioAtPoint","latDelta","GeoJSONImageSource","geojson","url","resolution","pointRadius","strokeStyle","strokeWidth","fillStyle","ProjectionScheme","args","res","boundsDeg","force","featureBounds","feature","bounds","fMinLon","fMinLat","fMaxLon","fMaxLat","features","minLonRad","minLatRad","maxLonRad","maxLatRad","regionBoundsDeg","ctx","featureBoundsDeg","bounds1","bounds2","minX1","minY1","maxX1","maxY1","minX2","minY2","maxX2","maxY2","type","coordinates","expandBoundsByPoint","c","ring","polygon","root","geomTypes","g","tileBoundsDeg","properties","minLonDeg","minLatDeg","maxLonDeg","maxLatDeg","arr","projectPoint","calculateAspectRatio","latRad","lonRad","pxLat","WGS84_ELLIPSOID","px","py","drawRatio","line","rIndex","_center","_sphereCenter","_normal","_box","Box3","SPLIT_TILE_DATA","SPLIT_HASH","ImageOverlayPlugin","overlays","enableTileSplitting","overlay","tiles","processQueue","PriorityQueue","a","b","tileA","tileB","visibleA","visibleB","scene","tile","overlayChanged","info","order","maxJobs","count","overlayInfo","tileControllers","pendingTiles","processedTiles","tileInfo","meshInfo","item","bytesUsed","bytes","MemoryUtils.getTextureByteLength","initialization","buffer","extension","uri","fullDispose","id","o","parents","parent","clone","children","collectChildren","child","centerTarget","box","splitDirections","hashTokens","token","other","ortho0","ortho1","directions","normalized","average","dir","dotProduct","hash","clipper","GeometryClipper","key","splitDirection","i0","i1","i2","barycoord","matrixWorld","Triangle","result","boundingVolume","maxSqRadius","position","sqRadius","controller","index","overlayFetch","initTile","promise","tileController","aspectRatio","heightInRange","regionTarget","err","PriorityQueueItemRemovedError","array","attribute","BufferAttribute","ImageOverlay","opacity","color","frame","preprocessURL","alphaMask","alphaInvert","Color","TiledImageOverlay","w","maxLevel","wProj","hProj","pixelWidth","pixelHeight","XYZTilesOverlay","GeoJSONOverlay","CesiumIonOverlay","apiToken","autoRefreshToken","assetId","CesiumIonAuth","json","att","session","tileWidth","xyzUrl","mapStyle","metadataUrl","metadata","TMSImageSource"],"mappings":"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"}