{"version":3,"file":"TiledImageSource-DLt2EM25.js","sources":["../../../src/three/plugins/images/utils/DataCache.js","../../../src/three/plugins/images/utils/TilingScheme.js","../../../src/three/plugins/images/sources/TiledImageSource.js"],"sourcesContent":["function hash( ...args ) {\n\n\treturn args.join( '_' );\n\n}\n\n// class for retrieving and locking data being requested\n// \"fetchItem\" and \"disposeItem\" should be implemented\nexport class DataCache {\n\n\tconstructor() {\n\n\t\tthis.cache = {};\n\t\tthis.count = 0;\n\t\tthis.cachedBytes = 0;\n\t\tthis.active = 0;\n\n\t}\n\n\t// overridable\n\tfetchItem() {}\n\tdisposeItem() {}\n\tgetMemoryUsage( item ) {\n\n\t\treturn 0;\n\n\t}\n\n\t// sets the data in the cache explicitly without need to load\n\tsetData( ...args ) {\n\n\t\tconst { cache } = this;\n\t\tconst data = args.pop();\n\t\tconst key = hash( ...args );\n\t\tif ( key in cache ) {\n\n\t\t\tthrow new Error( `DataCache: \"${ key }\" is already present.` );\n\n\t\t} else {\n\n\t\t\tthis.cache[ key ] = {\n\t\t\t\tabortController: new AbortController(),\n\t\t\t\tresult: data,\n\t\t\t\tcount: 1,\n\t\t\t\tbytes: this.getMemoryUsage( data ),\n\t\t\t};\n\t\t\tthis.count ++;\n\t\t\tthis.cachedBytes += this.cache[ key ].bytes;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\t// fetches the associated data if it doesn't exist and increments the lock counter\n\tlock( ...args ) {\n\n\t\tconst { cache } = this;\n\t\tconst key = hash( ...args );\n\t\tif ( key in cache ) {\n\n\t\t\tcache[ key ].count ++;\n\n\t\t} else {\n\n\t\t\tconst abortController = new AbortController();\n\t\t\tconst info = {\n\t\t\t\tabortController,\n\t\t\t\tresult: null,\n\t\t\t\tcount: 1,\n\t\t\t\tbytes: 0,\n\t\t\t};\n\n\t\t\tthis.active ++;\n\t\t\tinfo.result = this.fetchItem( args, abortController.signal );\n\t\t\tif ( info.result instanceof Promise ) {\n\n\t\t\t\tinfo.result.then( res => {\n\n\t\t\t\t\tinfo.result = res;\n\t\t\t\t\tinfo.bytes = this.getMemoryUsage( res );\n\t\t\t\t\tthis.cachedBytes += info.bytes;\n\t\t\t\t\treturn res;\n\n\t\t\t\t} ).finally( () => {\n\n\t\t\t\t\tthis.active --;\n\n\t\t\t\t} ).catch( e => {\n\n\t\t\t\t\t// error logging and handling can be handled elsewhere\n\n\t\t\t\t} );\n\n\t\t\t} else {\n\n\t\t\t\tthis.active --;\n\t\t\t\tinfo.bytes = this.getMemoryUsage( info.result );\n\t\t\t\tthis.cachedBytes += info.bytes;\n\n\t\t\t}\n\n\t\t\tthis.cache[ key ] = info;\n\t\t\tthis.count ++;\n\n\t\t}\n\n\t\treturn cache[ key ].result;\n\n\t}\n\n\t// decrements the lock counter for the item and deletes the item if it has reached zero\n\trelease( ...args ) {\n\n\t\tconst key = hash( ...args );\n\t\tthis.releaseViaFullKey( key );\n\n\t}\n\n\t// get the loaded item\n\tget( ...args ) {\n\n\t\tconst { cache } = this;\n\t\tconst key = hash( ...args );\n\t\tif ( key in cache && cache[ key ].count > 0 ) {\n\n\t\t\treturn cache[ key ].result;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\thas( ...args ) {\n\n\t\tconst { cache } = this;\n\t\tconst key = hash( ...args );\n\t\treturn key in cache;\n\n\t}\n\n\t// dispose all items\n\tdispose() {\n\n\t\tconst { cache } = this;\n\t\tfor ( const key in cache ) {\n\n\t\t\tconst { abortController } = cache[ key ];\n\t\t\tabortController.abort();\n\n\t\t\tthis.releaseViaFullKey( key, true );\n\n\t\t}\n\n\t\tthis.cache = {};\n\n\t}\n\n\t// releases an item with an optional force flag\n\treleaseViaFullKey( key, force = false ) {\n\n\t\tconst { cache } = this;\n\t\tif ( key in cache && cache[ key ].count > 0 ) {\n\n\t\t\t// decrement the lock\n\t\t\tconst info = cache[ key ];\n\t\t\tinfo.count --;\n\n\t\t\t// if the item is no longer being used\n\t\t\tif ( info.count === 0 || force ) {\n\n\t\t\t\tconst disposeCallback = () => {\n\n\t\t\t\t\t// if the object isn't in the cache anymore then exit early because it's been disposed elsewhere\n\t\t\t\t\tif ( cache[ key ] !== info ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// abort any loads\n\t\t\t\t\tconst { result, abortController } = info;\n\t\t\t\t\tabortController.abort();\n\n\t\t\t\t\t// dispose of the object even if it still is in progress\n\t\t\t\t\tif ( result instanceof Promise ) {\n\n\t\t\t\t\t\t// \"disposeItem\" will throw potentially if fetch, etc are cancelled using the abort signal\n\t\t\t\t\t\tresult.then( item => {\n\n\t\t\t\t\t\t\tthis.disposeItem( item );\n\t\t\t\t\t\t\tthis.count --;\n\t\t\t\t\t\t\tthis.cachedBytes -= info.bytes;\n\n\t\t\t\t\t\t} ).catch( () => {} );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.disposeItem( result );\n\t\t\t\t\t\tthis.count --;\n\t\t\t\t\t\tthis.cachedBytes -= info.bytes;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete cache[ key ];\n\n\t\t\t\t};\n\n\t\t\t\tif ( force ) {\n\n\t\t\t\t\t// if we're forcing disposal then dispose immediately\n\t\t\t\t\tdisposeCallback();\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// queue for disposal in a frame here - we need to make sure we're not disposing of something twice\n\t\t\t\t\t// this can get called multiple times in a row to increment then decrement again.\n\t\t\t\t\tqueueMicrotask( () => {\n\n\t\t\t\t\t\tif ( info.count === 0 ) {\n\n\t\t\t\t\t\t\tdisposeCallback();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tthrow new Error( 'DataCache: Attempting to release key that does not exist' );\n\n\t}\n\n}\n","import { MathUtils } from 'three';\n\nfunction doBoundsIntersect( a, b ) {\n\n\tconst [ aMinX, aMinY, aMaxX, aMaxY ] = a;\n\tconst [ bMinX, bMinY, bMaxX, bMaxY ] = b;\n\n\treturn ! ( aMinX >= bMaxX || aMaxX <= bMinX || aMinY >= bMaxY || aMaxY <= bMinY );\n\n}\n\n// Class for storing and querying a tiling scheme including a bounds, origin, and negative tile indices.\n// Assumes that tiles are split into four child tiles at each level.\n\n// Projection Bounds: The full extent of content representable by the projection.\n// Content Bounds: The range within the content bounds contains relevant, loadable, and renderable data.\n// Tile Bounds: The per-layer extent covered by the tiles to be loaded. This range may be larger than\n// both the projection and content bounds.\nexport class TilingScheme {\n\n\tget levelCount() {\n\n\t\treturn this._levels.length;\n\n\t}\n\n\tget maxLevel() {\n\n\t\treturn this.levelCount - 1;\n\n\t}\n\n\tget minLevel() {\n\n\t\tconst levels = this._levels;\n\t\tfor ( let i = 0; i < levels.length; i ++ ) {\n\n\t\t\tif ( levels[ i ] !== null ) {\n\n\t\t\t\treturn i;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn - 1;\n\n\t}\n\n\t// prioritize user-set bounds over projection bounds if present\n\tget contentBounds() {\n\n\t\treturn this._contentBounds ?? this.projection?.getBounds() ?? [ 0, 0, 1, 1 ];\n\n\t}\n\n\tget aspectRatio() {\n\n\t\tconst { pixelWidth, pixelHeight } = this.getLevel( this.maxLevel );\n\t\treturn pixelWidth / pixelHeight;\n\n\t}\n\n\tconstructor() {\n\n\t\tthis.flipY = false;\n\t\tthis.pixelOverlap = 0;\n\n\t\t// The origin and bounds\n\t\tthis._contentBounds = null;\n\t\tthis.projection = null;\n\n\t\tthis._levels = [];\n\n\t}\n\n\t// build the zoom levels\n\tsetLevel( level, options = {} ) {\n\n\t\tconst levels = this._levels;\n\t\twhile ( levels.length < level ) {\n\n\t\t\tlevels.push( null );\n\n\t\t}\n\n\t\tconst {\n\t\t\ttilePixelWidth = 256,\n\t\t\ttilePixelHeight = 256,\n\t\t\ttileCountX = 2 ** level,\n\t\t\ttileCountY = 2 ** level,\n\t\t\ttileBounds = null,\n\t\t} = options;\n\n\t\tconst {\n\t\t\tpixelWidth = tilePixelWidth * tileCountX,\n\t\t\tpixelHeight = tilePixelHeight * tileCountY,\n\t\t} = options;\n\n\t\tlevels[ level ] = {\n\t\t\t// The pixel resolution of each tile.\n\t\t\ttilePixelWidth,\n\t\t\ttilePixelHeight,\n\n\t\t\t// The total pixel resolution of the final image at this level. These numbers\n\t\t\t// may not be a round multiple of the tile width.\n\t\t\tpixelWidth,\n\t\t\tpixelHeight,\n\n\t\t\t// Or the total number of tiles that can be loaded at this level.\n\t\t\ttileCountX,\n\t\t\ttileCountY,\n\n\t\t\t// The bounds covered by the extent of the tiles at this loaded. The actual content covered by the overall tile set\n\t\t\t// may be a subset of this range (eg there may be unused space).\n\t\t\ttileBounds,\n\t\t};\n\n\t}\n\n\tgenerateLevels( levels, rootTileX, rootTileY, options = {} ) {\n\n\t\tconst {\n\t\t\tminLevel = 0,\n\t\t\ttilePixelWidth = 256,\n\t\t\ttilePixelHeight = 256,\n\t\t} = options;\n\n\t\tconst maxLevel = levels - 1;\n\t\tconst {\n\t\t\tpixelWidth = tilePixelWidth * rootTileX * ( 2 ** maxLevel ),\n\t\t\tpixelHeight = tilePixelHeight * rootTileY * ( 2 ** maxLevel ),\n\t\t} = options;\n\t\tfor ( let level = minLevel; level < levels; level ++ ) {\n\n\t\t\tconst invLevel = levels - level - 1;\n\t\t\tconst levelPixelWidth = Math.ceil( pixelWidth * ( 2 ** - invLevel ) );\n\t\t\tconst levelPixelHeight = Math.ceil( pixelHeight * ( 2 ** - invLevel ) );\n\t\t\tconst tileCountX = Math.ceil( levelPixelWidth / tilePixelWidth );\n\t\t\tconst tileCountY = Math.ceil( levelPixelHeight / tilePixelHeight );\n\n\t\t\tthis.setLevel( level, {\n\t\t\t\ttilePixelWidth,\n\t\t\t\ttilePixelHeight,\n\t\t\t\tpixelWidth: levelPixelWidth,\n\t\t\t\tpixelHeight: levelPixelHeight,\n\t\t\t\ttileCountX,\n\t\t\t\ttileCountY,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\tgetLevel( level ) {\n\n\t\treturn this._levels[ level ];\n\n\t}\n\n\t// bounds representing the contentful region of the image\n\tsetContentBounds( minX, minY, maxX, maxY ) {\n\n\t\tthis._contentBounds = [ minX, minY, maxX, maxY ];\n\n\t}\n\n\tsetProjection( projection ) {\n\n\t\tthis.projection = projection;\n\n\t}\n\n\t// query functions\n\tgetTileAtPoint( bx, by, level, normalized = false ) {\n\n\t\tconst { flipY } = this;\n\t\tconst { tileCountX, tileCountY, tileBounds } = this.getLevel( level );\n\t\tconst xStride = 1 / tileCountX;\n\t\tconst yStride = 1 / tileCountY;\n\n\t\tif ( ! normalized ) {\n\n\t\t\t[ bx, by ] = this.toNormalizedPoint( bx, by );\n\n\t\t}\n\n\t\tif ( tileBounds ) {\n\n\t\t\tconst normalizedBounds = this.toNormalizedRange( tileBounds );\n\t\t\tbx = MathUtils.mapLinear( bx, normalizedBounds[ 0 ], normalizedBounds[ 2 ], 0, 1 );\n\t\t\tby = MathUtils.mapLinear( by, normalizedBounds[ 1 ], normalizedBounds[ 3 ], 0, 1 );\n\n\t\t}\n\n\t\tconst tx = Math.floor( bx / xStride );\n\t\tlet ty = Math.floor( by / yStride );\n\n\t\tif ( flipY ) {\n\n\t\t\tty = tileCountY - 1 - ty;\n\n\t\t}\n\n\t\treturn [ tx, ty ];\n\n\t}\n\n\tgetTilesInRange( minX, minY, maxX, maxY, level, normalized = false ) {\n\n\t\t// check if the range is outside the content bounds\n\t\tconst range = [ minX, minY, maxX, maxY ];\n\t\tconst contentBounds = this.getContentBounds( normalized );\n\t\tlet tileBounds = this.getLevel( level ).tileBounds;\n\t\tif ( ! doBoundsIntersect( range, contentBounds ) ) {\n\n\t\t\treturn [ 0, 0, - 1, - 1 ];\n\n\t\t}\n\n\t\t// check if the range is outside the tile bounds\n\t\tif ( tileBounds ) {\n\n\t\t\tif ( normalized ) {\n\n\t\t\t\ttileBounds = this.toNormalizedRange( tileBounds );\n\n\t\t\t}\n\n\t\t\tif ( ! doBoundsIntersect( range, contentBounds ) ) {\n\n\t\t\t\treturn [ 0, 0, - 1, - 1 ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst [ clampedMinX, clampedMinY, clampedMaxX, clampedMaxY ] = this.clampToContentBounds( range, normalized );\n\t\tconst minTile = this.getTileAtPoint( clampedMinX, clampedMinY, level, normalized );\n\t\tconst maxTile = this.getTileAtPoint( clampedMaxX, clampedMaxY, level, normalized );\n\n\t\tif ( this.flipY ) {\n\n\t\t\t[ minTile[ 1 ], maxTile[ 1 ] ] = [ maxTile[ 1 ], minTile[ 1 ] ];\n\n\t\t}\n\n\t\tconst { tileCountX, tileCountY } = this.getLevel( level );\n\t\tconst [ minTileX, minTileY ] = minTile;\n\t\tconst [ maxTileX, maxTileY ] = maxTile;\n\n\t\tif ( maxTileX < 0 || maxTileY < 0 || minTileX >= tileCountX || minTileY >= tileCountY ) {\n\n\t\t\treturn [ 0, 0, - 1, - 1 ];\n\n\t\t}\n\n\t\treturn [\n\t\t\tMathUtils.clamp( minTileX, 0, tileCountX - 1 ),\n\t\t\tMathUtils.clamp( minTileY, 0, tileCountY - 1 ),\n\t\t\tMathUtils.clamp( maxTileX, 0, tileCountX - 1 ),\n\t\t\tMathUtils.clamp( maxTileY, 0, tileCountY - 1 ),\n\t\t];\n\n\t}\n\n\tgetTileExists( x, y, level ) {\n\n\t\tconst [ rminx, rminy, rmaxx, rmaxy ] = this.contentBounds;\n\t\tconst [ tminx, tminy, tmaxx, tmaxy ] = this.getTileBounds( x, y, level );\n\t\tconst isDegenerate = tminx >= tmaxx || tminy >= tmaxy;\n\n\t\t// TODO: is supporting \"just touch\" correct?\n\t\treturn ! isDegenerate && tminx <= rmaxx && tminy <= rmaxy && tmaxx >= rminx && tmaxy >= rminy;\n\n\t}\n\n\tgetContentBounds( normalized = false ) {\n\n\t\tconst { projection } = this;\n\t\tconst bounds = [ ...this.contentBounds ];\n\t\tif ( projection && normalized ) {\n\n\t\t\tbounds[ 0 ] = projection.convertLongitudeToProjection( bounds[ 0 ] );\n\t\t\tbounds[ 1 ] = projection.convertLatitudeToProjection( bounds[ 1 ] );\n\t\t\tbounds[ 2 ] = projection.convertLongitudeToProjection( bounds[ 2 ] );\n\t\t\tbounds[ 3 ] = projection.convertLatitudeToProjection( bounds[ 3 ] );\n\n\t\t}\n\n\t\treturn bounds;\n\n\t}\n\n\t// returns the UV range associated with the content in the given tile\n\tgetTileContentUVBounds( x, y, level ) {\n\n\t\tconst [ minU, minV, maxU, maxV ] = this.getTileBounds( x, y, level, true, true );\n\t\tconst [ fullMinU, fullMinV, fullMaxU, fullMaxV ] = this.getTileBounds( x, y, level, true, false );\n\t\treturn [\n\t\t\tMathUtils.mapLinear( minU, fullMinU, fullMaxU, 0, 1 ),\n\t\t\tMathUtils.mapLinear( minV, fullMinV, fullMaxV, 0, 1 ),\n\t\t\tMathUtils.mapLinear( maxU, fullMinU, fullMaxU, 0, 1 ),\n\t\t\tMathUtils.mapLinear( maxV, fullMinV, fullMaxV, 0, 1 ),\n\t\t];\n\n\t}\n\n\tgetTileBounds( x, y, level, normalized = false, clampToProjection = true ) {\n\n\t\tconst { flipY, pixelOverlap, projection } = this;\n\t\tconst { tilePixelWidth, tilePixelHeight, pixelWidth, pixelHeight, tileBounds } = this.getLevel( level );\n\n\t\tlet tileLeft = tilePixelWidth * x - pixelOverlap;\n\t\tlet tileTop = tilePixelHeight * y - pixelOverlap;\n\t\tlet tileRight = tileLeft + tilePixelWidth + pixelOverlap * 2;\n\t\tlet tileBottom = tileTop + tilePixelHeight + pixelOverlap * 2;\n\n\t\t// clamp\n\t\ttileLeft = Math.max( tileLeft, 0 );\n\t\ttileTop = Math.max( tileTop, 0 );\n\t\ttileRight = Math.min( tileRight, pixelWidth );\n\t\ttileBottom = Math.min( tileBottom, pixelHeight );\n\n\t\t// normalized\n\t\ttileLeft = tileLeft / pixelWidth;\n\t\ttileRight = tileRight / pixelWidth;\n\t\ttileTop = tileTop / pixelHeight;\n\t\ttileBottom = tileBottom / pixelHeight;\n\n\t\t// invert y\n\t\tif ( flipY ) {\n\n\t\t\tconst extents = ( tileBottom - tileTop ) / 2;\n\t\t\tconst centerY = ( tileTop + tileBottom ) / 2;\n\t\t\tconst invCenterY = 1.0 - centerY;\n\n\t\t\ttileTop = invCenterY - extents;\n\t\t\ttileBottom = invCenterY + extents;\n\n\t\t}\n\n\t\tlet bounds = [ tileLeft, tileTop, tileRight, tileBottom ];\n\t\tif ( tileBounds ) {\n\n\t\t\tconst normBounds = this.toNormalizedRange( tileBounds );\n\t\t\tbounds[ 0 ] = MathUtils.mapLinear( bounds[ 0 ], 0, 1, normBounds[ 0 ], normBounds[ 2 ] );\n\t\t\tbounds[ 2 ] = MathUtils.mapLinear( bounds[ 2 ], 0, 1, normBounds[ 0 ], normBounds[ 2 ] );\n\t\t\tbounds[ 1 ] = MathUtils.mapLinear( bounds[ 1 ], 0, 1, normBounds[ 1 ], normBounds[ 3 ] );\n\t\t\tbounds[ 3 ] = MathUtils.mapLinear( bounds[ 3 ], 0, 1, normBounds[ 1 ], normBounds[ 3 ] );\n\n\t\t}\n\n\t\tif ( clampToProjection ) {\n\n\t\t\tbounds = this.clampToProjectionBounds( bounds, true );\n\n\t\t}\n\n\t\tif ( projection && ! normalized ) {\n\n\t\t\tbounds[ 0 ] = projection.convertProjectionToLongitude( bounds[ 0 ] );\n\t\t\tbounds[ 1 ] = projection.convertProjectionToLatitude( bounds[ 1 ] );\n\t\t\tbounds[ 2 ] = projection.convertProjectionToLongitude( bounds[ 2 ] );\n\t\t\tbounds[ 3 ] = projection.convertProjectionToLatitude( bounds[ 3 ] );\n\n\t\t}\n\n\t\treturn bounds;\n\n\t}\n\n\ttoNormalizedPoint( x, y ) {\n\n\t\tconst { projection } = this;\n\t\tconst result = [ x, y ];\n\t\tif ( this.projection ) {\n\n\t\t\tresult[ 0 ] = projection.convertLongitudeToProjection( result[ 0 ] );\n\t\t\tresult[ 1 ] = projection.convertLatitudeToProjection( result[ 1 ] );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\ttoNormalizedRange( range ) {\n\n\t\treturn [\n\t\t\t...this.toNormalizedPoint( range[ 0 ], range[ 1 ] ),\n\t\t\t...this.toNormalizedPoint( range[ 2 ], range[ 3 ] ),\n\t\t];\n\n\t}\n\n\ttoCartographicPoint( x, y ) {\n\n\t\tconst { projection } = this;\n\t\tconst result = [ x, y ];\n\t\tif ( this.projection ) {\n\n\t\t\tresult[ 0 ] = projection.convertProjectionToLongitude( result[ 0 ] );\n\t\t\tresult[ 1 ] = projection.convertProjectionToLatitude( result[ 1 ] );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'TilingScheme: Projection not available.' );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\ttoCartographicRange( range ) {\n\n\t\treturn [\n\t\t\t...this.toCartographicPoint( range[ 0 ], range[ 1 ] ),\n\t\t\t...this.toCartographicPoint( range[ 2 ], range[ 3 ] ),\n\t\t];\n\n\t}\n\n\tclampToContentBounds( range, normalized = false ) {\n\n\t\tconst result = [ ...range ];\n\t\tconst [ minX, minY, maxX, maxY ] = this.getContentBounds( normalized );\n\t\tresult[ 0 ] = MathUtils.clamp( result[ 0 ], minX, maxX );\n\t\tresult[ 1 ] = MathUtils.clamp( result[ 1 ], minY, maxY );\n\t\tresult[ 2 ] = MathUtils.clamp( result[ 2 ], minX, maxX );\n\t\tresult[ 3 ] = MathUtils.clamp( result[ 3 ], minY, maxY );\n\n\t\treturn result;\n\n\t}\n\n\tclampToProjectionBounds( range, normalized = false ) {\n\n\t\tconst result = [ ...range ];\n\t\tconst { projection } = this;\n\t\tlet clampBounds;\n\n\t\tif ( normalized || ! projection ) {\n\n\t\t\tclampBounds = [ 0, 0, 1, 1 ];\n\n\t\t} else {\n\n\t\t\tclampBounds = projection.getBounds();\n\n\t\t}\n\n\t\tconst [ minX, minY, maxX, maxY ] = clampBounds;\n\t\tresult[ 0 ] = MathUtils.clamp( result[ 0 ], minX, maxX );\n\t\tresult[ 1 ] = MathUtils.clamp( result[ 1 ], minY, maxY );\n\t\tresult[ 2 ] = MathUtils.clamp( result[ 2 ], minX, maxX );\n\t\tresult[ 3 ] = MathUtils.clamp( result[ 3 ], minY, maxY );\n\n\t\treturn result;\n\n\t}\n\n}\n\n","import { DataCache } from '../utils/DataCache.js';\nimport { TilingScheme } from '../utils/TilingScheme.js';\nimport { SRGBColorSpace, Texture, TextureUtils } from 'three';\n\n// TODO: support queries for detail at level - ie projected pixel size for geometric error mapping\n// Goes here or in \"TilingScheme\"?\nexport class TiledImageSource extends DataCache {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis.tiling = new TilingScheme();\n\t\tthis.fetchOptions = {};\n\t\tthis.fetchData = ( ...args ) => fetch( ...args );\n\n\t}\n\n\t// async function for initializing the tiled image set\n\tinit() {}\n\n\t// helper for processing the buffer into a texture\n\tasync processBufferToTexture( buffer ) {\n\n\t\tconst blob = new Blob( [ buffer ] );\n\t\tconst imageBitmap = await createImageBitmap( blob, {\n\t\t\tpremultiplyAlpha: 'none',\n\t\t\tcolorSpaceConversion: 'none',\n\t\t\timageOrientation: 'flipY',\n\t\t} );\n\t\tconst texture = new Texture( imageBitmap );\n\t\ttexture.generateMipmaps = false;\n\t\ttexture.colorSpace = SRGBColorSpace;\n\t\ttexture.needsUpdate = true;\n\n\t\treturn texture;\n\n\t}\n\n\tgetMemoryUsage( tex ) {\n\n\t\tconst { format, type, image, generateMipmaps } = tex;\n\t\tconst { width, height } = image;\n\t\tconst bytes = TextureUtils.getByteLength( width, height, format, type );\n\t\treturn generateMipmaps ? bytes * 4 / 3 : bytes;\n\n\t}\n\n\t// fetch the item with the given key fields\n\tfetchItem( tokens, signal ) {\n\n\t\tconst fetchOptions = {\n\t\t\t...this.fetchOptions,\n\t\t\tsignal,\n\t\t};\n\t\tconst url = this.getUrl( ...tokens );\n\t\treturn this\n\t\t\t.fetchData( url, fetchOptions )\n\t\t\t.then( res => res.arrayBuffer() )\n\t\t\t.then( buffer => this.processBufferToTexture( buffer ) );\n\n\t}\n\n\t// dispose of the item that was fetched\n\tdisposeItem( texture ) {\n\n\t\ttexture.dispose();\n\t\tif ( texture.image instanceof ImageBitmap ) {\n\n\t\t\ttexture.image.close();\n\n\t\t}\n\n\t}\n\n\tgetUrl( ...args ) {\n\n\t}\n\n}\n"],"names":["hash","args","DataCache","item","cache","data","key","abortController","info","res","e","force","disposeCallback","result","doBoundsIntersect","a","b","aMinX","aMinY","aMaxX","aMaxY","bMinX","bMinY","bMaxX","bMaxY","TilingScheme","levels","_a","pixelWidth","pixelHeight","level","options","tilePixelWidth","tilePixelHeight","tileCountX","tileCountY","tileBounds","rootTileX","rootTileY","minLevel","maxLevel","invLevel","levelPixelWidth","levelPixelHeight","minX","minY","maxX","maxY","projection","bx","by","normalized","flipY","xStride","yStride","normalizedBounds","MathUtils","tx","ty","range","contentBounds","clampedMinX","clampedMinY","clampedMaxX","clampedMaxY","minTile","maxTile","minTileX","minTileY","maxTileX","maxTileY","x","y","rminx","rminy","rmaxx","rmaxy","tminx","tminy","tmaxx","tmaxy","bounds","minU","minV","maxU","maxV","fullMinU","fullMinV","fullMaxU","fullMaxV","clampToProjection","pixelOverlap","tileLeft","tileTop","tileRight","tileBottom","extents","invCenterY","normBounds","clampBounds","TiledImageSource","buffer","blob","imageBitmap","texture","Texture","SRGBColorSpace","tex","format","type","image","generateMipmaps","width","height","bytes","TextureUtils","tokens","signal","fetchOptions","url"],"mappings":"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"}