{"version":3,"file":"TilesRenderer-UmkQDoLb.js","sources":["../../../src/core/renderer/utilities/urlExtension.js","../../../src/core/renderer/utilities/LRUCache.js","../../../src/core/renderer/utilities/PriorityQueue.js","../../../src/core/renderer/tiles/traverseFunctions.js","../../../src/core/renderer/utilities/throttle.js","../../../src/core/renderer/utilities/TraversalUtils.js","../../../src/core/renderer/tiles/TilesRendererBase.js","../../../src/three/renderer/tiles/TilesGroup.js","../../../src/three/renderer/tiles/raycastTraverse.js","../../../src/three/renderer/math/OBB.js","../../../src/three/renderer/math/TileBoundingVolume.js","../../../src/three/renderer/math/ExtendedFrustum.js","../../../src/three/renderer/utils/MemoryUtils.js","../../../src/three/renderer/tiles/TilesRenderer.js"],"sourcesContent":["/**\n * Returns the file extension of the path component of a URL\n * @param {string} url\n * @returns {string} null if no extension found\n */\nexport function getUrlExtension( url ) {\n\n\tif ( ! url ) {\n\n\t\treturn null;\n\n\t}\n\n\t// Find the last occurrence of '?' and '#' to handle query params and fragments\n\tlet endIndex = url.length;\n\tconst queryIndex = url.indexOf( '?' );\n\tconst fragmentIndex = url.indexOf( '#' );\n\tif ( queryIndex !== - 1 ) {\n\n\t\tendIndex = Math.min( endIndex, queryIndex );\n\n\t}\n\n\tif ( fragmentIndex !== - 1 ) {\n\n\t\tendIndex = Math.min( endIndex, fragmentIndex );\n\n\t}\n\n\t// Check if the string is just a hostname or whether the path does not end in an extension\n\tconst lastPeriodIndex = url.lastIndexOf( '.', endIndex );\n\tconst lastSlashIndex = url.lastIndexOf( '/', endIndex );\n\tconst protocolIndex = url.indexOf( '://' );\n\tconst isHostOnly = protocolIndex !== - 1 && protocolIndex + 2 === lastSlashIndex;\n\tif ( isHostOnly || lastPeriodIndex === - 1 || lastPeriodIndex < lastSlashIndex ) {\n\n\t\treturn null;\n\n\t}\n\n\treturn url.substring( lastPeriodIndex + 1, endIndex ) || null;\n\n}\n","const GIGABYTE_BYTES = 2 ** 30;\n\nclass LRUCache {\n\n\tget unloadPriorityCallback() {\n\n\t\treturn this._unloadPriorityCallback;\n\n\t}\n\n\tset unloadPriorityCallback( cb ) {\n\n\t\tif ( cb.length === 1 ) {\n\n\t\t\tconsole.warn( 'LRUCache: \"unloadPriorityCallback\" function has been changed to take two arguments.' );\n\t\t\tthis._unloadPriorityCallback = ( a, b ) => {\n\n\t\t\t\tconst valA = cb( a );\n\t\t\t\tconst valB = cb( b );\n\n\t\t\t\tif ( valA < valB ) return - 1;\n\t\t\t\tif ( valA > valB ) return 1;\n\t\t\t\treturn 0;\n\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tthis._unloadPriorityCallback = cb;\n\n\t\t}\n\n\t}\n\n\tconstructor() {\n\n\t\t// options\n\t\tthis.minSize = 6000;\n\t\tthis.maxSize = 8000;\n\t\tthis.minBytesSize = 0.3 * GIGABYTE_BYTES;\n\t\tthis.maxBytesSize = 0.4 * GIGABYTE_BYTES;\n\t\tthis.unloadPercent = 0.05;\n\t\tthis.autoMarkUnused = true;\n\n\t\t// \"itemSet\" doubles as both the list of the full set of items currently\n\t\t// stored in the cache (keys) as well as a map to the time the item was last\n\t\t// used so it can be sorted appropriately.\n\t\tthis.itemSet = new Map();\n\t\tthis.itemList = [];\n\t\tthis.usedSet = new Set();\n\t\tthis.callbacks = new Map();\n\t\tthis.unloadingHandle = - 1;\n\t\tthis.cachedBytes = 0;\n\t\tthis.bytesMap = new Map();\n\t\tthis.loadedSet = new Set();\n\n\t\tthis._unloadPriorityCallback = null;\n\n\t\tconst itemSet = this.itemSet;\n\t\tthis.defaultPriorityCallback = item => itemSet.get( item );\n\n\t}\n\n\t// Returns whether or not the cache has reached the maximum size\n\tisFull() {\n\n\t\treturn this.itemSet.size >= this.maxSize || this.cachedBytes >= this.maxBytesSize;\n\n\t}\n\n\tgetMemoryUsage( item ) {\n\n\t\treturn this.bytesMap.get( item ) || 0;\n\n\t}\n\n\tsetMemoryUsage( item, bytes ) {\n\n\t\tconst { bytesMap, itemSet } = this;\n\t\tif ( ! itemSet.has( item ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.cachedBytes -= bytesMap.get( item ) || 0;\n\t\tbytesMap.set( item, bytes );\n\t\tthis.cachedBytes += bytes;\n\n\t}\n\n\tadd( item, removeCb ) {\n\n\t\tconst itemSet = this.itemSet;\n\t\tif ( itemSet.has( item ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( this.isFull() ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst usedSet = this.usedSet;\n\t\tconst itemList = this.itemList;\n\t\tconst callbacks = this.callbacks;\n\t\titemList.push( item );\n\t\tusedSet.add( item );\n\t\titemSet.set( item, Date.now() );\n\t\tcallbacks.set( item, removeCb );\n\n\t\treturn true;\n\n\t}\n\n\thas( item ) {\n\n\t\treturn this.itemSet.has( item );\n\n\t}\n\n\tremove( item ) {\n\n\t\tconst usedSet = this.usedSet;\n\t\tconst itemSet = this.itemSet;\n\t\tconst itemList = this.itemList;\n\t\tconst bytesMap = this.bytesMap;\n\t\tconst callbacks = this.callbacks;\n\t\tconst loadedSet = this.loadedSet;\n\n\t\tif ( itemSet.has( item ) ) {\n\n\t\t\tthis.cachedBytes -= bytesMap.get( item ) || 0;\n\t\t\tbytesMap.delete( item );\n\n\t\t\tcallbacks.get( item )( item );\n\n\t\t\tconst index = itemList.indexOf( item );\n\t\t\titemList.splice( index, 1 );\n\t\t\tusedSet.delete( item );\n\t\t\titemSet.delete( item );\n\t\t\tcallbacks.delete( item );\n\t\t\tloadedSet.delete( item );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t// Marks whether tiles in the cache have been completely loaded or not. Tiles that have not been completely\n\t// loaded are subject to being disposed early if the cache is full above its max size limits, even if they\n\t// are marked as used.\n\tsetLoaded( item, value ) {\n\n\t\tconst { itemSet, loadedSet } = this;\n\t\tif ( itemSet.has( item ) ) {\n\n\t\t\tif ( value === true ) {\n\n\t\t\t\tloadedSet.add( item );\n\n\t\t\t} else {\n\n\t\t\t\tloadedSet.delete( item );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tmarkUsed( item ) {\n\n\t\tconst itemSet = this.itemSet;\n\t\tconst usedSet = this.usedSet;\n\t\tif ( itemSet.has( item ) && ! usedSet.has( item ) ) {\n\n\t\t\titemSet.set( item, Date.now() );\n\t\t\tusedSet.add( item );\n\n\t\t}\n\n\t}\n\n\tmarkUnused( item ) {\n\n\t\tthis.usedSet.delete( item );\n\n\t}\n\n\tmarkAllUnused() {\n\n\t\tthis.usedSet.clear();\n\n\t}\n\n\t// TODO: this should be renamed because it's not necessarily unloading all unused content\n\t// Maybe call it \"cleanup\" or \"unloadToMinSize\"\n\tunloadUnusedContent() {\n\n\t\tconst {\n\t\t\tunloadPercent,\n\t\t\tminSize,\n\t\t\tmaxSize,\n\t\t\titemList,\n\t\t\titemSet,\n\t\t\tusedSet,\n\t\t\tloadedSet,\n\t\t\tcallbacks,\n\t\t\tbytesMap,\n\t\t\tminBytesSize,\n\t\t\tmaxBytesSize,\n\t\t} = this;\n\n\t\tconst unused = itemList.length - usedSet.size;\n\t\tconst unloaded = itemList.length - loadedSet.size;\n\t\tconst excessNodes = Math.max( Math.min( itemList.length - minSize, unused ), 0 );\n\t\tconst excessBytes = this.cachedBytes - minBytesSize;\n\t\tconst unloadPriorityCallback = this.unloadPriorityCallback || this.defaultPriorityCallback;\n\t\tlet needsRerun = false;\n\n\t\tconst hasNodesToUnload = excessNodes > 0 && unused > 0 || unloaded && itemList.length > maxSize;\n\t\tconst hasBytesToUnload = unused && this.cachedBytes > minBytesSize || unloaded && this.cachedBytes > maxBytesSize;\n\t\tif ( hasBytesToUnload || hasNodesToUnload ) {\n\n\t\t\t// used items should be at the end of the array, \"unloaded\" items in the middle of the array\n\t\t\titemList.sort( ( a, b ) => {\n\n\t\t\t\tconst usedA = usedSet.has( a );\n\t\t\t\tconst usedB = usedSet.has( b );\n\t\t\t\tif ( usedA === usedB ) {\n\n\t\t\t\t\tconst loadedA = loadedSet.has( a );\n\t\t\t\t\tconst loadedB = loadedSet.has( b );\n\t\t\t\t\tif ( loadedA === loadedB ) {\n\n\t\t\t\t\t\t// Use the sort function otherwise\n\t\t\t\t\t\t// higher priority should be further to the left\n\t\t\t\t\t\treturn - unloadPriorityCallback( a, b );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn loadedA ? 1 : - 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If one is used and the other is not move the used one towards the end of the array\n\t\t\t\t\treturn usedA ? 1 : - 1;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\t// address corner cases where the minSize might be zero or smaller than maxSize - minSize,\n\t\t\t// which would result in a very small or no items being unloaded.\n\t\t\tconst maxUnload = Math.max( minSize * unloadPercent, excessNodes * unloadPercent );\n\t\t\tconst nodesToUnload = Math.ceil( Math.min( maxUnload, unused, excessNodes ) );\n\t\t\tconst maxBytesUnload = Math.max( unloadPercent * excessBytes, unloadPercent * minBytesSize );\n\t\t\tconst bytesToUnload = Math.min( maxBytesUnload, excessBytes );\n\n\t\t\tlet removedNodes = 0;\n\t\t\tlet removedBytes = 0;\n\n\t\t\t// evict up to the max node or bytes size, keeping one more item over the max bytes limit\n\t\t\t// so the \"full\" function behaves correctly.\n\t\t\twhile (\n\t\t\t\tthis.cachedBytes - removedBytes > maxBytesSize ||\n\t\t\t\titemList.length - removedNodes > maxSize\n\t\t\t) {\n\n\t\t\t\tconst item = itemList[ removedNodes ];\n\t\t\t\tconst bytes = bytesMap.get( item ) || 0;\n\t\t\t\tif (\n\t\t\t\t\tusedSet.has( item ) && loadedSet.has( item ) ||\n\t\t\t\t\tthis.cachedBytes - removedBytes - bytes < maxBytesSize &&\n\t\t\t\t\titemList.length - removedNodes <= maxSize\n\t\t\t\t) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tremovedBytes += bytes;\n\t\t\t\tremovedNodes ++;\n\n\t\t\t}\n\n\t\t\t// evict up to the min node or bytes size, keeping one more item over the min bytes limit\n\t\t\t// so we're meeting it\n\t\t\twhile (\n\t\t\t\tremovedBytes < bytesToUnload ||\n\t\t\t\tremovedNodes < nodesToUnload\n\t\t\t) {\n\n\t\t\t\tconst item = itemList[ removedNodes ];\n\t\t\t\tconst bytes = bytesMap.get( item ) || 0;\n\t\t\t\tif (\n\t\t\t\t\tusedSet.has( item ) ||\n\t\t\t\t\tthis.cachedBytes - removedBytes - bytes < minBytesSize &&\n\t\t\t\t\tremovedNodes >= nodesToUnload\n\t\t\t\t) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tremovedBytes += bytes;\n\t\t\t\tremovedNodes ++;\n\n\t\t\t}\n\n\t\t\t// remove the nodes\n\t\t\titemList.splice( 0, removedNodes ).forEach( item => {\n\n\t\t\t\tthis.cachedBytes -= bytesMap.get( item ) || 0;\n\n\t\t\t\tcallbacks.get( item )( item );\n\t\t\t\tbytesMap.delete( item );\n\t\t\t\titemSet.delete( item );\n\t\t\t\tcallbacks.delete( item );\n\t\t\t\tloadedSet.delete( item );\n\t\t\t\tusedSet.delete( item );\n\n\t\t\t} );\n\n\t\t\t// if we didn't remove enough nodes or we still have excess bytes and there are nodes to removed\n\t\t\t// then we want to fire another round of unloading\n\t\t\tneedsRerun = removedNodes < excessNodes || removedBytes < excessBytes && removedNodes < unused;\n\t\t\tneedsRerun = needsRerun && removedNodes > 0;\n\n\t\t}\n\n\t\tif ( needsRerun ) {\n\n\t\t\tthis.unloadingHandle = requestAnimationFrame( () => this.scheduleUnload() );\n\n\t\t}\n\n\t}\n\n\tscheduleUnload() {\n\n\t\tcancelAnimationFrame( this.unloadingHandle );\n\n\t\tif ( ! this.scheduled ) {\n\n\t\t\tthis.scheduled = true;\n\t\t\tqueueMicrotask( () => {\n\n\t\t\t\tthis.scheduled = false;\n\t\t\t\tthis.unloadUnusedContent();\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\nexport { LRUCache };\n","class PriorityQueue {\n\n\t// returns whether tasks are queued or actively running\n\tget running() {\n\n\t\treturn this.items.length !== 0 || this.currJobs !== 0;\n\n\t}\n\n\tconstructor() {\n\n\t\t// options\n\t\tthis.maxJobs = 6;\n\n\t\tthis.items = [];\n\t\tthis.callbacks = new Map();\n\t\tthis.currJobs = 0;\n\t\tthis.scheduled = false;\n\t\tthis.autoUpdate = true;\n\n\t\tthis.priorityCallback = null;\n\n\t\t// Customizable scheduling callback. Default using requestAnimationFrame()\n\t\tthis.schedulingCallback = func => {\n\n\t\t\trequestAnimationFrame( func );\n\n\t\t};\n\n\t\tthis._runjobs = () => {\n\n\t\t\tthis.scheduled = false;\n\t\t\tthis.tryRunJobs();\n\n\t\t};\n\n\t}\n\n\tsort() {\n\n\t\tconst priorityCallback = this.priorityCallback;\n\t\tconst items = this.items;\n\t\tif ( priorityCallback !== null ) {\n\n\t\t\titems.sort( priorityCallback );\n\n\t\t}\n\n\t}\n\n\thas( item ) {\n\n\t\treturn this.callbacks.has( item );\n\n\t}\n\n\tadd( item, callback ) {\n\n\t\tconst data = {\n\t\t\tcallback,\n\t\t\treject: null,\n\t\t\tresolve: null,\n\t\t\tpromise: null,\n\t\t};\n\n\t\tdata.promise = new Promise( ( resolve, reject ) => {\n\n\t\t\tconst items = this.items;\n\t\t\tconst callbacks = this.callbacks;\n\n\t\t\tdata.resolve = resolve;\n\t\t\tdata.reject = reject;\n\n\t\t\titems.unshift( item );\n\t\t\tcallbacks.set( item, data );\n\n\t\t\tif ( this.autoUpdate ) {\n\n\t\t\t\tthis.scheduleJobRun();\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn data.promise;\n\n\t}\n\n\tremove( item ) {\n\n\t\tconst items = this.items;\n\t\tconst callbacks = this.callbacks;\n\n\t\tconst index = items.indexOf( item );\n\t\tif ( index !== - 1 ) {\n\n\t\t\t// reject the promise to ensure there are no dangling promises - add a\n\t\t\t// catch here to handle the case where the promise was never used anywhere\n\t\t\t// else.\n\t\t\tconst info = callbacks.get( item );\n\t\t\tinfo.promise.catch( () => {} );\n\t\t\tinfo.reject( new Error( 'PriorityQueue: Item removed.' ) );\n\n\t\t\titems.splice( index, 1 );\n\t\t\tcallbacks.delete( item );\n\n\t\t}\n\n\t}\n\n\tremoveByFilter( filter ) {\n\n\t\tconst { items } = this;\n\t\tfor ( let i = 0; i < items.length; i ++ ) {\n\n\t\t\tconst item = items[ i ];\n\t\t\tif ( filter( item ) ) {\n\n\t\t\t\tthis.remove( item );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttryRunJobs() {\n\n\t\tthis.sort();\n\n\t\tconst items = this.items;\n\t\tconst callbacks = this.callbacks;\n\t\tconst maxJobs = this.maxJobs;\n\t\tlet iterated = 0;\n\n\t\tconst completedCallback = () => {\n\n\t\t\tthis.currJobs --;\n\n\t\t\tif ( this.autoUpdate ) {\n\n\t\t\t\tthis.scheduleJobRun();\n\n\t\t\t}\n\n\t\t};\n\n\t\twhile ( maxJobs > this.currJobs && items.length > 0 && iterated < maxJobs ) {\n\n\t\t\tthis.currJobs ++;\n\t\t\titerated ++;\n\t\t\tconst item = items.pop();\n\t\t\tconst { callback, resolve, reject } = callbacks.get( item );\n\t\t\tcallbacks.delete( item );\n\n\t\t\tlet result;\n\t\t\ttry {\n\n\t\t\t\tresult = callback( item );\n\n\t\t\t} catch ( err ) {\n\n\t\t\t\treject( err );\n\t\t\t\tcompletedCallback();\n\n\t\t\t}\n\n\t\t\tif ( result instanceof Promise ) {\n\n\t\t\t\tresult\n\t\t\t\t\t.then( resolve )\n\t\t\t\t\t.catch( reject )\n\t\t\t\t\t.finally( completedCallback );\n\n\t\t\t} else {\n\n\t\t\t\tresolve( result );\n\t\t\t\tcompletedCallback();\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tscheduleJobRun() {\n\n\t\tif ( ! this.scheduled ) {\n\n\t\t\tthis.schedulingCallback( this._runjobs );\n\n\t\t\tthis.scheduled = true;\n\n\t\t}\n\n\t}\n\n}\n\nexport { PriorityQueue };\n","import { LOADED, FAILED } from '../constants.js';\n\nconst viewErrorTarget = {\n\tinView: false,\n\terror: Infinity,\n\tdistanceFromCamera: Infinity,\n};\n\n// flag guiding the behavior of the traversal to load the siblings at the root of the\n// tile set or not. The spec seems to indicate \"true\" when using REPLACE define but\n// Cesium's behavior is \"false\".\n// See CesiumGS/3d-tiles#776\nconst LOAD_ROOT_SIBLINGS = true;\n\nfunction isDownloadFinished( value ) {\n\n\treturn value === LOADED || value === FAILED;\n\n}\n\n// Checks whether this tile was last used on the given frame.\nfunction isUsedThisFrame( tile, frameCount ) {\n\n\treturn tile.__lastFrameVisited === frameCount && tile.__used;\n\n}\n\nfunction areChildrenProcessed( tile ) {\n\n\treturn tile.__childrenProcessed === tile.children.length;\n\n}\n\n// Resets the frame frame information for the given tile\nfunction resetFrameState( tile, renderer ) {\n\n\tif ( tile.__lastFrameVisited !== renderer.frameCount ) {\n\n\t\ttile.__lastFrameVisited = renderer.frameCount;\n\t\ttile.__used = false;\n\t\ttile.__inFrustum = false;\n\t\ttile.__isLeaf = false;\n\t\ttile.__visible = false;\n\t\ttile.__active = false;\n\t\ttile.__error = Infinity;\n\t\ttile.__distanceFromCamera = Infinity;\n\t\ttile.__allChildrenLoaded = false;\n\n\t\t// update tile frustum and error state\n\t\trenderer.calculateTileViewError( tile, viewErrorTarget );\n\t\ttile.__inFrustum = viewErrorTarget.inView;\n\t\ttile.__error = viewErrorTarget.error;\n\t\ttile.__distanceFromCamera = viewErrorTarget.distanceFromCamera;\n\n\t}\n\n}\n\n// Recursively mark tiles used down to the next layer, skipping external tile sets\nfunction recursivelyMarkUsed( tile, renderer ) {\n\n\trenderer.ensureChildrenArePreprocessed( tile );\n\n\tresetFrameState( tile, renderer );\n\tmarkUsed( tile, renderer );\n\n\t// don't traverse if the children have not been processed, yet but tile set content\n\t// should be considered to be \"replaced\" by the loaded children so await that here.\n\tif ( tile.__hasUnrenderableContent && areChildrenProcessed( tile ) ) {\n\n\t\tconst children = tile.children;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\trecursivelyMarkUsed( children[ i ], renderer );\n\n\t\t}\n\n\t}\n\n}\n\n// Recursively traverses to the next tiles with unloaded renderable content to load them\nfunction recursivelyLoadNextRenderableTiles( tile, renderer ) {\n\n\trenderer.ensureChildrenArePreprocessed( tile );\n\n\t// exit the recursion if the tile hasn't been used this frame\n\tif ( isUsedThisFrame( tile, renderer.frameCount ) ) {\n\n\t\t// queue this tile to download content\n\t\tif ( tile.__hasContent ) {\n\n\t\t\trenderer.queueTileForDownload( tile );\n\n\t\t}\n\n\t\tif ( areChildrenProcessed( tile ) ) {\n\n\t\t\t// queue any used child tiles\n\t\t\tconst children = tile.children;\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\trecursivelyLoadNextRenderableTiles( children[ i ], renderer );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n// Mark a tile as being used by current view\nfunction markUsed( tile, renderer ) {\n\n\tif ( tile.__used ) {\n\n\t\treturn;\n\n\t}\n\n\ttile.__used = true;\n\trenderer.markTileUsed( tile );\n\trenderer.stats.used ++;\n\n\tif ( tile.__inFrustum === true ) {\n\n\t\trenderer.stats.inFrustum ++;\n\n\t}\n\n}\n\n// Returns whether the tile can be traversed to the next layer of children by checking the tile metrics\nfunction canTraverse( tile, renderer ) {\n\n\t// If we've met the error requirements then don't load further - if an external tile set is encountered,\n\t// though, then continue to refine.\n\tif ( tile.__error <= renderer.errorTarget && ! tile.__hasUnrenderableContent ) {\n\n\t\treturn false;\n\n\t}\n\n\t// Early out if we've reached the maximum allowed depth.\n\tif ( renderer.maxDepth > 0 && tile.__depth + 1 >= renderer.maxDepth ) {\n\n\t\treturn false;\n\n\t}\n\n\t// Early out if the children haven't been processed, yet\n\tif ( ! areChildrenProcessed( tile ) ) {\n\n\t\treturn false;\n\n\t}\n\n\treturn true;\n\n}\n\n// Determine which tiles are used by the renderer given the current camera configuration\nexport function markUsedTiles( tile, renderer ) {\n\n\t// determine frustum set is run first so we can ensure the preprocessing of all the necessary\n\t// child tiles has happened here.\n\trenderer.ensureChildrenArePreprocessed( tile );\n\n\tresetFrameState( tile, renderer );\n\n\tif ( ! tile.__inFrustum ) {\n\n\t\treturn;\n\n\t}\n\n\tif ( ! canTraverse( tile, renderer ) ) {\n\n\t\tmarkUsed( tile, renderer );\n\t\treturn;\n\n\t}\n\n\t// Traverse children and see if any children are in view.\n\tlet anyChildrenUsed = false;\n\tlet anyChildrenInFrustum = false;\n\tconst children = tile.children;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\tconst c = children[ i ];\n\t\tmarkUsedTiles( c, renderer );\n\t\tanyChildrenUsed = anyChildrenUsed || isUsedThisFrame( c, renderer.frameCount );\n\t\tanyChildrenInFrustum = anyChildrenInFrustum || c.__inFrustum;\n\n\t}\n\n\t// Disabled for now because this will cause otherwise unused children to be added to the lru cache\n\t// if none of the children are in the frustum then this tile shouldn't be displayed.\n\t// Otherwise this can cause load oscillation as parents are traversed and loaded and then determined\n\t// to not be used because children aren't visible. See #1165.\n\t// if ( tile.refine === 'REPLACE' && ! anyChildrenInFrustum && children.length !== 0 && ! tile.__hasUnrenderableContent ) {\n\n\t// \t// TODO: we're not checking tiles with unrenderable content here since external tile sets might look like they're in the frustum,\n\t// \t// load the children, then the children indicate that it's not visible, causing it to be unloaded. Then it will be loaded again.\n\t// \t// The impact when including external tile set roots in the check is more significant but can't be used unless we keep external tile\n\t// \t// sets around even when they're not needed. See issue #741.\n\n\t// \t// TODO: what if we mark the tile as not in the frustum but we _do_ mark it as used? Then we can stop frustum traversal and at least\n\t// \t// prevent tiles from rendering unless they're needed.\n\t// \tconsole.log('FAILED')\n\t// \ttile.__inFrustum = false;\n\t// \treturn;\n\n\t// }\n\n\t// wait until after the above condition to mark the traversed tile as used or not\n\tmarkUsed( tile, renderer );\n\n\t// If this is a tile that needs children loaded to refine then recursively load child\n\t// tiles until error is met\n\tif ( anyChildrenUsed && tile.refine === 'REPLACE' && ( tile.__depth !== 0 || LOAD_ROOT_SIBLINGS ) ) {\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tconst c = children[ i ];\n\t\t\trecursivelyMarkUsed( c, renderer );\n\n\t\t}\n\n\t}\n\n}\n\n// Traverse and mark the tiles that are at the leaf nodes of the \"used\" tree.\nexport function markUsedSetLeaves( tile, renderer ) {\n\n\tconst frameCount = renderer.frameCount;\n\tif ( ! isUsedThisFrame( tile, frameCount ) ) {\n\n\t\treturn;\n\n\t}\n\n\t// This tile is a leaf if none of the children had been used.\n\tconst children = tile.children;\n\tlet anyChildrenUsed = false;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\tconst c = children[ i ];\n\t\tanyChildrenUsed = anyChildrenUsed || isUsedThisFrame( c, frameCount );\n\n\t}\n\n\tif ( ! anyChildrenUsed ) {\n\n\t\ttile.__isLeaf = true;\n\n\t} else {\n\n\t\tlet allChildrenLoaded = true;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tconst c = children[ i ];\n\t\t\tmarkUsedSetLeaves( c, renderer );\n\n\t\t\tif ( isUsedThisFrame( c, frameCount ) ) {\n\n\t\t\t\t// consider a child to be loaded if\n\t\t\t\t// - the children's children have been loaded\n\t\t\t\t// - the tile content has loaded\n\t\t\t\t// - the tile is completely empty - ie has no children and no content\n\t\t\t\t// - the child tile set has tried to load but failed\n\t\t\t\tconst childLoaded =\n\t\t\t\t\tc.__allChildrenLoaded ||\n\t\t\t\t\t! c.__hasContent ||\n\t\t\t\t\t( c.__hasRenderableContent && isDownloadFinished( c.__loadingState ) ) ||\n\t\t\t\t\t( c.__hasUnrenderableContent && c.__loadingState === FAILED );\n\t\t\t\tallChildrenLoaded = allChildrenLoaded && childLoaded;\n\n\t\t\t}\n\n\t\t}\n\n\t\ttile.__allChildrenLoaded = allChildrenLoaded;\n\n\t}\n\n}\n\n// TODO: revisit implementation\n// Skip past tiles we consider unrenderable because they are outside the error threshold.\nexport function markVisibleTiles( tile, renderer ) {\n\n\tconst stats = renderer.stats;\n\tif ( ! isUsedThisFrame( tile, renderer.frameCount ) ) {\n\n\t\treturn;\n\n\t}\n\n\t// Request the tile contents or mark it as visible if we've found a leaf.\n\tif ( tile.__isLeaf ) {\n\n\t\tif ( tile.__loadingState === LOADED ) {\n\n\t\t\tif ( tile.__inFrustum ) {\n\n\t\t\t\ttile.__visible = true;\n\t\t\t\tstats.visible ++;\n\n\t\t\t}\n\t\t\ttile.__active = true;\n\t\t\tstats.active ++;\n\n\t\t} else if ( tile.__hasContent ) {\n\n\t\t\trenderer.queueTileForDownload( tile );\n\n\t\t}\n\n\t\treturn;\n\n\t}\n\n\tconst children = tile.children;\n\tconst hasContent = tile.__hasContent;\n\tconst loadedContent = isDownloadFinished( tile.__loadingState ) && hasContent;\n\tconst errorRequirement = ( renderer.errorTarget + 1 ) * renderer.errorThreshold;\n\tconst meetsSSE = tile.__error <= errorRequirement;\n\tconst isAdditiveRefine = tile.refine === 'ADD';\n\n\t// TODO: the \"meetsSSE\" field can be removed when the \"errorThreshold\" field has been removed\n\n\t// Don't wait for all children tiles to load if this tile set has empty tiles at the root in order\n\t// to match Cesium's behavior\n\tconst allChildrenLoaded = tile.__allChildrenLoaded || ( tile.__depth === 0 && ! LOAD_ROOT_SIBLINGS );\n\n\t// If we've met the SSE requirements and we can load content then fire a fetch.\n\tif ( hasContent && ( meetsSSE || isAdditiveRefine ) ) {\n\n\t\trenderer.queueTileForDownload( tile );\n\n\t}\n\n\t// By this time only tiles that meet the screen space error requirements will be traversed. Only mark this\n\t// as visible if it's been loaded and not all children have loaded yet or it's an additive tile, meaning it needs\n\t// to display in addition to the children.\n\n\t// Skip the tile entirely if there's no content to load\n\tif ( meetsSSE && loadedContent && ! allChildrenLoaded || loadedContent && isAdditiveRefine ) {\n\n\t\tif ( tile.__inFrustum ) {\n\n\t\t\ttile.__visible = true;\n\t\t\tstats.visible ++;\n\n\t\t}\n\t\ttile.__active = true;\n\t\tstats.active ++;\n\n\t}\n\n\t// If we're additive then don't stop the traversal here because it doesn't matter whether the children load in\n\t// at the same rate.\n\tif ( ! isAdditiveRefine && meetsSSE && ! allChildrenLoaded ) {\n\n\t\t// load the child content if we've found that we've been loaded so we can move down to the next tile\n\t\t// layer when the data has loaded.\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tconst c = children[ i ];\n\t\t\tif ( isUsedThisFrame( c, renderer.frameCount ) ) {\n\n\t\t\t\trecursivelyLoadNextRenderableTiles( c, renderer );\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tmarkVisibleTiles( children[ i ], renderer );\n\n\t\t}\n\n\t}\n\n}\n\n// Final traverse to toggle tile visibility.\nexport function toggleTiles( tile, renderer ) {\n\n\tconst isUsed = isUsedThisFrame( tile, renderer.frameCount );\n\tif ( isUsed || tile.__usedLastFrame ) {\n\n\t\tlet setActive = false;\n\t\tlet setVisible = false;\n\t\tif ( isUsed ) {\n\n\t\t\t// enable visibility if active due to shadows\n\t\t\tsetActive = tile.__active;\n\t\t\tif ( renderer.displayActiveTiles ) {\n\n\t\t\t\tsetVisible = tile.__active || tile.__visible;\n\n\t\t\t} else {\n\n\t\t\t\tsetVisible = tile.__visible;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// if the tile was used last frame but not this one then there's potential for the tile\n\t\t\t// to not have been visited during the traversal, meaning it hasn't been reset and has\n\t\t\t// stale values. This ensures the values are not stale.\n\t\t\tresetFrameState( tile, renderer );\n\n\t\t}\n\n\t\t// If the active or visible state changed then call the functions.\n\t\tif ( tile.__hasRenderableContent && tile.__loadingState === LOADED ) {\n\n\t\t\tif ( tile.__wasSetActive !== setActive ) {\n\n\t\t\t\trenderer.invokeOnePlugin( plugin => plugin.setTileActive && plugin.setTileActive( tile, setActive ) );\n\n\t\t\t}\n\n\t\t\tif ( tile.__wasSetVisible !== setVisible ) {\n\n\t\t\t\trenderer.invokeOnePlugin( plugin => plugin.setTileVisible && plugin.setTileVisible( tile, setVisible ) );\n\n\t\t\t}\n\n\t\t}\n\t\ttile.__wasSetActive = setActive;\n\t\ttile.__wasSetVisible = setVisible;\n\t\ttile.__usedLastFrame = isUsed;\n\n\t\tconst children = tile.children;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tconst c = children[ i ];\n\t\t\ttoggleTiles( c, renderer );\n\n\t\t}\n\n\t}\n\n}\n","// function that rate limits the amount of time a function can be called to once\n// per frame, initially queuing a new call for the next frame.\nexport function throttle( callback ) {\n\n\tlet handle = null;\n\treturn () => {\n\n\t\tif ( handle === null ) {\n\n\t\t\thandle = requestAnimationFrame( () => {\n\n\t\t\t\thandle = null;\n\t\t\t\tcallback();\n\n\t\t\t} );\n\n\t\t}\n\n\t};\n\n}\n","// Helper function for traversing a tile set. If `beforeCb` returns `true` then the\n// traversal will end early.\nexport function traverseSet( tile, beforeCb = null, afterCb = null ) {\n\n\tconst stack = [];\n\n\t// A stack-based, depth-first traversal, storing\n\t// triplets (tile, parent, depth) in the stack array.\n\n\tstack.push( tile );\n\tstack.push( null );\n\tstack.push( 0 );\n\n\twhile ( stack.length > 0 ) {\n\n\t\tconst depth = stack.pop();\n\t\tconst parent = stack.pop();\n\t\tconst tile = stack.pop();\n\n\t\tif ( beforeCb && beforeCb( tile, parent, depth ) ) {\n\n\t\t\tif ( afterCb ) {\n\n\t\t\t\tafterCb( tile, parent, depth );\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst children = tile.children;\n\n\t\t// Children might be undefined if the tile has not been preprocessed yet\n\t\tif ( children ) {\n\n\t\t\tfor ( let i = children.length - 1; i >= 0; i -- ) {\n\n\t\t\t\tstack.push( children[ i ] );\n\t\t\t\tstack.push( tile );\n\t\t\t\tstack.push( depth + 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( afterCb ) {\n\n\t\t\tafterCb( tile, parent, depth );\n\n\t\t}\n\n\t}\n\n}\n\n// Traverses the ancestry of the tile up to the root tile.\nexport function traverseAncestors( tile, callback = null ) {\n\n\tlet current = tile;\n\n\twhile ( current ) {\n\n\t\tconst depth = current.__depth;\n\t\tconst parent = current.parent;\n\n\t\tif ( callback ) {\n\n\t\t\tcallback( current, parent, depth );\n\n\t\t}\n\n\t\tcurrent = parent;\n\n\t}\n\n\n}\n","import { getUrlExtension } from '../utilities/urlExtension.js';\nimport { LRUCache } from '../utilities/LRUCache.js';\nimport { PriorityQueue } from '../utilities/PriorityQueue.js';\nimport { markUsedTiles, toggleTiles, markVisibleTiles, markUsedSetLeaves } from './traverseFunctions.js';\nimport { UNLOADED, LOADING, PARSING, LOADED, FAILED } from '../constants.js';\nimport { throttle } from '../utilities/throttle.js';\nimport { traverseSet } from '../utilities/TraversalUtils.js';\n\nconst PLUGIN_REGISTERED = Symbol( 'PLUGIN_REGISTERED' );\n\n// priority queue sort function that takes two tiles to compare. Returning 1 means\n// \"tile a\" is loaded first.\nconst priorityCallback = ( a, b ) => {\n\n\tconst aPriority = a.priority || 0;\n\tconst bPriority = b.priority || 0;\n\n\tif ( aPriority !== bPriority ) {\n\n\t\t// lower priority value sorts first\n\t\treturn aPriority > bPriority ? 1 : - 1;\n\n\t} else if ( a.__used !== b.__used ) {\n\n\t\t// load tiles that have been used\n\t\treturn a.__used ? 1 : - 1;\n\n\t} else if ( a.__error !== b.__error ) {\n\n\t\t// load the tile with the higher error\n\t\treturn a.__error > b.__error ? 1 : - 1;\n\n\t} else if ( a.__distanceFromCamera !== b.__distanceFromCamera ) {\n\n\t\t// and finally visible tiles which have equal error (ex: if geometricError === 0)\n\t\t// should prioritize based on distance.\n\t\treturn a.__distanceFromCamera > b.__distanceFromCamera ? - 1 : 1;\n\n\t} else if ( a.__depthFromRenderedParent !== b.__depthFromRenderedParent ) {\n\n\t\treturn a.__depthFromRenderedParent > b.__depthFromRenderedParent ? - 1 : 1;\n\n\t}\n\n\treturn 0;\n\n};\n\n// lru cache unload callback that takes two tiles to compare. Returning 1 means \"tile a\"\n// is unloaded first.\nconst lruPriorityCallback = ( a, b ) => {\n\n\tconst aPriority = a.priority || 0;\n\tconst bPriority = b.priority || 0;\n\n\tif ( aPriority !== bPriority ) {\n\n\t\t// lower priority value sorts first\n\t\treturn aPriority > bPriority ? 1 : - 1;\n\n\t} else if ( a.__lastFrameVisited !== b.__lastFrameVisited ) {\n\n\t\t// dispose of least recent tiles first\n\t\treturn a.__lastFrameVisited > b.__lastFrameVisited ? - 1 : 1;\n\n\t} else if ( a.__depthFromRenderedParent !== b.__depthFromRenderedParent ) {\n\n\t\t// dispose of deeper tiles first so parents are not disposed before children\n\t\treturn a.__depthFromRenderedParent > b.__depthFromRenderedParent ? 1 : - 1;\n\n\t} else if ( a.__loadingState !== b.__loadingState ) {\n\n\t\t// dispose of tiles that are earlier along in the loading process first\n\t\treturn a.__loadingState > b.__loadingState ? - 1 : 1;\n\n\t} else if ( a.__hasUnrenderableContent !== b.__hasUnrenderableContent ) {\n\n\t\t// dispose of external tile sets last\n\t\treturn a.__hasUnrenderableContent ? - 1 : 1;\n\n\t} else if ( a.__error !== b.__error ) {\n\n\t\t// unload the tile with lower error\n\t\treturn a.__error > b.__error ? - 1 : 1;\n\n\t}\n\n\treturn 0;\n\n};\n\nexport class TilesRendererBase {\n\n\tget root() {\n\n\t\tconst tileSet = this.rootTileSet;\n\t\treturn tileSet ? tileSet.root : null;\n\n\t}\n\n\tget loadProgress() {\n\n\t\tconst { stats, isLoading } = this;\n\t\tconst loading = stats.downloading + stats.parsing;\n\t\tconst total = stats.inCacheSinceLoad + ( isLoading ? 1 : 0 );\n\t\treturn total === 0 ? 1.0 : 1.0 - loading / total;\n\n\t}\n\n\tget errorThreshold() {\n\n\t\treturn this._errorThreshold;\n\n\t}\n\n\tset errorThreshold( v ) {\n\n\t\tconsole.warn( 'TilesRenderer: The \"errorThreshold\" option has been deprecated.' );\n\t\tthis._errorThreshold = v;\n\n\t}\n\n\tconstructor( url = null ) {\n\n\t\t// state\n\t\tthis.rootLoadingState = UNLOADED;\n\t\tthis.rootTileSet = null;\n\t\tthis.rootURL = url;\n\t\tthis.fetchOptions = {};\n\t\tthis.plugins = [];\n\t\tthis.queuedTiles = [];\n\t\tthis.cachedSinceLoadComplete = new Set();\n\t\tthis.isLoading = false;\n\n\t\tconst lruCache = new LRUCache();\n\t\tlruCache.unloadPriorityCallback = lruPriorityCallback;\n\n\t\tconst downloadQueue = new PriorityQueue();\n\t\tdownloadQueue.maxJobs = 25;\n\t\tdownloadQueue.priorityCallback = priorityCallback;\n\n\t\tconst parseQueue = new PriorityQueue();\n\t\tparseQueue.maxJobs = 5;\n\t\tparseQueue.priorityCallback = priorityCallback;\n\n\t\tconst processNodeQueue = new PriorityQueue();\n\t\tprocessNodeQueue.maxJobs = 25;\n\n\t\tthis.processedTiles = new WeakSet();\n\t\tthis.visibleTiles = new Set();\n\t\tthis.activeTiles = new Set();\n\t\tthis.usedSet = new Set();\n\t\tthis.lruCache = lruCache;\n\t\tthis.downloadQueue = downloadQueue;\n\t\tthis.parseQueue = parseQueue;\n\t\tthis.processNodeQueue = processNodeQueue;\n\t\tthis.stats = {\n\t\t\tinCacheSinceLoad: 0,\n\t\t\tinCache: 0,\n\t\t\tparsing: 0,\n\t\t\tdownloading: 0,\n\t\t\tfailed: 0,\n\t\t\tinFrustum: 0,\n\t\t\tused: 0,\n\t\t\tactive: 0,\n\t\t\tvisible: 0,\n\t\t};\n\t\tthis.frameCount = 0;\n\n\t\t// callbacks\n\t\tthis._dispatchNeedsUpdateEvent = throttle( () => {\n\n\t\t\tthis.dispatchEvent( { type: 'needs-update' } );\n\n\t\t} );\n\n\t\t// options\n\t\tthis.errorTarget = 16.0;\n\t\tthis._errorThreshold = Infinity;\n\t\tthis.displayActiveTiles = false;\n\t\tthis.maxDepth = Infinity;\n\n\t}\n\n\t// Plugins\n\tregisterPlugin( plugin ) {\n\n\t\tif ( plugin[ PLUGIN_REGISTERED ] === true ) {\n\n\t\t\tthrow new Error( 'TilesRendererBase: A plugin can only be registered to a single tile set' );\n\n\t\t}\n\n\t\t// insert the plugin based on the priority registered on the plugin\n\t\tconst plugins = this.plugins;\n\t\tconst priority = plugin.priority || 0;\n\t\tlet insertionPoint = plugins.length;\n\t\tfor ( let i = 0; i < plugins.length; i ++ ) {\n\n\t\t\tconst otherPriority = plugins[ i ].priority || 0;\n\t\t\tif ( otherPriority > priority ) {\n\n\t\t\t\tinsertionPoint = i;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tplugins.splice( insertionPoint, 0, plugin );\n\t\tplugin[ PLUGIN_REGISTERED ] = true;\n\t\tif ( plugin.init ) {\n\n\t\t\tplugin.init( this );\n\n\t\t}\n\n\t}\n\n\tunregisterPlugin( plugin ) {\n\n\t\tconst plugins = this.plugins;\n\t\tif ( typeof plugin === 'string' ) {\n\n\t\t\tplugin = this.getPluginByName( name );\n\n\t\t}\n\n\t\tif ( plugins.includes( plugin ) ) {\n\n\t\t\tconst index = plugins.indexOf( plugin );\n\t\t\tplugins.splice( index, 1 );\n\t\t\tif ( plugin.dispose ) {\n\n\t\t\t\tplugin.dispose();\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tgetPluginByName( name ) {\n\n\t\treturn this.plugins.find( p => p.name === name ) || null;\n\n\t}\n\n\ttraverse( beforecb, aftercb, ensureFullyProcessed = true ) {\n\n\t\tif ( ! this.root ) return;\n\n\t\ttraverseSet( this.root, ( tile, ...args ) => {\n\n\t\t\tif ( ensureFullyProcessed ) {\n\n\t\t\t\tthis.ensureChildrenArePreprocessed( tile, true );\n\n\t\t\t}\n\n\t\t\treturn beforecb ? beforecb( tile, ...args ) : false;\n\n\t\t}, aftercb );\n\n\t}\n\n\tqueueTileForDownload( tile ) {\n\n\t\tif ( tile.__loadingState !== UNLOADED || this.lruCache.isFull() ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.queuedTiles.push( tile );\n\n\t}\n\n\tmarkTileUsed( tile ) {\n\n\t\t// save the tile in a separate \"used set\" so we can mark it as unused\n\t\t// before the next tile set traversal\n\t\tthis.usedSet.add( tile );\n\t\tthis.lruCache.markUsed( tile );\n\n\t}\n\n\t// Public API\n\tupdate() {\n\n\t\tconst { lruCache, usedSet, stats, root, downloadQueue, parseQueue, processNodeQueue } = this;\n\t\tif ( this.rootLoadingState === UNLOADED ) {\n\n\t\t\tthis.rootLoadingState = LOADING;\n\t\t\tthis.invokeOnePlugin( plugin => plugin.loadRootTileSet && plugin.loadRootTileSet() )\n\t\t\t\t.then( root => {\n\n\t\t\t\t\tlet processedUrl = this.rootURL;\n\t\t\t\t\tif ( processedUrl !== null ) {\n\n\t\t\t\t\t\tthis.invokeAllPlugins( plugin => processedUrl = plugin.preprocessURL ? plugin.preprocessURL( processedUrl, null ) : processedUrl );\n\n\t\t\t\t\t}\n\t\t\t\t\tthis.rootLoadingState = LOADED;\n\t\t\t\t\tthis.rootTileSet = root;\n\t\t\t\t\tthis.dispatchEvent( { type: 'needs-update' } );\n\t\t\t\t\tthis.dispatchEvent( { type: 'load-content' } );\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'load-tile-set',\n\t\t\t\t\t\ttileSet: root,\n\t\t\t\t\t\turl: processedUrl,\n\t\t\t\t\t} );\n\n\t\t\t\t} )\n\t\t\t\t.catch( error => {\n\n\t\t\t\t\tthis.rootLoadingState = FAILED;\n\t\t\t\t\tconsole.error( error );\n\n\t\t\t\t\tthis.rootTileSet = null;\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'load-error',\n\t\t\t\t\t\ttile: null,\n\t\t\t\t\t\terror,\n\t\t\t\t\t\turl: this.rootURL,\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t}\n\n\t\tif ( ! root ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tstats.inFrustum = 0;\n\t\tstats.used = 0;\n\t\tstats.active = 0;\n\t\tstats.visible = 0;\n\t\tthis.frameCount ++;\n\n\t\tusedSet.forEach( tile => lruCache.markUnused( tile ) );\n\t\tusedSet.clear();\n\n\t\tmarkUsedTiles( root, this );\n\t\tmarkUsedSetLeaves( root, this );\n\t\tmarkVisibleTiles( root, this );\n\t\ttoggleTiles( root, this );\n\n\t\t// TODO: This will only sort for one tile set. We may want to store this queue on the\n\t\t// LRUCache so multiple tile sets can use it at once\n\t\t// start the downloads of the tiles as needed\n\t\tconst queuedTiles = this.queuedTiles;\n\t\tqueuedTiles.sort( lruCache.unloadPriorityCallback );\n\t\tfor ( let i = 0, l = queuedTiles.length; i < l && ! lruCache.isFull(); i ++ ) {\n\n\t\t\tthis.requestTileContents( queuedTiles[ i ] );\n\n\t\t}\n\n\t\tqueuedTiles.length = 0;\n\n\t\t// start the downloads\n\t\tlruCache.scheduleUnload();\n\n\t\t// if all tasks have finished and we've been marked as actively loading then fire the completion event\n\t\tconst runningTasks = downloadQueue.running || parseQueue.running || processNodeQueue.running;\n\t\tif ( runningTasks === false && this.isLoading === true ) {\n\n\t\t\tthis.cachedSinceLoadComplete.clear();\n\t\t\tstats.inCacheSinceLoad = 0;\n\n\t\t\tthis.dispatchEvent( { type: 'tiles-load-end' } );\n\t\t\tthis.isLoading = false;\n\n\t\t}\n\n\t}\n\n\tresetFailedTiles() {\n\n\t\t// reset the root tile if it's finished but never loaded\n\t\tif ( this.rootLoadingState === FAILED ) {\n\n\t\t\tthis.rootLoadingState = UNLOADED;\n\n\t\t}\n\n\t\tconst stats = this.stats;\n\t\tif ( stats.failed === 0 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.traverse( tile => {\n\n\t\t\tif ( tile.__loadingState === FAILED ) {\n\n\t\t\t\ttile.__loadingState = UNLOADED;\n\n\t\t\t}\n\n\t\t}, null, false );\n\n\t\tstats.failed = 0;\n\n\t}\n\n\tdispose() {\n\n\t\t// dispose of all the plugins\n\t\tconst plugins = [ ...this.plugins ];\n\t\tplugins.forEach( plugin => {\n\n\t\t\tthis.unregisterPlugin( plugin );\n\n\t\t} );\n\n\t\tconst lruCache = this.lruCache;\n\n\t\t// Make sure we've collected all children before disposing of the internal tilesets to avoid\n\t\t// dangling children that we inadvertantly skip when deleting the nested tileset.\n\t\tconst toRemove = [];\n\t\tthis.traverse( t => {\n\n\t\t\ttoRemove.push( t );\n\t\t\treturn false;\n\n\t\t}, null, false );\n\t\tfor ( let i = 0, l = toRemove.length; i < l; i ++ ) {\n\n\t\t\tlruCache.remove( toRemove[ i ] );\n\n\t\t}\n\n\t\tthis.stats = {\n\t\t\tparsing: 0,\n\t\t\tdownloading: 0,\n\t\t\tfailed: 0,\n\t\t\tinFrustum: 0,\n\t\t\tused: 0,\n\t\t\tactive: 0,\n\t\t\tvisible: 0,\n\t\t};\n\t\tthis.frameCount = 0;\n\n\t}\n\n\t// Overrideable\n\tcalculateBytesUsed( scene, tile ) {\n\n\t\treturn 0;\n\n\t}\n\n\tdispatchEvent( e ) {\n\n\t\t// event to be overriden for dispatching via an event system\n\n\t}\n\n\tfetchData( url, options ) {\n\n\t\treturn fetch( url, options );\n\n\t}\n\n\tparseTile( buffer, tile, extension ) {\n\n\t\treturn null;\n\n\t}\n\n\tdisposeTile( tile ) {\n\n\t\t// TODO: are these necessary? Are we disposing tiles when they are currently visible?\n\t\tif ( tile.__visible ) {\n\n\t\t\tthis.invokeOnePlugin( plugin => plugin.setTileVisible && plugin.setTileVisible( tile, false ) );\n\t\t\ttile.__visible = false;\n\n\t\t}\n\n\t\tif ( tile.__active ) {\n\n\t\t\tthis.invokeOnePlugin( plugin => plugin.setTileActive && plugin.setTileActive( tile, false ) );\n\t\t\ttile.__active = false;\n\n\t\t}\n\n\t}\n\n\tpreprocessNode( tile, tileSetDir, parentTile = null ) {\n\n\t\tthis.processedTiles.add( tile );\n\n\t\tif ( tile.content ) {\n\n\t\t\t// Fix old file formats\n\t\t\tif ( ! ( 'uri' in tile.content ) && 'url' in tile.content ) {\n\n\t\t\t\ttile.content.uri = tile.content.url;\n\t\t\t\tdelete tile.content.url;\n\n\t\t\t}\n\n\t\t\t// NOTE: fix for some cases where tilesets provide the bounding volume\n\t\t\t// but volumes are not present.\n\t\t\tif (\n\t\t\t\ttile.content.boundingVolume &&\n\t\t\t\t! (\n\t\t\t\t\t'box' in tile.content.boundingVolume ||\n\t\t\t\t\t'sphere' in tile.content.boundingVolume ||\n\t\t\t\t\t'region' in tile.content.boundingVolume\n\t\t\t\t)\n\t\t\t) {\n\n\t\t\t\tdelete tile.content.boundingVolume;\n\n\t\t\t}\n\n\t\t}\n\n\t\ttile.parent = parentTile;\n\t\ttile.children = tile.children || [];\n\n\t\tif ( tile.content?.uri ) {\n\n\t\t\t// \"content\" should only indicate loadable meshes, not external tile sets\n\t\t\tconst extension = getUrlExtension( tile.content.uri );\n\n\t\t\ttile.__hasContent = true;\n\t\t\ttile.__hasUnrenderableContent = Boolean( extension && /json$/.test( extension ) );\n\t\t\ttile.__hasRenderableContent = ! tile.__hasUnrenderableContent;\n\n\t\t} else {\n\n\t\t\ttile.__hasContent = false;\n\t\t\ttile.__hasUnrenderableContent = false;\n\t\t\ttile.__hasRenderableContent = false;\n\n\t\t}\n\n\t\t// tracker for determining if all the children have been asynchronously\n\t\t// processed and are ready to be traversed\n\t\ttile.__childrenProcessed = 0;\n\t\tif ( parentTile ) {\n\n\t\t\tparentTile.__childrenProcessed ++;\n\n\t\t}\n\n\t\ttile.__distanceFromCamera = Infinity;\n\t\ttile.__error = Infinity;\n\n\t\ttile.__inFrustum = false;\n\t\ttile.__isLeaf = false;\n\n\t\ttile.__usedLastFrame = false;\n\t\ttile.__used = false;\n\n\t\ttile.__wasSetVisible = false;\n\t\ttile.__visible = false;\n\t\ttile.__allChildrenLoaded = false;\n\n\t\ttile.__wasSetActive = false;\n\t\ttile.__active = false;\n\n\t\ttile.__loadingState = UNLOADED;\n\n\t\tif ( parentTile === null ) {\n\n\t\t\ttile.__depth = 0;\n\t\t\ttile.__depthFromRenderedParent = ( tile.__hasRenderableContent ? 1 : 0 );\n\t\t\ttile.refine = tile.refine || 'REPLACE';\n\n\t\t} else {\n\n\t\t\t// increment the \"depth from parent\" when we encounter a new tile with content\n\t\t\ttile.__depth = parentTile.__depth + 1;\n\t\t\ttile.__depthFromRenderedParent = parentTile.__depthFromRenderedParent + ( tile.__hasRenderableContent ? 1 : 0 );\n\n\t\t\ttile.refine = tile.refine || parentTile.refine;\n\n\t\t}\n\n\t\ttile.__basePath = tileSetDir;\n\n\t\ttile.__lastFrameVisited = - 1;\n\n\t\tthis.invokeAllPlugins( plugin => {\n\n\t\t\tplugin !== this && plugin.preprocessNode && plugin.preprocessNode( tile, tileSetDir, parentTile );\n\n\t\t} );\n\n\t}\n\n\tsetTileActive( tile, active ) {\n\n\t\tactive ? this.activeTiles.add( tile ) : this.activeTiles.delete( tile );\n\n\t}\n\n\tsetTileVisible( tile, visible ) {\n\n\t\tvisible ? this.visibleTiles.add( tile ) : this.visibleTiles.delete( tile );\n\n\t}\n\n\tcalculateTileViewError( tile, target ) {\n\n\t\t// retrieve whether the tile is visible, screen space error, and distance to camera\n\t\t// set \"inView\", \"error\", \"distance\"\n\n\t}\n\n\tensureChildrenArePreprocessed( tile, immediate = false ) {\n\n\t\tconst children = tile.children;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tconst child = children[ i ];\n\t\t\tif ( '__depth' in child ) {\n\n\t\t\t\t// the child has already been processed\n\t\t\t\tbreak;\n\n\t\t\t} else if ( immediate ) {\n\n\t\t\t\t// process the node immediately and make sure we don't double process it\n\t\t\t\tthis.processNodeQueue.remove( child );\n\t\t\t\tthis.preprocessNode( child, tile.__basePath, tile );\n\n\t\t\t} else {\n\n\t\t\t\t// queue the node for processing if it hasn't been already\n\t\t\t\tif ( ! this.processNodeQueue.has( child ) ) {\n\n\t\t\t\t\tthis.processNodeQueue.add( child, child => {\n\n\t\t\t\t\t\tthis.preprocessNode( child, tile.__basePath, tile );\n\t\t\t\t\t\tthis._dispatchNeedsUpdateEvent();\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Private Functions\n\t// returns the total bytes used for by the given tile as reported by all plugins\n\tgetBytesUsed( tile ) {\n\n\t\tlet bytes = 0;\n\t\tthis.invokeAllPlugins( plugin => {\n\n\t\t\tif ( plugin.calculateBytesUsed ) {\n\n\t\t\t\tbytes += plugin.calculateBytesUsed( tile, tile.cached.scene ) || 0;\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn bytes;\n\n\t}\n\n\t// force a recalculation of the tile or all tiles if no tile is provided\n\trecalculateBytesUsed( tile = null ) {\n\n\t\tconst { lruCache, processedTiles } = this;\n\t\tif ( tile === null ) {\n\n\t\t\tlruCache.itemSet.forEach( item => {\n\n\t\t\t\tif ( processedTiles.has( item ) ) {\n\n\t\t\t\t\tlruCache.setMemoryUsage( item, this.getBytesUsed( item ) );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\tlruCache.setMemoryUsage( tile, this.getBytesUsed( tile ) );\n\n\t\t}\n\n\t}\n\n\tpreprocessTileSet( json, url, parent = null ) {\n\n\t\tconst version = json.asset.version;\n\t\tconst [ major, minor ] = version.split( '.' ).map( v => parseInt( v ) );\n\t\tconsole.assert(\n\t\t\tmajor <= 1,\n\t\t\t'TilesRenderer: asset.version is expected to be a 1.x or a compatible version.',\n\t\t);\n\n\t\tif ( major === 1 && minor > 0 ) {\n\n\t\t\tconsole.warn( 'TilesRenderer: tiles versions at 1.1 or higher have limited support. Some new extensions and features may not be supported.' );\n\n\t\t}\n\n\t\t// remove the last file path path-segment from the URL including the trailing slash\n\t\tlet basePath = url.replace( /\\/[^/]*$/, '' );\n\t\tbasePath = new URL( basePath, window.location.href ).toString();\n\t\tthis.preprocessNode( json.root, basePath, parent );\n\n\t}\n\n\tloadRootTileSet() {\n\n\t\t// transform the url\n\t\tlet processedUrl = this.rootURL;\n\t\tthis.invokeAllPlugins( plugin => processedUrl = plugin.preprocessURL ? plugin.preprocessURL( processedUrl, null ) : processedUrl );\n\n\t\t// load the tile set root\n\t\tconst pr = this\n\t\t\t.invokeOnePlugin( plugin => plugin.fetchData && plugin.fetchData( processedUrl, this.fetchOptions ) )\n\t\t\t.then( res => {\n\n\t\t\t\tif ( ! ( res instanceof Response ) ) {\n\n\t\t\t\t\treturn res;\n\n\t\t\t\t} else if ( res.ok ) {\n\n\t\t\t\t\treturn res.json();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( `TilesRenderer: Failed to load tileset \"${ processedUrl }\" with status ${ res.status } : ${ res.statusText }` );\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.then( root => {\n\n\t\t\t\tthis.preprocessTileSet( root, processedUrl );\n\t\t\t\treturn root;\n\n\t\t\t} );\n\n\t\treturn pr;\n\n\t}\n\n\trequestTileContents( tile ) {\n\n\t\t// If the tile is already being loaded then don't\n\t\t// start it again.\n\t\tif ( tile.__loadingState !== UNLOADED ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tlet isExternalTileSet = false;\n\t\tlet externalTileset = null;\n\t\tlet uri = new URL( tile.content.uri, tile.__basePath + '/' ).toString();\n\t\tthis.invokeAllPlugins( plugin => uri = plugin.preprocessURL ? plugin.preprocessURL( uri, tile ) : uri );\n\n\t\tconst stats = this.stats;\n\t\tconst lruCache = this.lruCache;\n\t\tconst downloadQueue = this.downloadQueue;\n\t\tconst parseQueue = this.parseQueue;\n\t\tconst extension = getUrlExtension( uri );\n\n\t\t// track an abort controller and pass-through the below conditions if aborted\n\t\tconst controller = new AbortController();\n\t\tconst signal = controller.signal;\n\t\tconst addedSuccessfully = lruCache.add( tile, t => {\n\n\t\t\t// Stop the load if it's started\n\t\t\tcontroller.abort();\n\n\t\t\t// Clear out all tile content\n\t\t\tif ( isExternalTileSet ) {\n\n\t\t\t\tt.children.length = 0;\n\t\t\t\tt.__childrenProcessed = 0;\n\n\t\t\t} else {\n\n\t\t\t\tthis.invokeAllPlugins( plugin => {\n\n\t\t\t\t\tplugin.disposeTile && plugin.disposeTile( t );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\t// Decrement stats\n\t\t\tstats.inCache --;\n\t\t\tif ( this.cachedSinceLoadComplete.has( tile ) ) {\n\n\t\t\t\tthis.cachedSinceLoadComplete.delete( tile );\n\t\t\t\tstats.inCacheSinceLoad --;\n\n\t\t\t}\n\n\t\t\tif ( t.__loadingState === LOADING ) {\n\n\t\t\t\tstats.downloading --;\n\n\t\t\t} else if ( t.__loadingState === PARSING ) {\n\n\t\t\t\tstats.parsing --;\n\n\t\t\t}\n\n\t\t\tt.__loadingState = UNLOADED;\n\n\t\t\tparseQueue.remove( t );\n\t\t\tdownloadQueue.remove( t );\n\n\t\t} );\n\n\t\t// if we couldn't add the tile to the lru cache because it's full then skip\n\t\tif ( ! addedSuccessfully ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// check if this is the beginning of a new set of tiles to load and dispatch and event\n\t\tif ( ! this.isLoading ) {\n\n\t\t\tthis.isLoading = true;\n\t\t\tthis.dispatchEvent( { type: 'tiles-load-start' } );\n\n\t\t}\n\n\t\tlruCache.setMemoryUsage( tile, this.getBytesUsed( tile ) );\n\t\tthis.cachedSinceLoadComplete.add( tile );\n\t\tstats.inCacheSinceLoad ++;\n\t\tstats.inCache ++;\n\t\tstats.downloading ++;\n\t\ttile.__loadingState = LOADING;\n\n\t\t// queue the download and parse\n\t\treturn downloadQueue.add( tile, downloadTile => {\n\n\t\t\tif ( signal.aborted ) {\n\n\t\t\t\treturn Promise.resolve();\n\n\t\t\t}\n\n\t\t\tconst res = this.invokeOnePlugin( plugin => plugin.fetchData && plugin.fetchData( uri, { ...this.fetchOptions, signal } ) );\n\t\t\tthis.dispatchEvent( { type: 'tile-download-start', tile } );\n\t\t\treturn res;\n\n\t\t} )\n\t\t\t.then( res => {\n\n\t\t\t\tif ( signal.aborted ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( res instanceof Response ) ) {\n\n\t\t\t\t\treturn res;\n\n\t\t\t\t} else if ( res.ok ) {\n\n\t\t\t\t\treturn extension === 'json' ? res.json() : res.arrayBuffer();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( `Failed to load model with error code ${res.status}` );\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.then( content => {\n\n\t\t\t\t// if it has been unloaded then the tile has been disposed\n\t\t\t\tif ( signal.aborted ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tstats.downloading --;\n\t\t\t\tstats.parsing ++;\n\t\t\t\ttile.__loadingState = PARSING;\n\n\t\t\t\treturn parseQueue.add( tile, parseTile => {\n\n\t\t\t\t\t// if it has been unloaded then the tile has been disposed\n\t\t\t\t\tif ( signal.aborted ) {\n\n\t\t\t\t\t\treturn Promise.resolve();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( extension === 'json' && content.root ) {\n\n\t\t\t\t\t\tthis.preprocessTileSet( content, uri, tile );\n\t\t\t\t\t\ttile.children.push( content.root );\n\t\t\t\t\t\texternalTileset = content;\n\t\t\t\t\t\tisExternalTileSet = true;\n\t\t\t\t\t\treturn Promise.resolve();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn this.invokeOnePlugin( plugin => plugin.parseTile && plugin.parseTile( content, parseTile, extension, uri, signal ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t} )\n\t\t\t.then( () => {\n\n\t\t\t\t// if it has been unloaded then the tile has been disposed\n\t\t\t\tif ( signal.aborted ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tstats.parsing --;\n\t\t\t\ttile.__loadingState = LOADED;\n\t\t\t\tlruCache.setLoaded( tile, true );\n\n\t\t\t\t// If the memory of the item hasn't been registered yet then that means the memory usage hasn't\n\t\t\t\t// been accounted for by the cache yet so we need to check if it fits or if we should remove it.\n\t\t\t\tconst bytesUsed = this.getBytesUsed( tile );\n\t\t\t\tif ( lruCache.getMemoryUsage( tile ) === 0 && bytesUsed > 0 && lruCache.isFull() ) {\n\n\t\t\t\t\t// And if the cache is full due to newly loaded memory then lets discard this tile - it will\n\t\t\t\t\t// be loaded again later from the disk cache if needed.\n\t\t\t\t\tlruCache.remove( tile );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\t// update memory\n\t\t\t\tlruCache.setMemoryUsage( tile, bytesUsed );\n\n\t\t\t\t// dispatch an event indicating that this model has completed and that a new\n\t\t\t\t// call to \"update\" is needed.\n\t\t\t\tthis.dispatchEvent( { type: 'needs-update' } );\n\t\t\t\tthis.dispatchEvent( { type: 'load-content' } );\n\t\t\t\tif ( isExternalTileSet ) {\n\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'load-tile-set',\n\t\t\t\t\t\ttileSet: externalTileset,\n\t\t\t\t\t\turl: uri,\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\t\t\t\tif ( tile.cached.scene ) {\n\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'load-model',\n\t\t\t\t\t\tscene: tile.cached.scene,\n\t\t\t\t\t\ttile,\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.catch( error => {\n\n\t\t\t\t// if it has been unloaded then the tile has been disposed\n\t\t\t\tif ( signal.aborted ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( error.name !== 'AbortError' ) {\n\n\t\t\t\t\tparseQueue.remove( tile );\n\t\t\t\t\tdownloadQueue.remove( tile );\n\n\t\t\t\t\tif ( tile.__loadingState === PARSING ) {\n\n\t\t\t\t\t\tstats.parsing --;\n\n\t\t\t\t\t} else if ( tile.__loadingState === LOADING ) {\n\n\t\t\t\t\t\tstats.downloading --;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tstats.failed ++;\n\n\t\t\t\t\tconsole.error( `TilesRenderer : Failed to load tile at url \"${ tile.content.uri }\".` );\n\t\t\t\t\tconsole.error( error );\n\t\t\t\t\ttile.__loadingState = FAILED;\n\t\t\t\t\tlruCache.setLoaded( tile, true );\n\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'load-error',\n\t\t\t\t\t\ttile,\n\t\t\t\t\t\terror,\n\t\t\t\t\t\turl: uri,\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlruCache.remove( tile );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t}\n\n\tgetAttributions( target = [] ) {\n\n\t\tthis.invokeAllPlugins( plugin => plugin !== this && plugin.getAttributions && plugin.getAttributions( target ) );\n\t\treturn target;\n\n\t}\n\n\tinvokeOnePlugin( func ) {\n\n\t\tconst plugins = [ ...this.plugins, this ];\n\t\tfor ( let i = 0; i < plugins.length; i ++ ) {\n\n\t\t\tconst result = func( plugins[ i ] );\n\t\t\tif ( result ) {\n\n\t\t\t\treturn result;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tinvokeAllPlugins( func ) {\n\n\t\tconst plugins = [ ...this.plugins, this ];\n\t\tconst pending = [];\n\t\tfor ( let i = 0; i < plugins.length; i ++ ) {\n\n\t\t\tconst result = func( plugins[ i ] );\n\t\t\tif ( result ) {\n\n\t\t\t\tpending.push( result );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn pending.length === 0 ? null : Promise.all( pending );\n\n\t}\n\n}\n","import { Group, Matrix4 } from 'three';\n\n// Specialization of \"Group\" that only updates world matrices of children if\n// the transform has changed since the last update and ignores the \"force\"\n// parameter under the assumption that the children tiles will not move.\nconst tempMat = new Matrix4();\nexport class TilesGroup extends Group {\n\n\tconstructor( tilesRenderer ) {\n\n\t\tsuper();\n\t\tthis.isTilesGroup = true;\n\t\tthis.name = 'TilesRenderer.TilesGroup';\n\t\tthis.tilesRenderer = tilesRenderer;\n\t\tthis.matrixWorldInverse = new Matrix4();\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\t// returning \"false\" ends raycast traversal\n\t\tif ( this.tilesRenderer.optimizeRaycast ) {\n\n\t\t\tthis.tilesRenderer.raycast( raycaster, intersects );\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tif ( this.matrixAutoUpdate ) {\n\n\t\t\tthis.updateMatrix();\n\n\t\t}\n\n\t\tif ( this.matrixWorldNeedsUpdate || force ) {\n\n\t\t\tif ( this.parent === null ) {\n\n\t\t\t\ttempMat.copy( this.matrix );\n\n\t\t\t} else {\n\n\t\t\t\ttempMat.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t}\n\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\t// check if the matrix changed relative to what it was.\n\t\t\tconst elA = tempMat.elements;\n\t\t\tconst elB = this.matrixWorld.elements;\n\t\t\tlet isDifferent = false;\n\t\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\t\tconst itemA = elA[ i ];\n\t\t\t\tconst itemB = elB[ i ];\n\t\t\t\tconst diff = Math.abs( itemA - itemB );\n\n\t\t\t\tif ( diff > Number.EPSILON ) {\n\n\t\t\t\t\tisDifferent = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( isDifferent ) {\n\n\t\t\t\tthis.matrixWorld.copy( tempMat );\n\t\t\t\tthis.matrixWorldInverse.copy( tempMat ).invert();\n\n\t\t\t\t// update children\n\t\t\t\t// the children will not have to change unless the parent group has updated\n\t\t\t\tconst children = this.children;\n\t\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\t\tchildren[ i ].updateMatrixWorld();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdateWorldMatrix( updateParents, updateChildren ) {\n\n\t\tif ( this.parent && updateParents ) {\n\n\t\t\tthis.parent.updateWorldMatrix( updateParents, false );\n\n\t\t}\n\n\t\t// run the normal update function to ensure children and inverse matrices are in sync\n\t\tthis.updateMatrixWorld( true );\n\n\t}\n\n}\n","import { Ray, Vector3 } from 'three';\n\n// In three.js r165 and higher raycast traversal can be ended early\nconst _localRay = new Ray();\nconst _vec = new Vector3();\nconst _hitArray = [];\n\nfunction distanceSort( a, b ) {\n\n\treturn a.distance - b.distance;\n\n}\n\nfunction intersectTileScene( tile, raycaster, renderer, intersects ) {\n\n\tconst { scene } = tile.cached;\n\tconst didRaycast = renderer.invokeOnePlugin( plugin => plugin.raycastTile && plugin.raycastTile( tile, scene, raycaster, intersects ) );\n\tif ( ! didRaycast ) {\n\n\t\traycaster.intersectObject( scene, true, intersects );\n\n\t}\n\n}\n\nfunction intersectTileSceneFirstHist( tile, raycaster, renderer ) {\n\n\tintersectTileScene( tile, raycaster, renderer, _hitArray );\n\t_hitArray.sort( distanceSort );\n\n\tconst hit = _hitArray[ 0 ] || null;\n\t_hitArray.length = 0;\n\treturn hit;\n\n}\n\nfunction isTileInitialized( tile ) {\n\n\treturn '__used' in tile;\n\n}\n\n// Returns the closest hit when traversing the tree\nexport function raycastTraverseFirstHit( renderer, tile, raycaster, localRay = null ) {\n\n\tconst { group, activeTiles } = renderer;\n\n\t// get the ray in the local group frame\n\tif ( localRay === null ) {\n\n\t\tlocalRay = _localRay;\n\t\tlocalRay.copy( raycaster.ray ).applyMatrix4( group.matrixWorldInverse );\n\n\t}\n\n\t// get a set of intersections so we intersect the nearest one first\n\tconst array = [];\n\tconst children = tile.children;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\tconst child = children[ i ];\n\t\tif ( ! isTileInitialized( child ) || ! child.__used ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\t// track the tile and hit distance for sorting\n\t\tconst boundingVolume = child.cached.boundingVolume;\n\t\tif ( boundingVolume.intersectRay( localRay, _vec ) !== null ) {\n\n\t\t\t_vec.applyMatrix4( group.matrixWorld );\n\t\t\tarray.push( {\n\t\t\t\tdistance: _vec.distanceToSquared( raycaster.ray.origin ),\n\t\t\t\ttile: child,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t// sort them by ascending distance\n\tarray.sort( distanceSort );\n\n\t// If the root is active make sure we've checked it\n\tlet bestHit = null;\n\tlet bestHitDistSq = Infinity;\n\tif ( activeTiles.has( tile ) ) {\n\n\t\tconst hit = intersectTileSceneFirstHist( tile, raycaster, renderer );\n\t\tif ( hit ) {\n\n\t\t\tbestHit = hit;\n\t\t\tbestHitDistSq = hit.distance * hit.distance;\n\n\t\t}\n\n\t}\n\n\t// traverse until we find the best hit and early out if a tile bounds\n\t// couldn't possible include a best hit\n\tfor ( let i = 0, l = array.length; i < l; i ++ ) {\n\n\t\tconst data = array[ i ];\n\t\tconst boundingVolumeDistSq = data.distance;\n\t\tconst tile = data.tile;\n\t\tif ( boundingVolumeDistSq > bestHitDistSq ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t\tconst hit = raycastTraverseFirstHit( renderer, tile, raycaster, localRay );\n\t\tif ( hit ) {\n\n\t\t\tconst hitDistSq = hit.distance * hit.distance;\n\t\t\tif ( hitDistSq < bestHitDistSq ) {\n\n\t\t\t\tbestHit = hit;\n\t\t\t\tbestHitDistSq = hitDistSq;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn bestHit;\n\n}\n\nexport function raycastTraverse( renderer, tile, raycaster, intersects, localRay = null ) {\n\n\t// if the tile has not been asynchronously initialized then there's no point in\n\t// traversing the tiles to check intersections.\n\tif ( ! isTileInitialized( tile ) ) {\n\n\t\treturn;\n\n\t}\n\n\tconst { group, activeTiles } = renderer;\n\tconst { boundingVolume } = tile.cached;\n\n\t// get the ray in the local group frame\n\tif ( localRay === null ) {\n\n\t\tlocalRay = _localRay;\n\t\tlocalRay.copy( raycaster.ray ).applyMatrix4( group.matrixWorldInverse );\n\n\t}\n\n\t// exit early if the tile isn't used or the bounding volume is not intersected\n\tif ( ! tile.__used || ! boundingVolume.intersectsRay( localRay ) ) {\n\n\t\treturn;\n\n\t}\n\n\t// only intersect the tile geometry if it's active\n\tif ( activeTiles.has( tile ) ) {\n\n\t\tintersectTileScene( tile, raycaster, renderer, intersects );\n\n\t}\n\n\tconst children = tile.children;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\traycastTraverse( renderer, children[ i ], raycaster, intersects, localRay );\n\n\t}\n\n}\n","import { Matrix4, Box3, Vector3, Plane, Ray } from 'three';\n\nconst _worldMin = new Vector3();\nconst _worldMax = new Vector3();\nconst _norm = new Vector3();\nconst _ray = new Ray();\n\nexport class OBB {\n\n\tconstructor( box = new Box3(), transform = new Matrix4() ) {\n\n\t\tthis.box = box.clone();\n\t\tthis.transform = transform.clone();\n\t\tthis.inverseTransform = new Matrix4();\n\t\tthis.points = new Array( 8 ).fill().map( () => new Vector3() );\n\t\tthis.planes = new Array( 6 ).fill().map( () => new Plane() );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.box.copy( source.box );\n\t\tthis.transform.copy( source.transform );\n\t\tthis.update();\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\t/**\n\t * Clamps the given point within the bounds of this OBB\n\t * @param {Vector3} point\n\t * @param {Vector3} result\n\t * @returns {Vector3}\n\t */\n\tclampPoint( point, result ) {\n\n\t\treturn result.copy( point )\n\t\t\t.applyMatrix4( this.inverseTransform )\n\t\t\t.clamp( this.box.min, this.box.max )\n\t\t\t.applyMatrix4( this.transform );\n\n\t}\n\n\t/**\n\t * Returns the distance from any edge of this OBB to the specified point.\n\t * If the point lies inside of this box, the distance will be 0.\n\t * @param {Vector3} point\n\t * @returns {number}\n\t */\n\tdistanceToPoint( point ) {\n\n\t\treturn this.clampPoint( point, _norm ).distanceTo( point );\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\t_norm.copy( point ).applyMatrix4( this.inverseTransform );\n\t\treturn this.box.containsPoint( _norm );\n\n\t}\n\n\t// returns boolean indicating whether the ray has intersected the obb\n\tintersectsRay( ray ) {\n\n\t\t_ray.copy( ray ).applyMatrix4( this.inverseTransform );\n\t\treturn _ray.intersectsBox( this.box );\n\n\t}\n\n\t// Sets \"target\" equal to the intersection point.\n\t// Returns \"null\" if no intersection found.\n\tintersectRay( ray, target ) {\n\n\t\t_ray.copy( ray ).applyMatrix4( this.inverseTransform );\n\t\tif ( _ray.intersectBox( this.box, target ) ) {\n\n\t\t\ttarget.applyMatrix4( this.transform );\n\t\t\treturn target;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\tconst { points, inverseTransform, transform, box } = this;\n\t\tinverseTransform.copy( transform ).invert();\n\n\t\tconst { min, max } = box;\n\t\tlet index = 0;\n\t\tfor ( let x = - 1; x <= 1; x += 2 ) {\n\n\t\t\tfor ( let y = - 1; y <= 1; y += 2 ) {\n\n\t\t\t\tfor ( let z = - 1; z <= 1; z += 2 ) {\n\n\t\t\t\t\tpoints[ index ].set(\n\t\t\t\t\t\tx < 0 ? min.x : max.x,\n\t\t\t\t\t\ty < 0 ? min.y : max.y,\n\t\t\t\t\t\tz < 0 ? min.z : max.z,\n\t\t\t\t\t).applyMatrix4( transform );\n\t\t\t\t\tindex ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.updatePlanes();\n\n\t}\n\n\tupdatePlanes() {\n\n\t\t_worldMin.copy( this.box.min ).applyMatrix4( this.transform );\n\t\t_worldMax.copy( this.box.max ).applyMatrix4( this.transform );\n\n\t\t_norm.set( 0, 0, 1 ).transformDirection( this.transform );\n\t\tthis.planes[ 0 ].setFromNormalAndCoplanarPoint( _norm, _worldMin );\n\t\tthis.planes[ 1 ].setFromNormalAndCoplanarPoint( _norm, _worldMax ).negate();\n\n\t\t_norm.set( 0, 1, 0 ).transformDirection( this.transform );\n\t\tthis.planes[ 2 ].setFromNormalAndCoplanarPoint( _norm, _worldMin );\n\t\tthis.planes[ 3 ].setFromNormalAndCoplanarPoint( _norm, _worldMax ).negate();\n\n\t\t_norm.set( 1, 0, 0 ).transformDirection( this.transform );\n\t\tthis.planes[ 4 ].setFromNormalAndCoplanarPoint( _norm, _worldMin );\n\t\tthis.planes[ 5 ].setFromNormalAndCoplanarPoint( _norm, _worldMax ).negate();\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\tthis.clampPoint( sphere.center, _norm );\n\t\treturn _norm.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t}\n\n\tintersectsFrustum( frustum ) {\n\n\t\treturn this._intersectsPlaneShape( frustum.planes, frustum.points );\n\n\t}\n\n\tintersectsOBB( obb ) {\n\n\t\treturn this._intersectsPlaneShape( obb.planes, obb.points );\n\n\t}\n\n\t// takes a series of 6 planes that define and enclosed shape and the 8 points that lie at the corners\n\t// of that shape to determine whether the OBB is intersected with.\n\t_intersectsPlaneShape( otherPlanes, otherPoints ) {\n\n\t\tconst thisPoints = this.points;\n\t\tconst thisPlanes = this.planes;\n\n\t\t// based on three.js' Box3 \"intersects frustum\" function\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst plane = otherPlanes[ i ];\n\t\t\tlet maxDistance = - Infinity;\n\t\t\tfor ( let j = 0; j < 8; j ++ ) {\n\n\t\t\t\tconst v = thisPoints[ j ];\n\t\t\t\tconst dist = plane.distanceToPoint( v );\n\t\t\t\tmaxDistance = maxDistance < dist ? dist : maxDistance;\n\n\t\t\t}\n\n\t\t\tif ( maxDistance < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// do the opposite check using the obb planes to avoid false positives\n\t\t// this check is not performed by three.js' AABB logic but helps prevent a lot incorrect intersection reports\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst plane = thisPlanes[ i ];\n\t\t\tlet maxDistance = - Infinity;\n\t\t\tfor ( let j = 0; j < 8; j ++ ) {\n\n\t\t\t\tconst v = otherPoints[ j ];\n\t\t\t\tconst dist = plane.distanceToPoint( v );\n\t\t\t\tmaxDistance = maxDistance < dist ? dist : maxDistance;\n\n\t\t\t}\n\n\t\t\tif ( maxDistance < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n}\n","import { Vector3, Sphere } from 'three';\nimport { OBB } from './OBB.js';\nimport { EllipsoidRegion } from './EllipsoidRegion.js';\n\nconst _vecX = new Vector3();\nconst _vecY = new Vector3();\nconst _vecZ = new Vector3();\nconst _sphereVec = new Vector3();\nconst _obbVec = new Vector3();\n\n// TODO: check region more precisely in all functions\nexport class TileBoundingVolume {\n\n\tconstructor() {\n\n\t\tthis.sphere = null;\n\t\tthis.obb = null;\n\t\tthis.region = null;\n\n\t\tthis.regionObb = null;\n\n\t}\n\n\tintersectsRay( ray ) {\n\n\t\tconst sphere = this.sphere;\n\t\tconst obb = this.obb || this.regionObb;\n\n\t\t// Early out if we don't hit this tile sphere\n\t\tif ( sphere && ! ray.intersectsSphere( sphere ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// Early out if we don't this this tile box\n\t\tif ( obb && ! obb.intersectsRay( ray ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tintersectRay( ray, target = null ) {\n\n\t\tconst sphere = this.sphere;\n\t\tconst obb = this.obb || this.regionObb;\n\n\t\tlet sphereDistSq = - Infinity;\n\t\tlet obbDistSq = - Infinity;\n\n\t\tif ( sphere ) {\n\n\t\t\tif ( ray.intersectSphere( sphere, _sphereVec ) ) {\n\n\t\t\t\tsphereDistSq = sphere.containsPoint( ray.origin ) ? 0 : ray.origin.distanceToSquared( _sphereVec );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( obb ) {\n\n\t\t\tif ( obb.intersectRay( ray, _obbVec ) ) {\n\n\t\t\t\tobbDistSq = obb.containsPoint( ray.origin ) ? 0 : ray.origin.distanceToSquared( _obbVec );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// if we didn't hit anything then exit\n\t\tconst furthestDist = Math.max( sphereDistSq, obbDistSq );\n\t\tif ( furthestDist === - Infinity ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// get the furthest hit point if needed\n\t\tray.at( Math.sqrt( furthestDist ), target );\n\t\treturn target;\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\tconst sphere = this.sphere;\n\t\tconst obb = this.obb || this.regionObb;\n\n\t\tlet sphereDistance = - Infinity;\n\t\tlet obbDistance = - Infinity;\n\n\t\tif ( sphere ) {\n\n\t\t\t// Sphere#distanceToPoint is negative inside the sphere, whereas Box3#distanceToPoint is\n\t\t\t// zero inside the box. Clipping the distance to a minimum of zero ensures that both\n\t\t\t// types of bounding volume behave the same way.\n\t\t\tsphereDistance = Math.max( sphere.distanceToPoint( point ), 0 );\n\n\t\t}\n\n\t\tif ( obb ) {\n\n\t\t\tobbDistance = obb.distanceToPoint( point );\n\n\t\t}\n\n\t\t// return the further distance of the two volumes\n\t\treturn sphereDistance > obbDistance ? sphereDistance : obbDistance;\n\n\t}\n\n\tintersectsFrustum( frustum ) {\n\n\t\tconst obb = this.obb || this.regionObb;\n\t\tconst sphere = this.sphere;\n\t\tif ( sphere && ! frustum.intersectsSphere( sphere ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( obb && ! obb.intersectsFrustum( frustum ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// if we don't have a sphere or obb then just say we did intersect\n\t\treturn Boolean( sphere || obb );\n\n\t}\n\n\tintersectsSphere( otherSphere ) {\n\n\t\tconst obb = this.obb || this.regionObb;\n\t\tconst sphere = this.sphere;\n\t\tif ( sphere && ! sphere.intersectsSphere( otherSphere ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( obb && ! obb.intersectsSphere( otherSphere ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn Boolean( sphere || obb );\n\n\t}\n\n\tintersectsOBB( otherObb ) {\n\n\t\tconst obb = this.obb || this.regionObb;\n\t\tconst sphere = this.sphere;\n\t\tif ( sphere && ! otherObb.intersectsSphere( sphere ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( obb && ! obb.intersectsOBB( otherObb ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn Boolean( sphere || obb );\n\n\t}\n\n\tgetOBB( targetBox, targetMatrix ) {\n\n\t\tconst obb = this.obb || this.regionObb;\n\t\tif ( obb ) {\n\n\t\t\ttargetBox.copy( obb.box );\n\t\t\ttargetMatrix.copy( obb.transform );\n\n\t\t} else {\n\n\t\t\tthis.getAABB( targetBox );\n\t\t\ttargetMatrix.identity();\n\n\t\t}\n\n\t}\n\n\tgetAABB( target ) {\n\n\t\tif ( this.sphere ) {\n\n\t\t\tthis.sphere.getBoundingBox( target );\n\n\t\t} else {\n\n\t\t\tconst obb = this.obb || this.regionObb;\n\t\t\ttarget.copy( obb.box ).applyMatrix4( obb.transform );\n\n\t\t}\n\n\t}\n\n\tgetSphere( target ) {\n\n\t\tif ( this.sphere ) {\n\n\t\t\ttarget.copy( this.sphere );\n\n\t\t} else if ( this.region ) {\n\n\t\t\tthis.region.getBoundingSphere( target );\n\n\t\t} else {\n\n\t\t\tconst obb = this.obb || this.regionObb;\n\t\t\tobb.box.getBoundingSphere( target );\n\t\t\ttarget.applyMatrix4( obb.transform );\n\n\t\t}\n\n\t}\n\n\tsetObbData( data, transform ) {\n\n\t\tconst obb = new OBB();\n\n\t\t// get the extents of the bounds in each axis\n\t\t_vecX.set( data[ 3 ], data[ 4 ], data[ 5 ] );\n\t\t_vecY.set( data[ 6 ], data[ 7 ], data[ 8 ] );\n\t\t_vecZ.set( data[ 9 ], data[ 10 ], data[ 11 ] );\n\n\t\tconst scaleX = _vecX.length();\n\t\tconst scaleY = _vecY.length();\n\t\tconst scaleZ = _vecZ.length();\n\n\t\t_vecX.normalize();\n\t\t_vecY.normalize();\n\t\t_vecZ.normalize();\n\n\t\t// handle the case where the box has a dimension of 0 in one axis\n\t\tif ( scaleX === 0 ) {\n\n\t\t\t_vecX.crossVectors( _vecY, _vecZ );\n\n\t\t}\n\n\t\tif ( scaleY === 0 ) {\n\n\t\t\t_vecY.crossVectors( _vecX, _vecZ );\n\n\t\t}\n\n\t\tif ( scaleZ === 0 ) {\n\n\t\t\t_vecZ.crossVectors( _vecX, _vecY );\n\n\t\t}\n\n\t\t// create the oriented frame that the box exists in\n\t\tobb.transform\n\t\t\t.set(\n\t\t\t\t_vecX.x, _vecY.x, _vecZ.x, data[ 0 ],\n\t\t\t\t_vecX.y, _vecY.y, _vecZ.y, data[ 1 ],\n\t\t\t\t_vecX.z, _vecY.z, _vecZ.z, data[ 2 ],\n\t\t\t\t0, 0, 0, 1\n\t\t\t)\n\t\t\t.premultiply( transform );\n\n\t\t// scale the box by the extents\n\t\tobb.box.min.set( - scaleX, - scaleY, - scaleZ );\n\t\tobb.box.max.set( scaleX, scaleY, scaleZ );\n\t\tobb.update();\n\t\tthis.obb = obb;\n\n\t}\n\n\tsetSphereData( x, y, z, radius, transform ) {\n\n\t\tconst sphere = new Sphere();\n\t\tsphere.center.set( x, y, z );\n\t\tsphere.radius = radius;\n\t\tsphere.applyMatrix4( transform );\n\t\tthis.sphere = sphere;\n\n\t}\n\n\tsetRegionData( ellipsoid, west, south, east, north, minHeight, maxHeight ) {\n\n\t\tconst region = new EllipsoidRegion(\n\t\t\t...ellipsoid.radius,\n\t\t\tsouth, north,\n\t\t\twest, east,\n\t\t\tminHeight, maxHeight,\n\t\t);\n\n\t\tconst obb = new OBB();\n\t\tregion.getBoundingBox( obb.box, obb.transform );\n\t\tobb.update();\n\n\t\tthis.region = region;\n\t\tthis.regionObb = obb;\n\n\t}\n\n}\n","import { Frustum, Matrix3, Vector3 } from 'three';\n\nconst _mat3 = new Matrix3();\n\n// Solve a system of equations to find the point where the three planes intersect\nfunction findIntersectionPoint( plane1, plane2, plane3, target ) {\n\n\t// Create the matrix A using the normals of the planes as rows\n\tconst A = _mat3.set(\n\t\tplane1.normal.x, plane1.normal.y, plane1.normal.z,\n\t\tplane2.normal.x, plane2.normal.y, plane2.normal.z,\n\t\tplane3.normal.x, plane3.normal.y, plane3.normal.z\n\t);\n\n\t// Create the vector B using the constants of the planes\n\ttarget.set( - plane1.constant, - plane2.constant, - plane3.constant );\n\n\t// Solve for X by applying the inverse matrix to B\n\ttarget.applyMatrix3( A.invert() );\n\n\treturn target;\n\n}\n\nclass ExtendedFrustum extends Frustum {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis.points = Array( 8 ).fill().map( () => new Vector3() );\n\n\t}\n\n\tsetFromProjectionMatrix( m, coordinateSystem ) {\n\n\t\tsuper.setFromProjectionMatrix( m, coordinateSystem );\n\t\tthis.calculateFrustumPoints();\n\t\treturn this;\n\n\t}\n\n\tcalculateFrustumPoints() {\n\n\t\tconst { planes, points } = this;\n\t\tconst planeIntersections = [\n\t\t\t[ planes[ 0 ], planes[ 3 ], planes[ 4 ] ], // Near top left\n\t\t\t[ planes[ 1 ], planes[ 3 ], planes[ 4 ] ], // Near top right\n\t\t\t[ planes[ 0 ], planes[ 2 ], planes[ 4 ] ], // Near bottom left\n\t\t\t[ planes[ 1 ], planes[ 2 ], planes[ 4 ] ], // Near bottom right\n\t\t\t[ planes[ 0 ], planes[ 3 ], planes[ 5 ] ], // Far top left\n\t\t\t[ planes[ 1 ], planes[ 3 ], planes[ 5 ] ], // Far top right\n\t\t\t[ planes[ 0 ], planes[ 2 ], planes[ 5 ] ], // Far bottom left\n\t\t\t[ planes[ 1 ], planes[ 2 ], planes[ 5 ] ], // Far bottom right\n\t\t];\n\n\t\tplaneIntersections.forEach( ( planes, index ) => {\n\n\t\t\tfindIntersectionPoint( planes[ 0 ], planes[ 1 ], planes[ 2 ], points[ index ] );\n\n\t\t} );\n\n\t}\n\n}\n\nexport { ExtendedFrustum };\n","import { estimateBytesUsed as _estimateBytesUsed } from 'three/examples/jsm/utils/BufferGeometryUtils.js';\nimport { TextureUtils } from 'three';\n\nexport function safeTextureGetByteLength( tex ) {\n\n\tconst { format, type, image } = tex;\n\tconst { width, height } = image;\n\n\tlet bytes = TextureUtils.getByteLength( width, height, format, type );\n\tbytes *= tex.generateMipmaps ? 4 / 3 : 1;\n\n\treturn bytes;\n\n}\n\n// Returns the estimated number of bytes used by the object\nexport function estimateBytesUsed( object ) {\n\n\tconst dedupeSet = new Set();\n\n\tlet totalBytes = 0;\n\tobject.traverse( c => {\n\n\t\t// get geometry bytes\n\t\tif ( c.geometry && ! dedupeSet.has( c.geometry ) ) {\n\n\t\t\ttotalBytes += _estimateBytesUsed( c.geometry );\n\t\t\tdedupeSet.add( c.geometry );\n\n\t\t}\n\n\t\t// get material bytes\n\t\tif ( c.material ) {\n\n\t\t\tconst material = c.material;\n\t\t\tfor ( const key in material ) {\n\n\t\t\t\tconst value = material[ key ];\n\t\t\t\tif ( value && value.isTexture && ! dedupeSet.has( value ) ) {\n\n\t\t\t\t\ttotalBytes += safeTextureGetByteLength( value );\n\t\t\t\t\tdedupeSet.add( value );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\treturn totalBytes;\n\n}\n","import { TilesRendererBase, LoaderUtils } from '3d-tiles-renderer/core';\nimport { B3DMLoader } from '../loaders/B3DMLoader.js';\nimport { PNTSLoader } from '../loaders/PNTSLoader.js';\nimport { I3DMLoader } from '../loaders/I3DMLoader.js';\nimport { CMPTLoader } from '../loaders/CMPTLoader.js';\nimport { TilesGroup } from './TilesGroup.js';\nimport {\n\tMatrix4,\n\tVector3,\n\tVector2,\n\tEuler,\n\tLoadingManager,\n\tEventDispatcher,\n\tGroup,\n} from 'three';\nimport { raycastTraverse, raycastTraverseFirstHit } from './raycastTraverse.js';\nimport { TileBoundingVolume } from '../math/TileBoundingVolume.js';\nimport { ExtendedFrustum } from '../math/ExtendedFrustum.js';\nimport { estimateBytesUsed } from '../utils/MemoryUtils.js';\nimport { WGS84_ELLIPSOID } from '../math/GeoConstants.js';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\n\nconst _mat = new Matrix4();\nconst _euler = new Euler();\n\n// In three.js r165 and higher raycast traversal can be ended early\nconst INITIAL_FRUSTUM_CULLED = Symbol( 'INITIAL_FRUSTUM_CULLED' );\nconst tempMat = new Matrix4();\nconst tempVector = new Vector3();\nconst tempVector2 = new Vector2();\nconst viewErrorTarget = {\n\tinView: false,\n\terror: Infinity,\n};\n\nconst X_AXIS = new Vector3( 1, 0, 0 );\nconst Y_AXIS = new Vector3( 0, 1, 0 );\n\nfunction updateFrustumCulled( object, toInitialValue ) {\n\n\tobject.traverse( c => {\n\n\t\tc.frustumCulled = c[ INITIAL_FRUSTUM_CULLED ] && toInitialValue;\n\n\t} );\n\n}\n\nexport class TilesRenderer extends TilesRendererBase {\n\n\tget autoDisableRendererCulling() {\n\n\t\treturn this._autoDisableRendererCulling;\n\n\t}\n\n\tset autoDisableRendererCulling( value ) {\n\n\t\tif ( this._autoDisableRendererCulling !== value ) {\n\n\t\t\tsuper._autoDisableRendererCulling = value;\n\t\t\tthis.forEachLoadedModel( ( scene ) => {\n\n\t\t\t\tupdateFrustumCulled( scene, ! value );\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\tget optimizeRaycast() {\n\n\t\treturn this._optimizeRaycast;\n\n\t}\n\n\tset optimizeRaycast( v ) {\n\n\t\tconsole.warn( 'TilesRenderer: The \"optimizeRaycast\" option has been deprecated.' );\n\t\tthis._optimizeRaycast = v;\n\n\t}\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\t\tthis.group = new TilesGroup( this );\n\t\tthis.ellipsoid = WGS84_ELLIPSOID.clone();\n\t\tthis.cameras = [];\n\t\tthis.cameraMap = new Map();\n\t\tthis.cameraInfo = [];\n\t\tthis._optimizeRaycast = true;\n\t\tthis._upRotationMatrix = new Matrix4();\n\t\tthis._bytesUsed = new WeakMap();\n\n\t\t// flag indicating whether frustum culling should be disabled\n\t\tthis._autoDisableRendererCulling = true;\n\n\t\tthis.manager = new LoadingManager();\n\n\t\t// saved for event dispatcher functions\n\t\tthis._listeners = {};\n\n\t}\n\n\taddEventListener( ...args ) {\n\n\t\tEventDispatcher.prototype.addEventListener.call( this, ...args );\n\n\t}\n\n\thasEventListener( ...args ) {\n\n\t\tEventDispatcher.prototype.hasEventListener.call( this, ...args );\n\n\t}\n\n\tremoveEventListener( ...args ) {\n\n\t\tEventDispatcher.prototype.removeEventListener.call( this, ...args );\n\n\t}\n\n\tdispatchEvent( ...args ) {\n\n\t\tEventDispatcher.prototype.dispatchEvent.call( this, ...args );\n\n\t}\n\n\t/* Public API */\n\tgetBoundingBox( target ) {\n\n\t\tif ( ! this.root ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst boundingVolume = this.root.cached.boundingVolume;\n\t\tif ( boundingVolume ) {\n\n\t\t\tboundingVolume.getAABB( target );\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\tgetOrientedBoundingBox( targetBox, targetMatrix ) {\n\n\t\tif ( ! this.root ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst boundingVolume = this.root.cached.boundingVolume;\n\t\tif ( boundingVolume ) {\n\n\t\t\tboundingVolume.getOBB( targetBox, targetMatrix );\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\tgetBoundingSphere( target ) {\n\n\t\tif ( ! this.root ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst boundingVolume = this.root.cached.boundingVolume;\n\t\tif ( boundingVolume ) {\n\n\t\t\tboundingVolume.getSphere( target );\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\tforEachLoadedModel( callback ) {\n\n\t\tthis.traverse( tile => {\n\n\t\t\tconst scene = tile.cached && tile.cached.scene;\n\t\t\tif ( scene ) {\n\n\t\t\t\tcallback( scene, tile );\n\n\t\t\t}\n\n\t\t}, null, false );\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tif ( ! this.root ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( raycaster.firstHitOnly ) {\n\n\t\t\tconst hit = raycastTraverseFirstHit( this, this.root, raycaster );\n\t\t\tif ( hit ) {\n\n\t\t\t\tintersects.push( hit );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\traycastTraverse( this, this.root, raycaster, intersects );\n\n\t\t}\n\n\t}\n\n\thasCamera( camera ) {\n\n\t\treturn this.cameraMap.has( camera );\n\n\t}\n\n\tsetCamera( camera ) {\n\n\t\tconst cameras = this.cameras;\n\t\tconst cameraMap = this.cameraMap;\n\t\tif ( ! cameraMap.has( camera ) ) {\n\n\t\t\tcameraMap.set( camera, new Vector2() );\n\t\t\tcameras.push( camera );\n\t\t\tthis.dispatchEvent( { type: 'add-camera', camera } );\n\n\t\t\treturn true;\n\n\t\t}\n\t\treturn false;\n\n\t}\n\n\tsetResolution( camera, xOrVec, y ) {\n\n\t\tconst cameraMap = this.cameraMap;\n\t\tif ( ! cameraMap.has( camera ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst width = xOrVec.isVector2 ? xOrVec.x : xOrVec;\n\t\tconst height = xOrVec.isVector2 ? xOrVec.y : y;\n\t\tconst cameraVec = cameraMap.get( camera );\n\n\t\tif ( cameraVec.width !== width || cameraVec.height !== height ) {\n\n\t\t\tcameraVec.set( width, height );\n\t\t\tthis.dispatchEvent( { type: 'camera-resolution-change' } );\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tsetResolutionFromRenderer( camera, renderer ) {\n\n\t\trenderer.getSize( tempVector2 );\n\n\t\treturn this.setResolution( camera, tempVector2.x, tempVector2.y );\n\n\t}\n\n\tdeleteCamera( camera ) {\n\n\t\tconst cameras = this.cameras;\n\t\tconst cameraMap = this.cameraMap;\n\t\tif ( cameraMap.has( camera ) ) {\n\n\t\t\tconst index = cameras.indexOf( camera );\n\t\t\tcameras.splice( index, 1 );\n\t\t\tcameraMap.delete( camera );\n\t\t\tthis.dispatchEvent( { type: 'delete-camera', camera } );\n\n\t\t\treturn true;\n\n\t\t}\n\t\treturn false;\n\n\t}\n\n\t/* Overriden */\n\tloadRootTileSet( ...args ) {\n\n\t\treturn super.loadRootTileSet( ...args )\n\t\t\t.then( root => {\n\n\t\t\t\t// cache the gltf tile set rotation matrix\n\t\t\t\tconst { asset, extensions = {} } = root;\n\t\t\t\tconst upAxis = asset && asset.gltfUpAxis || 'y';\n\t\t\t\tswitch ( upAxis.toLowerCase() ) {\n\n\t\t\t\t\tcase 'x':\n\t\t\t\t\t\tthis._upRotationMatrix.makeRotationAxis( Y_AXIS, - Math.PI / 2 );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'y':\n\t\t\t\t\t\tthis._upRotationMatrix.makeRotationAxis( X_AXIS, Math.PI / 2 );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// update the ellipsoid based on the extension\n\t\t\t\tif ( '3DTILES_ellipsoid' in extensions ) {\n\n\t\t\t\t\tconst ext = extensions[ '3DTILES_ellipsoid' ];\n\t\t\t\t\tconst { ellipsoid } = this;\n\t\t\t\t\tellipsoid.name = ext.body;\n\t\t\t\t\tif ( ext.radii ) {\n\n\t\t\t\t\t\tellipsoid.radius.set( ...ext.radii );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tellipsoid.radius.set( 1, 1, 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn root;\n\n\t\t\t} );\n\n\t}\n\n\tupdate() {\n\n\t\t// check if the plugins that can block the tile updates require it\n\t\tlet needsUpdate = null;\n\t\tthis.invokeAllPlugins( plugin => {\n\n\t\t\tif ( plugin.doTilesNeedUpdate ) {\n\n\t\t\t\tconst res = plugin.doTilesNeedUpdate();\n\t\t\t\tif ( needsUpdate === null ) {\n\n\t\t\t\t\tneedsUpdate = res;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tneedsUpdate = Boolean( needsUpdate || res );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( needsUpdate === false ) {\n\n\t\t\tthis.dispatchEvent( { type: 'update-before' } );\n\t\t\tthis.dispatchEvent( { type: 'update-after' } );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// follow through with the update\n\t\tthis.dispatchEvent( { type: 'update-before' } );\n\n\t\tconst group = this.group;\n\t\tconst cameras = this.cameras;\n\t\tconst cameraMap = this.cameraMap;\n\t\tconst cameraInfo = this.cameraInfo;\n\n\t\t// automatically scale the array of cameraInfo to match the cameras\n\t\twhile ( cameraInfo.length > cameras.length ) {\n\n\t\t\tcameraInfo.pop();\n\n\t\t}\n\n\t\twhile ( cameraInfo.length < cameras.length ) {\n\n\t\t\tcameraInfo.push( {\n\n\t\t\t\tfrustum: new ExtendedFrustum(),\n\t\t\t\tisOrthographic: false,\n\t\t\t\tsseDenominator: - 1, // used if isOrthographic:false\n\t\t\t\tposition: new Vector3(),\n\t\t\t\tinvScale: - 1,\n\t\t\t\tpixelSize: 0, // used if isOrthographic:true\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// extract scale of group container\n\t\ttempVector.setFromMatrixScale( group.matrixWorldInverse );\n\t\tif ( Math.abs( Math.max( tempVector.x - tempVector.y, tempVector.x - tempVector.z ) ) > 1e-6 ) {\n\n\t\t\tconsole.warn( 'ThreeTilesRenderer : Non uniform scale used for tile which may cause issues when calculating screen space error.' );\n\n\t\t}\n\n\t\t// store the camera cameraInfo in the 3d tiles root frame\n\t\tfor ( let i = 0, l = cameraInfo.length; i < l; i ++ ) {\n\n\t\t\tconst camera = cameras[ i ];\n\t\t\tconst info = cameraInfo[ i ];\n\t\t\tconst frustum = info.frustum;\n\t\t\tconst position = info.position;\n\t\t\tconst resolution = cameraMap.get( camera );\n\n\t\t\tif ( resolution.width === 0 || resolution.height === 0 ) {\n\n\t\t\t\tconsole.warn( 'TilesRenderer: resolution for camera error calculation is not set.' );\n\n\t\t\t}\n\n\t\t\t// Read the calculated projection matrix directly to support custom Camera implementations\n\t\t\tconst projection = camera.projectionMatrix.elements;\n\n\t\t\t// The last element of the projection matrix is 1 for orthographic, 0 for perspective\n\t\t\tinfo.isOrthographic = projection[ 15 ] === 1;\n\n\t\t\tif ( info.isOrthographic ) {\n\n\t\t\t\t// See OrthographicCamera.updateProjectionMatrix and Matrix4.makeOrthographic:\n\t\t\t\t// the view width and height are used to populate matrix elements 0 and 5.\n\t\t\t\tconst w = 2 / projection[ 0 ];\n\t\t\t\tconst h = 2 / projection[ 5 ];\n\t\t\t\tinfo.pixelSize = Math.max( h / resolution.height, w / resolution.width );\n\n\t\t\t} else {\n\n\t\t\t\t// See PerspectiveCamera.updateProjectionMatrix and Matrix4.makePerspective:\n\t\t\t\t// the vertical FOV is used to populate matrix element 5.\n\t\t\t\tinfo.sseDenominator = ( 2 / projection[ 5 ] ) / resolution.height;\n\n\t\t\t}\n\n\t\t\t// get frustum in group root frame\n\t\t\ttempMat.copy( group.matrixWorld );\n\t\t\ttempMat.premultiply( camera.matrixWorldInverse );\n\t\t\ttempMat.premultiply( camera.projectionMatrix );\n\n\t\t\tfrustum.setFromProjectionMatrix( tempMat );\n\n\t\t\t// get transform position in group root frame\n\t\t\tposition.set( 0, 0, 0 );\n\t\t\tposition.applyMatrix4( camera.matrixWorld );\n\t\t\tposition.applyMatrix4( group.matrixWorldInverse );\n\n\t\t}\n\n\t\tsuper.update();\n\n\t\tthis.dispatchEvent( { type: 'update-after' } );\n\n\t\t// check for cameras _after_ base update so we can enable pre-loading the root tile set\n\t\tif ( cameras.length === 0 && this.root ) {\n\n\t\t\tlet found = false;\n\t\t\tthis.invokeAllPlugins( plugin => found = found || Boolean( plugin !== this && plugin.calculateTileViewError ) );\n\t\t\tif ( found === false ) {\n\n\t\t\t\tconsole.warn( 'TilesRenderer: no cameras defined. Cannot update 3d tiles.' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tpreprocessNode( tile, tileSetDir, parentTile = null ) {\n\n\t\tsuper.preprocessNode( tile, tileSetDir, parentTile );\n\n\t\tconst transform = new Matrix4();\n\t\tif ( tile.transform ) {\n\n\t\t\tconst transformArr = tile.transform;\n\t\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\t\ttransform.elements[ i ] = transformArr[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( parentTile ) {\n\n\t\t\ttransform.premultiply( parentTile.cached.transform );\n\n\t\t}\n\n\t\tconst transformInverse = new Matrix4().copy( transform ).invert();\n\t\tconst boundingVolume = new TileBoundingVolume();\n\t\tif ( 'sphere' in tile.boundingVolume ) {\n\n\t\t\tboundingVolume.setSphereData( ...tile.boundingVolume.sphere, transform );\n\n\t\t}\n\n\t\tif ( 'box' in tile.boundingVolume ) {\n\n\t\t\tboundingVolume.setObbData( tile.boundingVolume.box, transform );\n\n\t\t}\n\n\t\tif ( 'region' in tile.boundingVolume ) {\n\n\t\t\tboundingVolume.setRegionData( this.ellipsoid, ...tile.boundingVolume.region );\n\n\t\t}\n\n\t\ttile.cached = {\n\n\t\t\ttransform,\n\t\t\ttransformInverse,\n\n\t\t\tactive: false,\n\n\t\t\tboundingVolume,\n\n\t\t\tmetadata: null,\n\t\t\tscene: null,\n\t\t\tgeometry: null,\n\t\t\tmaterials: null,\n\t\t\ttextures: null,\n\n\t\t};\n\n\t}\n\n\tasync parseTile( buffer, tile, extension, uri, abortSignal ) {\n\n\t\tconst cached = tile.cached;\n\t\tconst workingPath = LoaderUtils.getWorkingPath( uri );\n\t\tconst fetchOptions = this.fetchOptions;\n\n\t\tconst manager = this.manager;\n\t\tlet promise = null;\n\n\t\tconst cachedTransform = cached.transform;\n\t\tconst upRotationMatrix = this._upRotationMatrix;\n\t\tconst fileType = ( LoaderUtils.readMagicBytes( buffer ) || extension ).toLowerCase();\n\t\tswitch ( fileType ) {\n\n\t\t\tcase 'b3dm': {\n\n\t\t\t\tconst loader = new B3DMLoader( manager );\n\t\t\t\tloader.workingPath = workingPath;\n\t\t\t\tloader.fetchOptions = fetchOptions;\n\n\t\t\t\tloader.adjustmentTransform.copy( upRotationMatrix );\n\n\t\t\t\tpromise = loader.parse( buffer );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcase 'pnts': {\n\n\t\t\t\tconst loader = new PNTSLoader( manager );\n\t\t\t\tloader.workingPath = workingPath;\n\t\t\t\tloader.fetchOptions = fetchOptions;\n\t\t\t\tpromise = loader.parse( buffer );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcase 'i3dm': {\n\n\t\t\t\tconst loader = new I3DMLoader( manager );\n\t\t\t\tloader.workingPath = workingPath;\n\t\t\t\tloader.fetchOptions = fetchOptions;\n\n\t\t\t\tloader.adjustmentTransform.copy( upRotationMatrix );\n\t\t\t\tloader.ellipsoid.copy( this.ellipsoid );\n\n\t\t\t\tpromise = loader.parse( buffer );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcase 'cmpt': {\n\n\t\t\t\tconst loader = new CMPTLoader( manager );\n\t\t\t\tloader.workingPath = workingPath;\n\t\t\t\tloader.fetchOptions = fetchOptions;\n\n\t\t\t\tloader.adjustmentTransform.copy( upRotationMatrix );\n\t\t\t\tloader.ellipsoid.copy( this.ellipsoid );\n\n\t\t\t\tpromise = loader\n\t\t\t\t\t.parse( buffer )\n\t\t\t\t\t.then( res => res.scene\t);\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// 3DTILES_content_gltf\n\t\t\tcase 'gltf':\n\t\t\tcase 'glb': {\n\n\t\t\t\tconst loader = manager.getHandler( 'path.gltf' ) || manager.getHandler( 'path.glb' ) || new GLTFLoader( manager );\n\t\t\t\tloader.setWithCredentials( fetchOptions.credentials === 'include' );\n\t\t\t\tloader.setRequestHeader( fetchOptions.headers || {} );\n\t\t\t\tif ( fetchOptions.credentials === 'include' && fetchOptions.mode === 'cors' ) {\n\n\t\t\t\t\tloader.setCrossOrigin( 'use-credentials' );\n\n\t\t\t\t}\n\n\t\t\t\t// assume any pre-registered loader has paths configured as the user desires, but if we're making\n\t\t\t\t// a new loader, use the working path during parse to support relative uris on other hosts\n\t\t\t\tlet resourcePath = loader.resourcePath || loader.path || workingPath;\n\t\t\t\tif ( ! /[\\\\/]$/.test( resourcePath ) && resourcePath.length ) {\n\n\t\t\t\t\tresourcePath += '/';\n\n\t\t\t\t}\n\n\t\t\t\tpromise = loader.parseAsync( buffer, resourcePath ).then( result => {\n\n\t\t\t\t\t// glTF files are not guaranteed to include a scene object\n\t\t\t\t\tresult.scene = result.scene || new Group();\n\n\t\t\t\t\t// apply the local up-axis correction rotation\n\t\t\t\t\t// GLTFLoader seems to never set a transformation on the root scene object so\n\t\t\t\t\t// any transformations applied to it can be assumed to be applied after load\n\t\t\t\t\t// (such as applying RTC_CENTER) meaning they should happen _after_ the z-up\n\t\t\t\t\t// rotation fix which is why \"multiply\" happens here.\n\t\t\t\t\tconst { scene } = result;\n\t\t\t\t\tscene.updateMatrix();\n\t\t\t\t\tscene.matrix\n\t\t\t\t\t\t.multiply( upRotationMatrix )\n\t\t\t\t\t\t.decompose( scene.position, scene.quaternion, scene.scale );\n\n\t\t\t\t\treturn result;\n\n\t\t\t\t} );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tdefault: {\n\n\t\t\t\tpromise = this.invokeOnePlugin( plugin => plugin.parseToMesh && plugin.parseToMesh( buffer, tile, extension, uri, abortSignal ) );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// wait for the tile to load\n\t\tconst result = await promise;\n\t\tif ( result === null ) {\n\n\t\t\tthrow new Error( `TilesRenderer: Content type \"${ fileType }\" not supported.` );\n\n\t\t}\n\n\t\t// get the scene data\n\t\tlet scene;\n\t\tlet metadata;\n\t\tif ( result.isObject3D ) {\n\n\t\t\tscene = result;\n\t\t\tmetadata = null;\n\n\t\t} else {\n\n\t\t\tscene = result.scene;\n\t\t\tmetadata = result;\n\n\t\t}\n\n\t\t// ensure the matrix is up to date in case the scene has a transform applied\n\t\tscene.updateMatrix();\n\t\tscene.matrix.premultiply( cachedTransform );\n\t\tscene.matrix.decompose( scene.position, scene.quaternion, scene.scale );\n\n\t\t// wait for extra processing by plugins if needed\n\t\tawait this.invokeAllPlugins( plugin => {\n\n\t\t\treturn plugin.processTileModel && plugin.processTileModel( scene, tile );\n\n\t\t} );\n\n\t\t// frustum culling\n\t\tscene.traverse( c => {\n\n\t\t\tc[ INITIAL_FRUSTUM_CULLED ] = c.frustumCulled;\n\n\t\t} );\n\t\tupdateFrustumCulled( scene, ! this.autoDisableRendererCulling );\n\n\t\t// collect all original geometries, materials, etc to be disposed of later\n\t\tconst materials = [];\n\t\tconst geometry = [];\n\t\tconst textures = [];\n\t\tscene.traverse( c => {\n\n\t\t\tif ( c.geometry ) {\n\n\t\t\t\tgeometry.push( c.geometry );\n\n\t\t\t}\n\n\t\t\tif ( c.material ) {\n\n\t\t\t\tconst material = c.material;\n\t\t\t\tmaterials.push( c.material );\n\n\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\tconst value = material[ key ];\n\t\t\t\t\tif ( value && value.isTexture ) {\n\n\t\t\t\t\t\ttextures.push( value );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// exit early if a new request has already started\n\t\tif ( abortSignal.aborted ) {\n\n\t\t\t// dispose of any image bitmaps that have been opened.\n\t\t\t// TODO: share this code with the \"disposeTile\" code below, possibly allow for the tiles\n\t\t\t// renderer base to trigger a disposal of unneeded data\n\t\t\tfor ( let i = 0, l = textures.length; i < l; i ++ ) {\n\n\t\t\t\tconst texture = textures[ i ];\n\n\t\t\t\tif ( texture.image instanceof ImageBitmap ) {\n\n\t\t\t\t\ttexture.image.close();\n\n\t\t\t\t}\n\n\t\t\t\ttexture.dispose();\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tcached.materials = materials;\n\t\tcached.geometry = geometry;\n\t\tcached.textures = textures;\n\t\tcached.scene = scene;\n\t\tcached.metadata = metadata;\n\n\t}\n\n\tdisposeTile( tile ) {\n\n\t\tsuper.disposeTile( tile );\n\n\t\t// This could get called before the tile has finished downloading\n\t\tconst cached = tile.cached;\n\t\tif ( cached.scene ) {\n\n\t\t\tconst materials = cached.materials;\n\t\t\tconst geometry = cached.geometry;\n\t\t\tconst textures = cached.textures;\n\t\t\tconst parent = cached.scene.parent;\n\n\t\t\t// dispose of any textures required by the mesh features extension\n\t\t\t// TODO: these are being discarded here to remove the image bitmaps -\n\t\t\t// can this be handled in another way? Or more generically?\n\t\t\tcached.scene.traverse( child => {\n\n\t\t\t\tif ( child.userData.meshFeatures ) {\n\n\t\t\t\t\tchild.userData.meshFeatures.dispose();\n\n\t\t\t\t}\n\n\t\t\t\tif ( child.userData.structuralMetadata ) {\n\n\t\t\t\t\tchild.userData.structuralMetadata.dispose();\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tfor ( let i = 0, l = geometry.length; i < l; i ++ ) {\n\n\t\t\t\tgeometry[ i ].dispose();\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\t\tmaterials[ i ].dispose();\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, l = textures.length; i < l; i ++ ) {\n\n\t\t\t\tconst texture = textures[ i ];\n\n\t\t\t\tif ( texture.image instanceof ImageBitmap ) {\n\n\t\t\t\t\ttexture.image.close();\n\n\t\t\t\t}\n\n\t\t\t\ttexture.dispose();\n\n\t\t\t}\n\n\t\t\tif ( parent ) {\n\n\t\t\t\tparent.remove( cached.scene );\n\n\t\t\t}\n\n\t\t\tthis.dispatchEvent( {\n\t\t\t\ttype: 'dispose-model',\n\t\t\t\tscene: cached.scene,\n\t\t\t\ttile,\n\t\t\t} );\n\n\t\t\tcached.scene = null;\n\t\t\tcached.materials = null;\n\t\t\tcached.textures = null;\n\t\t\tcached.geometry = null;\n\t\t\tcached.metadata = null;\n\n\t\t}\n\n\t}\n\n\tsetTileVisible( tile, visible ) {\n\n\t\tconst scene = tile.cached.scene;\n\t\tconst group = this.group;\n\n\t\tif ( visible ) {\n\n\t\t\tif ( scene ) {\n\n\t\t\t\tgroup.add( scene );\n\t\t\t\tscene.updateMatrixWorld( true );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( scene ) {\n\n\t\t\t\tgroup.remove( scene );\n\n\t\t\t}\n\n\t\t}\n\n\t\tsuper.setTileVisible( tile, visible );\n\n\t\tthis.dispatchEvent( {\n\t\t\ttype: 'tile-visibility-change',\n\t\t\tscene,\n\t\t\ttile,\n\t\t\tvisible,\n\t\t} );\n\n\t}\n\n\tcalculateBytesUsed( tile, scene ) {\n\n\t\tconst bytesUsed = this._bytesUsed;\n\t\tif ( ! bytesUsed.has( tile ) && scene ) {\n\n\t\t\tbytesUsed.set( tile, estimateBytesUsed( scene ) );\n\n\t\t}\n\n\t\treturn bytesUsed.get( tile ) ?? null;\n\n\t}\n\n\tcalculateTileViewError( tile, target ) {\n\n\t\tconst cached = tile.cached;\n\t\tconst cameras = this.cameras;\n\t\tconst cameraInfo = this.cameraInfo;\n\t\tconst boundingVolume = cached.boundingVolume;\n\n\t\tlet inView = false;\n\t\tlet inViewError = - Infinity;\n\t\tlet inViewDistance = Infinity;\n\t\tlet maxError = - Infinity;\n\t\tlet minDistance = Infinity;\n\n\t\tfor ( let i = 0, l = cameras.length; i < l; i ++ ) {\n\n\t\t\t// calculate the camera error\n\t\t\tconst info = cameraInfo[ i ];\n\t\t\tlet error;\n\t\t\tlet distance;\n\t\t\tif ( info.isOrthographic ) {\n\n\t\t\t\tconst pixelSize = info.pixelSize;\n\t\t\t\terror = tile.geometricError / pixelSize;\n\t\t\t\tdistance = Infinity;\n\n\t\t\t} else {\n\n\t\t\t\t// avoid dividing 0 by 0 which can result in NaN. If the distance to the tile is\n\t\t\t\t// 0 then the error should be infinity.\n\t\t\t\tconst sseDenominator = info.sseDenominator;\n\t\t\t\tdistance = boundingVolume.distanceToPoint( info.position );\n\t\t\t\terror = distance === 0 ? Infinity : tile.geometricError / ( distance * sseDenominator );\n\n\t\t\t}\n\n\t\t\t// Track which camera frustums this tile is in so we can use it\n\t\t\t// to ignore the error calculations for cameras that can't see it\n\t\t\tconst frustum = cameraInfo[ i ].frustum;\n\t\t\tif ( boundingVolume.intersectsFrustum( frustum ) ) {\n\n\t\t\t\tinView = true;\n\t\t\t\tinViewError = Math.max( inViewError, error );\n\t\t\t\tinViewDistance = Math.min( inViewDistance, distance );\n\n\t\t\t}\n\n\t\t\tmaxError = Math.max( maxError, error );\n\t\t\tminDistance = Math.min( minDistance, distance );\n\n\t\t}\n\n\t\t// check the plugin visibility\n\t\tthis.invokeAllPlugins( plugin => {\n\n\t\t\tif ( plugin !== this && plugin.calculateTileViewError && plugin.calculateTileViewError( tile, viewErrorTarget ) ) {\n\n\t\t\t\t// Tile shall be traversed if inView for at least one plugin.\n\t\t\t\tinView = inView && viewErrorTarget.inView;\n\t\t\t\tmaxError = Math.max( maxError, viewErrorTarget.error );\n\n\t\t\t\tif ( viewErrorTarget.inView ) {\n\n\t\t\t\t\tinViewError = Math.max( inViewError, viewErrorTarget.error );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// If the tiles are out of view then use the global distance and error calculated\n\t\tif ( inView ) {\n\n\t\t\ttarget.inView = true;\n\t\t\ttarget.error = inViewError;\n\t\t\ttarget.distanceFromCamera = inViewDistance;\n\n\t\t} else {\n\n\t\t\ttarget.inView = viewErrorTarget.inView;\n\t\t\ttarget.error = maxError;\n\t\t\ttarget.distanceFromCamera = minDistance;\n\n\t\t}\n\n\t}\n\n\t// adjust the rotation of the group such that Y is altitude, X is North, and Z is East\n\tsetLatLonToYUp( lat, lon ) {\n\n\t\tconsole.warn( 'TilesRenderer: setLatLonToYUp is deprecated. Use the ReorientationPlugin, instead.' );\n\n\t\tconst { ellipsoid, group } = this;\n\n\t\t_euler.set( Math.PI / 2, Math.PI / 2, 0 );\n\t\t_mat.makeRotationFromEuler( _euler );\n\n\t\tellipsoid.getEastNorthUpFrame( lat, lon, 0, group.matrix )\n\t\t\t.multiply( _mat )\n\t\t\t.invert()\n\t\t\t.decompose(\n\t\t\t\tgroup.position,\n\t\t\t\tgroup.quaternion,\n\t\t\t\tgroup.scale,\n\t\t\t);\n\n\t\tgroup.updateMatrixWorld( true );\n\n\t}\n\n\tdispose() {\n\n\t\tsuper.dispose();\n\t\tthis.group.removeFromParent();\n\n\t}\n\n}\n"],"names":["getUrlExtension","url","endIndex","queryIndex","fragmentIndex","lastPeriodIndex","lastSlashIndex","protocolIndex","GIGABYTE_BYTES","LRUCache","cb","a","b","valA","valB","itemSet","item","bytes","bytesMap","removeCb","usedSet","itemList","callbacks","loadedSet","index","value","unloadPercent","minSize","maxSize","minBytesSize","maxBytesSize","unused","unloaded","excessNodes","excessBytes","unloadPriorityCallback","needsRerun","hasNodesToUnload","usedA","usedB","loadedA","loadedB","maxUnload","nodesToUnload","maxBytesUnload","bytesToUnload","removedNodes","removedBytes","PriorityQueue","func","priorityCallback","items","callback","data","resolve","reject","info","filter","i","maxJobs","iterated","completedCallback","result","err","viewErrorTarget","LOAD_ROOT_SIBLINGS","isDownloadFinished","LOADED","FAILED","isUsedThisFrame","tile","frameCount","areChildrenProcessed","resetFrameState","renderer","recursivelyMarkUsed","markUsed","children","l","recursivelyLoadNextRenderableTiles","canTraverse","markUsedTiles","anyChildrenUsed","anyChildrenInFrustum","c","markUsedSetLeaves","allChildrenLoaded","childLoaded","markVisibleTiles","stats","hasContent","loadedContent","errorRequirement","meetsSSE","isAdditiveRefine","toggleTiles","isUsed","setActive","setVisible","plugin","throttle","handle","traverseSet","beforeCb","afterCb","stack","depth","parent","traverseAncestors","current","PLUGIN_REGISTERED","aPriority","bPriority","lruPriorityCallback","TilesRendererBase","tileSet","isLoading","loading","total","v","UNLOADED","lruCache","downloadQueue","parseQueue","processNodeQueue","plugins","priority","insertionPoint","name","p","beforecb","aftercb","ensureFullyProcessed","args","root","LOADING","processedUrl","error","queuedTiles","toRemove","t","scene","options","buffer","extension","tileSetDir","parentTile","_a","active","visible","target","immediate","child","processedTiles","json","version","major","minor","basePath","res","isExternalTileSet","externalTileset","uri","controller","signal","PARSING","downloadTile","content","parseTile","bytesUsed","pending","tempMat","Matrix4","TilesGroup","Group","tilesRenderer","raycaster","intersects","force","elA","elB","isDifferent","itemA","itemB","updateParents","updateChildren","_localRay","Ray","_vec","Vector3","_hitArray","distanceSort","intersectTileScene","intersectTileSceneFirstHist","hit","isTileInitialized","raycastTraverseFirstHit","localRay","group","activeTiles","array","bestHit","bestHitDistSq","boundingVolumeDistSq","hitDistSq","raycastTraverse","boundingVolume","_worldMin","_worldMax","_norm","_ray","OBB","box","Box3","transform","Plane","source","point","ray","points","inverseTransform","min","max","x","y","z","sphere","frustum","obb","otherPlanes","otherPoints","thisPoints","thisPlanes","plane","maxDistance","j","dist","_vecX","_vecY","_vecZ","_sphereVec","_obbVec","TileBoundingVolume","sphereDistSq","obbDistSq","furthestDist","sphereDistance","obbDistance","otherSphere","otherObb","targetBox","targetMatrix","scaleX","scaleY","scaleZ","radius","Sphere","ellipsoid","west","south","east","north","minHeight","maxHeight","region","EllipsoidRegion","_mat3","Matrix3","findIntersectionPoint","plane1","plane2","plane3","A","ExtendedFrustum","Frustum","m","coordinateSystem","planes","safeTextureGetByteLength","tex","format","type","image","width","height","TextureUtils","estimateBytesUsed","object","dedupeSet","totalBytes","_estimateBytesUsed","material","key","_mat","_euler","Euler","INITIAL_FRUSTUM_CULLED","tempVector","tempVector2","Vector2","X_AXIS","Y_AXIS","updateFrustumCulled","toInitialValue","TilesRenderer","WGS84_ELLIPSOID","LoadingManager","EventDispatcher","camera","cameras","cameraMap","xOrVec","cameraVec","asset","extensions","ext","needsUpdate","cameraInfo","position","resolution","projection","w","h","found","transformArr","transformInverse","abortSignal","cached","workingPath","LoaderUtils.getWorkingPath","fetchOptions","manager","promise","cachedTransform","upRotationMatrix","fileType","LoaderUtils.readMagicBytes","loader","B3DMLoader","PNTSLoader","I3DMLoader","CMPTLoader","GLTFLoader","resourcePath","metadata","materials","geometry","textures","texture","inView","inViewError","inViewDistance","maxError","minDistance","distance","pixelSize","sseDenominator","lat","lon"],"mappings":"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"}