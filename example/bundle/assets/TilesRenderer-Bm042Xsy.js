import{T as se}from"./TilesRendererBase-CFsQu8zV.js";import{g as ne,r as ie}from"./BatchTable-CRr3zuRk.js";import{B as re}from"./B3DMLoader-Cnf0ja_2.js";import{P as oe}from"./PNTSLoader-DwvZQNdL.js";import{W as ae,I as le}from"./I3DMLoader-BWluRuWb.js";import{C as ce}from"./CMPTLoader-BOTrymv0.js";import{G,n as R,ah as X,o as f,B as ue,av as he,d as pe,bH as me,aS as de,T as fe,b9 as ge,aQ as O,V as Y,aP as be}from"./three.module-D-uF--xd.js";import{E as xe}from"./EllipsoidRegion-VNvPMw5b.js";import{e as ye,G as we}from"./GLTFLoader-B4GrkiON.js";const B=new R;class Me extends G{constructor(e){super(),this.isTilesGroup=!0,this.name="TilesRenderer.TilesGroup",this.tilesRenderer=e,this.matrixWorldInverse=new R}raycast(e,t){return this.tilesRenderer.optimizeRaycast?(this.tilesRenderer.raycast(e,t),!1):!0}updateMatrixWorld(e){if(this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldNeedsUpdate||e){this.parent===null?B.copy(this.matrix):B.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1;const t=B.elements,s=this.matrixWorld.elements;let n=!1;for(let o=0;o<16;o++){const i=t[o],r=s[o];if(Math.abs(i-r)>Number.EPSILON){n=!0;break}}if(n){this.matrixWorld.copy(B),this.matrixWorldInverse.copy(B).invert();const o=this.children;for(let i=0,r=o.length;i<r;i++)o[i].updateMatrixWorld()}}}updateWorldMatrix(e,t){this.parent&&e&&this.parent.updateWorldMatrix(e,!1),this.updateMatrixWorld(!0)}}const $=new X,W=new f,C=[];function Z(h,e){return h.distance-e.distance}function Q(h,e,t,s){const{scene:n}=h.engineData;t.invokeOnePlugin(i=>i.raycastTile&&i.raycastTile(h,n,e,s))||e.intersectObject(n,!0,s)}function Te(h,e,t){Q(h,e,t,C),C.sort(Z);const s=C[0]||null;return C.length=0,s}function J(h){return"traversal"in h}function K(h,e,t,s=null){const{group:n,activeTiles:o}=h;s===null&&(s=$,s.copy(t.ray).applyMatrix4(n.matrixWorldInverse));const i=[],r=e.children;for(let c=0,d=r.length;c<d;c++){const m=r[c];if(!J(m)||!m.traversal.used)continue;m.engineData.boundingVolume.intersectRay(s,W)!==null&&(W.applyMatrix4(n.matrixWorld),i.push({distance:W.distanceToSquared(t.ray.origin),tile:m}))}i.sort(Z);let a=null,u=1/0;if(o.has(e)){const c=Te(e,t,h);c&&(a=c,u=c.distance*c.distance)}for(let c=0,d=i.length;c<d;c++){const m=i[c],M=m.distance,g=m.tile;if(M>u)break;const p=K(h,g,t,s);if(p){const x=p.distance*p.distance;x<u&&(a=p,u=x)}}return a}function ee(h,e,t,s,n=null){if(!J(e))return;const{group:o,activeTiles:i}=h,{boundingVolume:r}=e.engineData;if(n===null&&(n=$,n.copy(t.ray).applyMatrix4(o.matrixWorldInverse)),!e.traversal.used||!r.intersectsRay(n))return;i.has(e)&&Q(e,t,h,s);const a=e.children;for(let u=0,c=a.length;u<c;u++)ee(h,a[u],t,s,n)}const E=new f,L=new f,b=new f,A=new X;class z{constructor(e=new ue,t=new R){this.box=e.clone(),this.transform=t.clone(),this.inverseTransform=new R,this.points=new Array(8).fill().map(()=>new f),this.planes=new Array(6).fill().map(()=>new he)}copy(e){return this.box.copy(e.box),this.transform.copy(e.transform),this.update(),this}clone(){return new this.constructor().copy(this)}clampPoint(e,t){return t.copy(e).applyMatrix4(this.inverseTransform).clamp(this.box.min,this.box.max).applyMatrix4(this.transform)}distanceToPoint(e){return this.clampPoint(e,b).distanceTo(e)}containsPoint(e){return b.copy(e).applyMatrix4(this.inverseTransform),this.box.containsPoint(b)}intersectsRay(e){return A.copy(e).applyMatrix4(this.inverseTransform),A.intersectsBox(this.box)}intersectRay(e,t){return A.copy(e).applyMatrix4(this.inverseTransform),A.intersectBox(this.box,t)?(t.applyMatrix4(this.transform),t):null}update(){const{points:e,inverseTransform:t,transform:s,box:n}=this;t.copy(s).invert();const{min:o,max:i}=n;let r=0;for(let a=-1;a<=1;a+=2)for(let u=-1;u<=1;u+=2)for(let c=-1;c<=1;c+=2)e[r].set(a<0?o.x:i.x,u<0?o.y:i.y,c<0?o.z:i.z).applyMatrix4(s),r++;this.updatePlanes()}updatePlanes(){E.copy(this.box.min).applyMatrix4(this.transform),L.copy(this.box.max).applyMatrix4(this.transform),b.set(0,0,1).transformDirection(this.transform),this.planes[0].setFromNormalAndCoplanarPoint(b,E),this.planes[1].setFromNormalAndCoplanarPoint(b,L).negate(),b.set(0,1,0).transformDirection(this.transform),this.planes[2].setFromNormalAndCoplanarPoint(b,E),this.planes[3].setFromNormalAndCoplanarPoint(b,L).negate(),b.set(1,0,0).transformDirection(this.transform),this.planes[4].setFromNormalAndCoplanarPoint(b,E),this.planes[5].setFromNormalAndCoplanarPoint(b,L).negate()}intersectsSphere(e){return this.clampPoint(e.center,b),b.distanceToSquared(e.center)<=e.radius*e.radius}intersectsFrustum(e){return this._intersectsPlaneShape(e.planes,e.points)}intersectsOBB(e){return this._intersectsPlaneShape(e.planes,e.points)}_intersectsPlaneShape(e,t){const s=this.points,n=this.planes;for(let o=0;o<6;o++){const i=e[o];let r=-1/0;for(let a=0;a<8;a++){const u=s[a],c=i.distanceToPoint(u);r=r<c?c:r}if(r<0)return!1}for(let o=0;o<6;o++){const i=n[o];let r=-1/0;for(let a=0;a<8;a++){const u=t[a],c=i.distanceToPoint(u);r=r<c?c:r}if(r<0)return!1}return!0}}const D=new f,v=new f,P=new f,U=new f,N=new f;class De{constructor(){this.sphere=null,this.obb=null,this.region=null,this.regionObb=null}intersectsRay(e){const t=this.sphere,s=this.obb||this.regionObb;return!(t&&!e.intersectsSphere(t)||s&&!s.intersectsRay(e))}intersectRay(e,t=null){const s=this.sphere,n=this.obb||this.regionObb;let o=-1/0,i=-1/0;s&&e.intersectSphere(s,U)&&(o=s.containsPoint(e.origin)?0:e.origin.distanceToSquared(U)),n&&n.intersectRay(e,N)&&(i=n.containsPoint(e.origin)?0:e.origin.distanceToSquared(N));const r=Math.max(o,i);return r===-1/0?null:(e.at(Math.sqrt(r),t),t)}distanceToPoint(e){const t=this.sphere,s=this.obb||this.regionObb;let n=-1/0,o=-1/0;return t&&(n=Math.max(t.distanceToPoint(e),0)),s&&(o=s.distanceToPoint(e)),n>o?n:o}intersectsFrustum(e){const t=this.obb||this.regionObb,s=this.sphere;return s&&!e.intersectsSphere(s)||t&&!t.intersectsFrustum(e)?!1:!!(s||t)}intersectsSphere(e){const t=this.obb||this.regionObb,s=this.sphere;return s&&!s.intersectsSphere(e)||t&&!t.intersectsSphere(e)?!1:!!(s||t)}intersectsOBB(e){const t=this.obb||this.regionObb,s=this.sphere;return s&&!e.intersectsSphere(s)||t&&!t.intersectsOBB(e)?!1:!!(s||t)}getOBB(e,t){const s=this.obb||this.regionObb;s?(e.copy(s.box),t.copy(s.transform)):(this.getAABB(e),t.identity())}getAABB(e){if(this.sphere)this.sphere.getBoundingBox(e);else{const t=this.obb||this.regionObb;e.copy(t.box).applyMatrix4(t.transform)}}getSphere(e){if(this.sphere)e.copy(this.sphere);else if(this.region)this.region.getBoundingSphere(e);else{const t=this.obb||this.regionObb;t.box.getBoundingSphere(e),e.applyMatrix4(t.transform)}}setObbData(e,t){const s=new z;D.set(e[3],e[4],e[5]),v.set(e[6],e[7],e[8]),P.set(e[9],e[10],e[11]);const n=D.length(),o=v.length(),i=P.length();D.normalize(),v.normalize(),P.normalize(),n===0&&D.crossVectors(v,P),o===0&&v.crossVectors(D,P),i===0&&P.crossVectors(D,v),s.transform.set(D.x,v.x,P.x,e[0],D.y,v.y,P.y,e[1],D.z,v.z,P.z,e[2],0,0,0,1).premultiply(t),s.box.min.set(-n,-o,-i),s.box.max.set(n,o,i),s.update(),this.obb=s}setSphereData(e,t,s,n,o){const i=new pe;i.center.set(e,t,s),i.radius=n,i.applyMatrix4(o),this.sphere=i}setRegionData(e,t,s,n,o,i,r){const a=new xe(...e.radius,s,o,t,n,i,r),u=new z;a.getBoundingBox(u.box,u.transform),u.update(),this.region=a,this.regionObb=u}}const ve=new de;function Pe(h,e,t,s){const n=ve.set(h.normal.x,h.normal.y,h.normal.z,e.normal.x,e.normal.y,e.normal.z,t.normal.x,t.normal.y,t.normal.z);return s.set(-h.constant,-e.constant,-t.constant),s.applyMatrix3(n.invert()),s}class Re extends me{constructor(){super(),this.points=Array(8).fill().map(()=>new f)}setFromProjectionMatrix(e,t){return super.setFromProjectionMatrix(e,t),this.calculateFrustumPoints(),this}calculateFrustumPoints(){const{planes:e,points:t}=this;[[e[0],e[3],e[4]],[e[1],e[3],e[4]],[e[0],e[2],e[4]],[e[1],e[2],e[4]],[e[0],e[3],e[5]],[e[1],e[3],e[5]],[e[0],e[2],e[5]],[e[1],e[2],e[5]]].forEach((n,o)=>{Pe(n[0],n[1],n[2],t[o])})}}function Se(h){if(!h)return 0;const{format:e,type:t,image:s}=h,{width:n,height:o}=s;let i=fe.getByteLength(n,o,e,t);return i*=h.generateMipmaps?4/3:1,i}function Be(h){const e=new Set;let t=0;return h.traverse(s=>{if(s.geometry&&!e.has(s.geometry)&&(t+=ye(s.geometry),e.add(s.geometry)),s.material){const n=s.material;for(const o in n){const i=n[o];i&&i.isTexture&&!e.has(i)&&(t+=Se(i),e.add(i))}}}),t}const j=new R,q=new be,te=Symbol("INITIAL_FRUSTUM_CULLED"),F=new R,I=new f,k=new Y,Ie=new f(1,0,0),_e=new f(0,1,0);function H(h,e){h.traverse(t=>{t.frustumCulled=t[te]&&e})}class ze extends se{get autoDisableRendererCulling(){return this._autoDisableRendererCulling}set autoDisableRendererCulling(e){this._autoDisableRendererCulling!==e&&(super._autoDisableRendererCulling=e,this.forEachLoadedModel(t=>{H(t,!e)}))}get optimizeRaycast(){return this._optimizeRaycast}set optimizeRaycast(e){console.warn('TilesRenderer: The "optimizeRaycast" option has been deprecated.'),this._optimizeRaycast=e}constructor(...e){super(...e),this.group=new Me(this),this.ellipsoid=ae.clone(),this.cameras=[],this.cameraMap=new Map,this.cameraInfo=[],this._optimizeRaycast=!0,this._upRotationMatrix=new R,this._bytesUsed=new WeakMap,this._autoDisableRendererCulling=!0,this.manager=new ge,this._listeners={}}addEventListener(e,t){e==="load-tile-set"&&(console.warn('TilesRenderer: "load-tile-set" event has been deprecated. Use "load-tileset" instead.'),e="load-tileset"),O.prototype.addEventListener.call(this,e,t)}hasEventListener(e,t){return e==="load-tile-set"&&(console.warn('TilesRenderer: "load-tile-set" event has been deprecated. Use "load-tileset" instead.'),e="load-tileset"),O.prototype.hasEventListener.call(this,e,t)}removeEventListener(e,t){e==="load-tile-set"&&(console.warn('TilesRenderer: "load-tile-set" event has been deprecated. Use "load-tileset" instead.'),e="load-tileset"),O.prototype.removeEventListener.call(this,e,t)}dispatchEvent(e){"tileset"in e&&Object.defineProperty(e,"tileSet",{get(){return console.warn('TilesRenderer: "event.tileSet" has been deprecated. Use "event.tileset" instead.'),e.tileset},enumerable:!1,configurable:!0}),O.prototype.dispatchEvent.call(this,e)}getBoundingBox(e){if(!this.root)return!1;const t=this.root.engineData.boundingVolume;return t?(t.getAABB(e),!0):!1}getOrientedBoundingBox(e,t){if(!this.root)return!1;const s=this.root.engineData.boundingVolume;return s?(s.getOBB(e,t),!0):!1}getBoundingSphere(e){if(!this.root)return!1;const t=this.root.engineData.boundingVolume;return t?(t.getSphere(e),!0):!1}forEachLoadedModel(e){this.traverse(t=>{const s=t.engineData&&t.engineData.scene;s&&e(s,t)},null,!1)}raycast(e,t){if(this.root)if(e.firstHitOnly){const s=K(this,this.root,e);s&&t.push(s)}else ee(this,this.root,e,t)}hasCamera(e){return this.cameraMap.has(e)}setCamera(e){const t=this.cameras,s=this.cameraMap;return s.has(e)?!1:(s.set(e,new Y),t.push(e),this.dispatchEvent({type:"add-camera",camera:e}),!0)}setResolution(e,t,s){const n=this.cameraMap;if(!n.has(e))return!1;const o=t.isVector2?t.x:t,i=t.isVector2?t.y:s,r=n.get(e);return(r.width!==o||r.height!==i)&&(r.set(o,i),this.dispatchEvent({type:"camera-resolution-change"})),!0}setResolutionFromRenderer(e,t){return t.getSize(k),this.setResolution(e,k.x,k.y)}deleteCamera(e){const t=this.cameras,s=this.cameraMap;if(s.has(e)){const n=t.indexOf(e);return t.splice(n,1),s.delete(e),this.dispatchEvent({type:"delete-camera",camera:e}),!0}return!1}loadRootTileset(...e){return super.loadRootTileset(...e).then(t=>{const{asset:s,extensions:n={}}=t;switch((s&&s.gltfUpAxis||"y").toLowerCase()){case"x":this._upRotationMatrix.makeRotationAxis(_e,-Math.PI/2);break;case"y":this._upRotationMatrix.makeRotationAxis(Ie,Math.PI/2);break}if("3DTILES_ellipsoid"in n){const i=n["3DTILES_ellipsoid"],{ellipsoid:r}=this;r.name=i.body,i.radii?r.radius.set(...i.radii):r.radius.set(1,1,1)}return t})}prepareForTraversal(){const e=this.group,t=this.cameras,s=this.cameraMap,n=this.cameraInfo;for(;n.length>t.length;)n.pop();for(;n.length<t.length;)n.push({frustum:new Re,isOrthographic:!1,sseDenominator:-1,position:new f,invScale:-1,pixelSize:0});I.setFromMatrixScale(e.matrixWorldInverse),Math.abs(Math.max(I.x-I.y,I.x-I.z))>1e-6&&console.warn("ThreeTilesRenderer : Non uniform scale used for tile which may cause issues when calculating screen space error.");for(let o=0,i=n.length;o<i;o++){const r=t[o],a=n[o],u=a.frustum,c=a.position,d=s.get(r);(d.width===0||d.height===0)&&console.warn("TilesRenderer: resolution for camera error calculation is not set.");const m=r.projectionMatrix.elements;if(a.isOrthographic=m[15]===1,a.isOrthographic){const M=2/m[0],g=2/m[5];a.pixelSize=Math.max(g/d.height,M/d.width)}else a.sseDenominator=2/m[5]/d.height;F.copy(e.matrixWorld),F.premultiply(r.matrixWorldInverse),F.premultiply(r.projectionMatrix),u.setFromProjectionMatrix(F),c.set(0,0,0),c.applyMatrix4(r.matrixWorld),c.applyMatrix4(e.matrixWorldInverse)}}update(){if(super.update(),this.cameras.length===0&&this.root){let e=!1;this.invokeAllPlugins(t=>e=e||!!(t!==this&&t.calculateTileViewError)),e===!1&&console.warn("TilesRenderer: no cameras defined. Cannot update 3d tiles.")}}preprocessNode(e,t,s=null){super.preprocessNode(e,t,s);const n=new R;if(e.transform){const r=e.transform;for(let a=0;a<16;a++)n.elements[a]=r[a]}s&&n.premultiply(s.engineData.transform);const o=new R().copy(n).invert(),i=new De;"sphere"in e.boundingVolume&&i.setSphereData(...e.boundingVolume.sphere,n),"box"in e.boundingVolume&&i.setObbData(e.boundingVolume.box,n),"region"in e.boundingVolume&&i.setRegionData(this.ellipsoid,...e.boundingVolume.region),e.engineData.transform=n,e.engineData.transformInverse=o,e.engineData.boundingVolume=i,e.engineData.geometry=null,e.engineData.materials=null,e.engineData.textures=null}async parseTile(e,t,s,n,o){const i=t.engineData,r=ne(n),a=this.fetchOptions,u=this.manager;let c=null;const d=i.transform,m=this._upRotationMatrix,M=(ie(e)||s).toLowerCase();switch(M){case"b3dm":{const l=new re(u);l.workingPath=r,l.fetchOptions=a,l.adjustmentTransform.copy(m),c=l.parse(e);break}case"pnts":{const l=new oe(u);l.workingPath=r,l.fetchOptions=a,c=l.parse(e);break}case"i3dm":{const l=new le(u);l.workingPath=r,l.fetchOptions=a,l.adjustmentTransform.copy(m),l.ellipsoid.copy(this.ellipsoid),c=l.parse(e);break}case"cmpt":{const l=new ce(u);l.workingPath=r,l.fetchOptions=a,l.adjustmentTransform.copy(m),l.ellipsoid.copy(this.ellipsoid),c=l.parse(e).then(y=>y.scene);break}case"gltf":case"glb":{const l=u.getHandler("path.gltf")||u.getHandler("path.glb")||new we(u);l.setWithCredentials(a.credentials==="include"),l.setRequestHeader(a.headers||{}),a.credentials==="include"&&a.mode==="cors"&&l.setCrossOrigin("use-credentials");let y=l.resourcePath||l.path||r;!/[\\/]$/.test(y)&&y.length&&(y+="/"),c=l.parseAsync(e,y).then(w=>{w.scene=w.scene||new G;const{scene:T}=w;return T.updateMatrix(),T.matrix.multiply(m).decompose(T.position,T.quaternion,T.scale),w});break}default:{c=this.invokeOnePlugin(l=>l.parseToMesh&&l.parseToMesh(e,t,s,n,o));break}}const g=await c;if(g===null)throw new Error(`TilesRenderer: Content type "${M}" not supported.`);let p,x;g.isObject3D?(p=g,x=null):(p=g.scene,x=g),p.updateMatrix(),p.matrix.premultiply(d),p.matrix.decompose(p.position,p.quaternion,p.scale),await this.invokeAllPlugins(l=>l.processTileModel&&l.processTileModel(p,t)),p.traverse(l=>{l[te]=l.frustumCulled}),H(p,!this.autoDisableRendererCulling);const _=[],S=[],V=[];if(p.traverse(l=>{if(l.geometry&&S.push(l.geometry),l.material){const y=l.material;_.push(l.material);for(const w in y){const T=y[w];T&&T.isTexture&&V.push(T)}}}),o.aborted){for(let l=0,y=V.length;l<y;l++){const w=V[l];w.image instanceof ImageBitmap&&w.image.close(),w.dispose()}return}i.materials=_,i.geometry=S,i.textures=V,i.scene=p,i.metadata=x}disposeTile(e){super.disposeTile(e);const t=e.engineData;if(t.scene){const s=t.materials,n=t.geometry,o=t.textures,i=t.scene.parent;t.scene.traverse(r=>{r.userData.meshFeatures&&r.userData.meshFeatures.dispose(),r.userData.structuralMetadata&&r.userData.structuralMetadata.dispose()});for(let r=0,a=n.length;r<a;r++)n[r].dispose();for(let r=0,a=s.length;r<a;r++)s[r].dispose();for(let r=0,a=o.length;r<a;r++){const u=o[r];u.image instanceof ImageBitmap&&u.image.close(),u.dispose()}i&&i.remove(t.scene),t.scene=null,t.materials=null,t.textures=null,t.geometry=null,t.metadata=null}}setTileVisible(e,t){const s=e.engineData.scene,n=this.group;t?s&&(n.add(s),s.updateMatrixWorld(!0)):s&&n.remove(s),super.setTileVisible(e,t)}calculateBytesUsed(e,t){const s=this._bytesUsed;return!s.has(e)&&t&&s.set(e,Be(t)),s.get(e)??null}calculateTileViewError(e,t){const s=e.engineData,n=this.cameras,o=this.cameraInfo,i=s.boundingVolume;let r=!1,a=0,u=1/0,c=0,d=1/0;for(let m=0,M=n.length;m<M;m++){const g=o[m];let p,x;if(g.isOrthographic){const S=g.pixelSize;p=e.geometricError/S,x=1/0}else{const S=g.sseDenominator;x=i.distanceToPoint(g.position),p=x===0?1/0:e.geometricError/(x*S)}const _=o[m].frustum;i.intersectsFrustum(_)&&(r=!0,a=Math.max(a,p),u=Math.min(u,x)),c=Math.max(c,p),d=Math.min(d,x)}r?(t.inView=!0,t.error=a,t.distanceFromCamera=u):(t.inView=!1,t.error=c,t.distanceFromCamera=d)}setLatLonToYUp(e,t){console.warn("TilesRenderer: setLatLonToYUp is deprecated. Use the ReorientationPlugin, instead.");const{ellipsoid:s,group:n}=this;q.set(Math.PI/2,Math.PI/2,0),j.makeRotationFromEuler(q),s.getEastNorthUpFrame(e,t,0,n.matrix).multiply(j).invert().decompose(n.position,n.quaternion,n.scale),n.updateMatrixWorld(!0)}dispose(){super.dispose(),this.group.removeFromParent()}}export{z as O,ze as T,Se as g};
//# sourceMappingURL=TilesRenderer-Bm042Xsy.js.map
