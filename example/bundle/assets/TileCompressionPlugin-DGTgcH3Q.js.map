{"version":3,"file":"TileCompressionPlugin-DGTgcH3Q.js","sources":["../../../src/three/plugins/TileCompressionPlugin.js"],"sourcesContent":["import { Vector3, LinearFilter, BufferAttribute, MathUtils } from 'three';\n\nconst _vec = new Vector3();\nfunction compressAttribute( attribute, arrayType ) {\n\n\tif ( attribute.isInterleavedBufferAttribute || attribute.array instanceof arrayType ) {\n\n\t\treturn attribute;\n\n\t}\n\n\tconst signed = arrayType === Int8Array || arrayType === Int16Array || arrayType === Int32Array;\n\tconst minValue = signed ? - 1 : 0;\n\n\tconst array = new arrayType( attribute.count * attribute.itemSize );\n\tconst newAttribute = new BufferAttribute( array, attribute.itemSize, true );\n\tconst itemSize = attribute.itemSize;\n\tconst count = attribute.count;\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\tconst v = MathUtils.clamp( attribute.getComponent( i, j ), minValue, 1 );\n\t\t\tnewAttribute.setComponent( i, j, v );\n\n\t\t}\n\n\t}\n\n\treturn newAttribute;\n\n}\n\nfunction compressPositionAttribute( mesh, arrayType = Int16Array ) {\n\n\tconst geometry = mesh.geometry;\n\tconst attributes = geometry.attributes;\n\tconst attribute = attributes.position;\n\n\t// skip if it's already compressed to the provided level\n\tif ( attribute.isInterleavedBufferAttribute || attribute.array instanceof arrayType ) {\n\n\t\treturn attribute;\n\n\t}\n\n\t// new attribute data\n\tconst array = new arrayType( attribute.count * attribute.itemSize );\n\tconst newAttribute = new BufferAttribute( array, attribute.itemSize, false );\n\tconst itemSize = attribute.itemSize;\n\tconst count = attribute.count;\n\n\t// bounding box stride\n\t// TODO: the bounding box is computed every time even if it already exists because\n\t// it's possible that the encoded value is incorrect causing artifacts\n\tgeometry.computeBoundingBox();\n\n\tconst boundingBox = geometry.boundingBox;\n\tconst { min, max } = boundingBox;\n\n\t// array range\n\tconst maxValue = 2 ** ( 8 * arrayType.BYTES_PER_ELEMENT - 1 ) - 1;\n\tconst minValue = - maxValue;\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\tconst key = j === 0 ? 'x' : j === 1 ? 'y' : 'z';\n\t\t\tconst bbMinValue = min[ key ];\n\t\t\tconst bbMaxValue = max[ key ];\n\n\t\t\t// scale the geometry values to the integer range\n\t\t\tconst v = MathUtils.mapLinear(\n\t\t\t\tattribute.getComponent( i, j ),\n\t\t\t\tbbMinValue, bbMaxValue,\n\t\t\t\tminValue, maxValue,\n\t\t\t);\n\n\t\t\tnewAttribute.setComponent( i, j, v );\n\n\t\t}\n\n\t}\n\n\t// shift the mesh to the center of the bounds\n\tboundingBox\n\t\t.getCenter( _vec )\n\t\t.multiply( mesh.scale )\n\t\t.applyQuaternion( mesh.quaternion );\n\tmesh.position.add( _vec );\n\n\t// adjust the scale to accommodate the new geometry data range\n\tmesh.scale.x *= 0.5 * ( max.x - min.x ) / maxValue;\n\tmesh.scale.y *= 0.5 * ( max.y - min.y ) / maxValue;\n\tmesh.scale.z *= 0.5 * ( max.z - min.z ) / maxValue;\n\n\tattributes.position = newAttribute;\n\tmesh.geometry.boundingBox = null;\n\tmesh.geometry.boundingSphere = null;\n\n\tmesh.updateMatrixWorld();\n\n}\n\nexport class TileCompressionPlugin {\n\n\tconstructor( options ) {\n\n\t\tthis._options = {\n\t\t\t// whether to generate normals if they don't already exist.\n\t\t\tgenerateNormals: false,\n\n\t\t\t// whether to disable use of mipmaps since they are typically not necessary\n\t\t\t// with something like 3d tiles.\n\t\t\tdisableMipmaps: true,\n\n\t\t\t// whether to compress certain attributes\n\t\t\tcompressIndex: true,\n\t\t\tcompressNormals: false,\n\t\t\tcompressUvs: false,\n\t\t\tcompressPosition: false,\n\n\t\t\t// the TypedArray type to use when compressing the attributes\n\t\t\tuvType: Int8Array,\n\t\t\tnormalType: Int8Array,\n\t\t\tpositionType: Int16Array,\n\n\t\t\t...options,\n\t\t};\n\n\t\tthis.name = 'TILES_COMPRESSION_PLUGIN';\n\t\tthis.priority = - 100;\n\n\t}\n\n\tprocessTileModel( scene, tile ) {\n\n\t\tconst {\n\t\t\tgenerateNormals,\n\n\t\t\tdisableMipmaps,\n\t\t\tcompressIndex,\n\t\t\tcompressUvs,\n\t\t\tcompressNormals,\n\t\t\tcompressPosition,\n\n\t\t\tuvType,\n\t\t\tnormalType,\n\t\t\tpositionType,\n\t\t} = this._options;\n\n\t\tscene.traverse( c => {\n\n\t\t\t// handle materials\n\t\t\tif ( c.material && disableMipmaps ) {\n\n\t\t\t\tconst material = c.material;\n\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\tconst value = material[ key ];\n\t\t\t\t\tif ( value && value.isTexture && value.generateMipmaps ) {\n\n\t\t\t\t\t\tvalue.generateMipmaps = false;\n\t\t\t\t\t\tvalue.minFilter = LinearFilter;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// handle geometry attribute compression\n\t\t\tif ( c.geometry ) {\n\n\t\t\t\tconst geometry = c.geometry;\n\t\t\t\tconst attributes = geometry.attributes;\n\t\t\t\tif ( compressUvs ) {\n\n\t\t\t\t\tconst { uv, uv1, uv2, uv3 } = attributes;\n\t\t\t\t\tif ( uv ) attributes.uv = compressAttribute( uv, uvType );\n\t\t\t\t\tif ( uv1 ) attributes.uv1 = compressAttribute( uv1, uvType );\n\t\t\t\t\tif ( uv2 ) attributes.uv2 = compressAttribute( uv2, uvType );\n\t\t\t\t\tif ( uv3 ) attributes.uv3 = compressAttribute( uv3, uvType );\n\n\t\t\t\t}\n\n\t\t\t\tif ( generateNormals && ! attributes.normals ) {\n\n\t\t\t\t\tgeometry.computeVertexNormals();\n\n\t\t\t\t}\n\n\t\t\t\tif ( compressNormals && attributes.normals ) {\n\n\t\t\t\t\tattributes.normals = compressAttribute( attributes.normals, normalType );\n\n\t\t\t\t}\n\n\t\t\t\tif ( compressPosition ) {\n\n\t\t\t\t\tcompressPositionAttribute( c, positionType );\n\n\t\t\t\t}\n\n\t\t\t\tif ( compressIndex && geometry.index ) {\n\n\t\t\t\t\tconst vertCount = attributes.position.count;\n\t\t\t\t\tconst index = geometry.index;\n\t\t\t\t\tconst type = vertCount > 65535 ? Uint32Array : vertCount > 255 ? Uint16Array : Uint8Array;\n\t\t\t\t\tif ( ! ( index.array instanceof type ) ) {\n\n\t\t\t\t\t\tconst array = new type( geometry.index.count );\n\t\t\t\t\t\tarray.set( index.array );\n\n\t\t\t\t\t\tconst attribute = new BufferAttribute( array, 1 );\n\t\t\t\t\t\tgeometry.setIndex( attribute );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n}\n"],"names":["_vec","Vector3","compressAttribute","attribute","arrayType","minValue","array","newAttribute","BufferAttribute","itemSize","count","i","j","v","MathUtils","compressPositionAttribute","mesh","geometry","attributes","boundingBox","min","max","maxValue","key","bbMinValue","bbMaxValue","TileCompressionPlugin","options","scene","tile","generateNormals","disableMipmaps","compressIndex","compressUvs","compressNormals","compressPosition","uvType","normalType","positionType","c","material","value","LinearFilter","uv","uv1","uv2","uv3","vertCount","index","type"],"mappings":"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"}