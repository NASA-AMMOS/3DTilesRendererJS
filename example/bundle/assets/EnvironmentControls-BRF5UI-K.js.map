{"version":3,"file":"EnvironmentControls-BRF5UI-K.js","sources":["../../../src/three/renderer/controls/PivotPointMesh.js","../../../src/three/renderer/controls/PointerTracker.js","../../../src/three/renderer/controls/utils.js","../../../src/three/renderer/controls/EnvironmentControls.js"],"sourcesContent":["import { Mesh, PlaneGeometry, ShaderMaterial, Vector2 } from 'three';\n\nexport class PivotPointMesh extends Mesh {\n\n\tconstructor() {\n\n\t\tsuper( new PlaneGeometry( 0, 0 ), new PivotMaterial() );\n\t\tthis.renderOrder = Infinity;\n\n\t}\n\n\tonBeforeRender( renderer ) {\n\n\t\tconst uniforms = this.material.uniforms;\n\t\trenderer.getSize( uniforms.resolution.value );\n\n\t}\n\n\tupdateMatrixWorld() {\n\n\t\tthis.matrixWorld.makeTranslation( this.position );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nclass PivotMaterial extends ShaderMaterial {\n\n\tconstructor() {\n\n\t\tsuper( {\n\n\t\t\tdepthWrite: false,\n\t\t\tdepthTest: false,\n\t\t\ttransparent: true,\n\n\t\t\tuniforms: {\n\n\t\t\t\tresolution: { value: new Vector2() },\n\t\t\t\tsize: { value: 15 },\n\t\t\t\tthickness: { value: 2 },\n\t\t\t\topacity: { value: 1 },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float thickness;\n\t\t\t\tuniform vec2 resolution;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\n\t\t\t\t\tfloat aspect = resolution.x / resolution.y;\n\t\t\t\t\tvec2 offset = uv * 2.0 - vec2( 1.0 );\n\t\t\t\t\toffset.y *= aspect;\n\n\t\t\t\t\tvec4 screenPoint = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tscreenPoint.xy += offset * ( size + thickness ) * screenPoint.w / resolution.x;\n\n\t\t\t\t\tgl_Position = screenPoint;\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float thickness;\n\t\t\t\tuniform float opacity;\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tfloat ht = 0.5 * thickness;\n\t\t\t\t\tfloat planeDim = size + thickness;\n\t\t\t\t\tfloat offset = ( planeDim - ht - 2.0 ) / planeDim;\n\t\t\t\t\tfloat texelThickness = ht / planeDim;\n\n\t\t\t\t\tvec2 vec = vUv * 2.0 - vec2( 1.0 );\n\t\t\t\t\tfloat dist = abs( length( vec ) - offset );\n\t\t\t\t\tfloat fw = fwidth( dist ) * 0.5;\n\t\t\t\t\tfloat a = smoothstep( texelThickness - fw, texelThickness + fw, dist );\n\n\t\t\t\t\tgl_FragColor = vec4( 1, 1, 1, opacity * ( 1.0 - a ) );\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t} );\n\n\t}\n\n}\n","import { Vector2 } from 'three';\n\nconst _vec = /* @__PURE__ */ new Vector2();\nconst _vec2 = /* @__PURE__ */ new Vector2();\nexport class PointerTracker {\n\n\tconstructor() {\n\n\t\tthis.domElement = null;\n\t\tthis.buttons = 0;\n\t\tthis.pointerType = null;\n\t\tthis.pointerOrder = [];\n\t\tthis.previousPositions = {};\n\t\tthis.pointerPositions = {};\n\t\tthis.startPositions = {};\n\t\tthis.pointerSetThisFrame = {};\n\t\tthis.hoverPosition = new Vector2();\n\t\tthis.hoverSet = false;\n\n\t}\n\n\treset() {\n\n\t\tthis.buttons = 0;\n\t\tthis.pointerType = null;\n\t\tthis.pointerOrder = [];\n\t\tthis.previousPositions = {};\n\t\tthis.pointerPositions = {};\n\t\tthis.startPositions = {};\n\t\tthis.pointerSetThisFrame = {};\n\t\tthis.hoverPosition = new Vector2();\n\t\tthis.hoverSet = false;\n\n\t}\n\n\t// The pointers can be set multiple times per frame so track whether the pointer has\n\t// been set this frame or not so we don't overwrite the previous position and lose information\n\t// about pointer movement\n\tupdateFrame() {\n\n\t\tconst { previousPositions, pointerPositions } = this;\n\t\tfor ( const id in pointerPositions ) {\n\n\t\t\tpreviousPositions[ id ].copy( pointerPositions[ id ] );\n\n\t\t}\n\n\t}\n\n\tsetHoverEvent( e ) {\n\n\t\tif ( e.pointerType === 'mouse' || e.type === 'wheel' ) {\n\n\t\t\tthis.getAdjustedPointer( e, this.hoverPosition );\n\t\t\tthis.hoverSet = true;\n\n\t\t}\n\n\t}\n\n\tgetLatestPoint( target ) {\n\n\t\tif ( this.pointerType !== null ) {\n\n\t\t\tthis.getCenterPoint( target );\n\t\t\treturn target;\n\n\t\t} else if ( this.hoverSet ) {\n\n\t\t\ttarget.copy( this.hoverPosition );\n\t\t\treturn target;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\t// get the pointer position in the coordinate system of the target element\n\tgetAdjustedPointer( e, target ) {\n\n\t\tconst domRef = this.domElement ? this.domElement : e.target;\n\t\tconst rect = domRef.getBoundingClientRect();\n\t\tconst x = e.clientX - rect.left;\n\t\tconst y = e.clientY - rect.top;\n\t\ttarget.set( x, y );\n\n\t}\n\n\taddPointer( e ) {\n\n\t\tconst id = e.pointerId;\n\t\tconst position = new Vector2();\n\t\tthis.getAdjustedPointer( e, position );\n\t\tthis.pointerOrder.push( id );\n\t\tthis.pointerPositions[ id ] = position;\n\t\tthis.previousPositions[ id ] = position.clone();\n\t\tthis.startPositions[ id ] = position.clone();\n\n\t\tif ( this.getPointerCount() === 1 ) {\n\n\t\t\tthis.pointerType = e.pointerType;\n\t\t\tthis.buttons = e.buttons;\n\n\t\t}\n\n\t}\n\n\tupdatePointer( e ) {\n\n\t\tconst id = e.pointerId;\n\t\tif ( ! ( id in this.pointerPositions ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tthis.getAdjustedPointer( e, this.pointerPositions[ id ] );\n\t\treturn true;\n\n\t}\n\n\tdeletePointer( e ) {\n\n\t\tconst id = e.pointerId;\n\t\tconst pointerOrder = this.pointerOrder;\n\t\tpointerOrder.splice( pointerOrder.indexOf( id ), 1 );\n\t\tdelete this.pointerPositions[ id ];\n\t\tdelete this.previousPositions[ id ];\n\t\tdelete this.startPositions[ id ];\n\n\t\tif ( this.getPointerCount() === 0 ) {\n\n\t\t\tthis.buttons = 0;\n\t\t\tthis.pointerType = null;\n\n\t\t}\n\n\t}\n\n\tgetPointerCount() {\n\n\t\treturn this.pointerOrder.length;\n\n\t}\n\n\tgetCenterPoint( target, pointerPositions = this.pointerPositions ) {\n\n\t\tconst pointerOrder = this.pointerOrder;\n\t\tif ( this.getPointerCount() === 1 || this.getPointerType() === 'mouse' ) {\n\n\t\t\tconst id = pointerOrder[ 0 ];\n\t\t\ttarget.copy( pointerPositions[ id ] );\n\t\t\treturn target;\n\n\t\t} else if ( this.getPointerCount() === 2 ) {\n\n\t\t\tconst id0 = this.pointerOrder[ 0 ];\n\t\t\tconst id1 = this.pointerOrder[ 1 ];\n\n\t\t\tconst p0 = pointerPositions[ id0 ];\n\t\t\tconst p1 = pointerPositions[ id1 ];\n\n\t\t\ttarget.addVectors( p0, p1 ).multiplyScalar( 0.5 );\n\t\t\treturn target;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tgetPreviousCenterPoint( target ) {\n\n\t\treturn this.getCenterPoint( target, this.previousPositions );\n\n\t}\n\n\tgetStartCenterPoint( target ) {\n\n\t\treturn this.getCenterPoint( target, this.startPositions );\n\n\t}\n\n\tgetMoveDistance() {\n\n\t\tthis.getCenterPoint( _vec );\n\t\tthis.getPreviousCenterPoint( _vec2 );\n\n\t\treturn _vec.sub( _vec2 ).length();\n\n\t}\n\n\tgetTouchPointerDistance( pointerPositions = this.pointerPositions ) {\n\n\t\tif ( this.getPointerCount() <= 1 || this.getPointerType() === 'mouse' ) {\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tconst { pointerOrder } = this;\n\t\tconst id0 = pointerOrder[ 0 ];\n\t\tconst id1 = pointerOrder[ 1 ];\n\n\t\tconst p0 = pointerPositions[ id0 ];\n\t\tconst p1 = pointerPositions[ id1 ];\n\n\t\treturn p0.distanceTo( p1 );\n\n\t}\n\n\tgetPreviousTouchPointerDistance() {\n\n\t\treturn this.getTouchPointerDistance( this.previousPositions );\n\n\t}\n\n\tgetStartTouchPointerDistance() {\n\n\t\treturn this.getTouchPointerDistance( this.startPositions );\n\n\t}\n\n\tgetPointerType() {\n\n\t\treturn this.pointerType;\n\n\t}\n\n\tisPointerTouch() {\n\n\t\treturn this.getPointerType() === 'touch';\n\n\t}\n\n\tgetPointerButtons() {\n\n\t\treturn this.buttons;\n\n\t}\n\n\tisLeftClicked() {\n\n\t\treturn Boolean( this.buttons & 1 );\n\n\t}\n\n\tisRightClicked() {\n\n\t\treturn Boolean( this.buttons & 2 );\n\n\t}\n\n}\n","import { Matrix4, Ray, Vector3 } from 'three';\n\nconst _matrix = /* @__PURE__ */ new Matrix4();\nconst _vec = /* @__PURE__ */ new Vector3();\n\n// helper function for constructing a matrix for rotating around a point\nexport function makeRotateAroundPoint( point, quat, target ) {\n\n\ttarget.makeTranslation( - point.x, - point.y, - point.z );\n\n\t_matrix.makeRotationFromQuaternion( quat );\n\ttarget.premultiply( _matrix );\n\n\t_matrix.makeTranslation( point.x, point.y, point.z );\n\ttarget.premultiply( _matrix );\n\n\treturn target;\n\n}\n\n// get the three.js pointer coords from an adjusted pointer (via PointerTracker)\nexport function adjustedPointerToCoords( pointer, element, target ) {\n\n\ttarget.x = ( pointer.x / element.clientWidth ) * 2 - 1;\n\ttarget.y = - ( pointer.y / element.clientHeight ) * 2 + 1;\n\n\tif ( target.isVector3 ) {\n\n\t\ttarget.z = 0;\n\n\t}\n\n}\n\n// find the closest ray on the horizon when the ray passes above the sphere\nexport function closestRaySpherePointFromRotation( ray, radius, target ) {\n\n\tconst hypotenuse = ray.origin.length();\n\n\t// angle inside the sphere\n\tconst theta = Math.acos( radius / hypotenuse );\n\n\t// the direction to the camera\n\ttarget\n\t\t.copy( ray.origin )\n\t\t.multiplyScalar( - 1 )\n\t\t.normalize();\n\n\t// get the normal of the plane the ray and origin lie in\n\tconst rotationVec = _vec\n\t\t.crossVectors( target, ray.direction )\n\t\t.normalize();\n\n\t// rotate the camera direction by angle and scale it to the surface\n\ttarget\n\t\t.multiplyScalar( - 1 )\n\t\t.applyAxisAngle( rotationVec, - theta )\n\t\t.normalize()\n\t\t.multiplyScalar( radius );\n\n}\n\n\n// custom version of set raycaster from camera that relies on the underlying matrices\n// so the ray origin is position at the camera near clip.\nexport function setRaycasterFromCamera( raycaster, coords, camera ) {\n\n\tconst ray = raycaster instanceof Ray ? raycaster : raycaster.ray;\n\tconst { origin, direction } = ray;\n\n\t// get the origin and direction of the frustum ray\n\torigin\n\t\t.set( coords.x, coords.y, - 1 )\n\t\t.unproject( camera );\n\n\tdirection\n\t\t.set( coords.x, coords.y, 1 )\n\t\t.unproject( camera )\n\t\t.sub( origin );\n\n\tif ( ! raycaster.isRay ) {\n\n\t\t// compute the far value based on the distance from point on the near\n\t\t// plane and point on the far plane. Then normalize the direction.\n\t\traycaster.near = 0;\n\t\traycaster.far = direction.length();\n\t\traycaster.camera = camera;\n\n\t}\n\n\t// normalize the ray direction\n\tdirection.normalize();\n\n}\n","import {\n\tMatrix4,\n\tQuaternion,\n\tVector2,\n\tVector3,\n\tRaycaster,\n\tPlane,\n\tEventDispatcher,\n\tMathUtils,\n\tClock,\n\tRay,\n} from 'three';\nimport { PivotPointMesh } from './PivotPointMesh.js';\nimport { PointerTracker } from './PointerTracker.js';\nimport { adjustedPointerToCoords, makeRotateAroundPoint, setRaycasterFromCamera } from './utils.js';\n\nexport const NONE = 0;\nexport const DRAG = 1;\nexport const ROTATE = 2;\nexport const ZOOM = 3;\nexport const WAITING = 4;\n\nconst DRAG_PLANE_THRESHOLD = 0.05;\nconst DRAG_UP_THRESHOLD = 0.025;\n\nconst _rotMatrix = /* @__PURE__ */ new Matrix4();\nconst _invMatrix = /* @__PURE__ */ new Matrix4();\nconst _delta = /* @__PURE__ */ new Vector3();\nconst _vec = /* @__PURE__ */ new Vector3();\nconst _pos = /* @__PURE__ */ new Vector3();\nconst _center = /* @__PURE__ */ new Vector3();\nconst _forward = /* @__PURE__ */ new Vector3();\nconst _right = /* @__PURE__ */ new Vector3();\nconst _targetRight = /* @__PURE__ */ new Vector3();\nconst _rotationAxis = /* @__PURE__ */ new Vector3();\nconst _quaternion = /* @__PURE__ */ new Quaternion();\nconst _plane = /* @__PURE__ */ new Plane();\nconst _localUp = /* @__PURE__ */ new Vector3();\nconst _mouseBefore = /* @__PURE__ */ new Vector3();\nconst _mouseAfter = /* @__PURE__ */ new Vector3();\nconst _identityQuat = /* @__PURE__ */ new Quaternion();\nconst _ray = /* @__PURE__ */ new Ray();\n\nconst _zoomPointPointer = /* @__PURE__ */ new Vector2();\nconst _pointer = /* @__PURE__ */ new Vector2();\nconst _prevPointer = /* @__PURE__ */ new Vector2();\nconst _deltaPointer = /* @__PURE__ */ new Vector2();\nconst _centerPoint = /* @__PURE__ */ new Vector2();\nconst _startCenterPoint = /* @__PURE__ */ new Vector2();\n\nconst _changeEvent = { type: 'change' };\nconst _startEvent = { type: 'start' };\nconst _endEvent = { type: 'end' };\n\nexport class EnvironmentControls extends EventDispatcher {\n\n\tget enabled() {\n\n\t\treturn this._enabled;\n\n\t}\n\n\tset enabled( v ) {\n\n\t\tif ( v !== this.enabled ) {\n\n\t\t\tthis._enabled = v;\n\t\t\tthis.resetState();\n\t\t\tthis.pointerTracker.reset();\n\n\t\t\tif ( ! this.enabled ) {\n\n\t\t\t\tthis.dragInertia.set( 0, 0, 0 );\n\t\t\t\tthis.rotationInertia.set( 0, 0 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconstructor( scene = null, camera = null, domElement = null, tilesRenderer = null ) {\n\n\t\tsuper();\n\n\t\tthis.isEnvironmentControls = true;\n\n\t\tthis.domElement = null;\n\t\tthis.camera = null;\n\t\tthis.scene = null;\n\t\tthis.tilesRenderer = null;\n\n\t\t// settings\n\t\tthis._enabled = true;\n\t\tthis.cameraRadius = 5;\n\t\tthis.rotationSpeed = 1;\n\t\tthis.minAltitude = 0;\n\t\tthis.maxAltitude = 0.45 * Math.PI;\n\t\tthis.minDistance = 10;\n\t\tthis.maxDistance = Infinity;\n\t\tthis.minZoom = 0;\n\t\tthis.maxZoom = Infinity;\n\t\tthis.zoomSpeed = 1;\n\t\tthis.adjustHeight = true;\n\t\tthis.enableDamping = false;\n\t\tthis.dampingFactor = 0.15;\n\n\t\tthis.fallbackPlane = new Plane( new Vector3( 0, 1, 0 ), 0 );\n\t\tthis.useFallbackPlane = true;\n\n\t\t// settings for GlobeControls\n\t\tthis.scaleZoomOrientationAtEdges = false;\n\t\tthis.autoAdjustCameraRotation = true;\n\n\t\t// internal state\n\t\tthis.state = NONE;\n\t\tthis.pointerTracker = new PointerTracker();\n\t\tthis.needsUpdate = false;\n\t\tthis.actionHeightOffset = 0;\n\n\t\tthis.pivotPoint = new Vector3();\n\n\t\t// used for zoom\n\t\tthis.zoomDirectionSet = false;\n\t\tthis.zoomPointSet = false;\n\t\tthis.zoomDirection = new Vector3();\n\t\tthis.zoomPoint = new Vector3();\n\t\tthis.zoomDelta = 0;\n\n\t\t// fields used for inertia\n\t\tthis.rotationInertiaPivot = new Vector3();\n\t\tthis.rotationInertia = new Vector2();\n\t\tthis.dragInertia = new Vector3();\n\t\tthis.inertiaTargetDistance = Infinity; \t\t// track the distance from the camera that we want to use to calculate the inertia end threshold\n\t\tthis.inertiaStableFrames = 0; \t\t\t\t// the number of frames that the camera has not moved while the user is interacting\n\n\t\t// circular pivot mesh\n\t\tthis.pivotMesh = new PivotPointMesh();\n\t\tthis.pivotMesh.raycast = () => {};\n\n\t\tthis.pivotMesh.scale.setScalar( 0.25 );\n\n\t\t// raycaster\n\t\tthis.raycaster = new Raycaster();\n\t\tthis.raycaster.firstHitOnly = true;\n\n\t\tthis.up = new Vector3( 0, 1, 0 );\n\t\tthis.clock = new Clock();\n\n\t\tthis._detachCallback = null;\n\t\tthis._upInitialized = false;\n\t\tthis._lastUsedState = NONE;\n\t\tthis._zoomPointWasSet = false;\n\n\t\t// always update the zoom target point in case the tiles are changing\n\t\tthis._tilesOnChangeCallback = () => this.zoomPointSet = false;\n\n\t\t// init\n\t\tif ( domElement ) this.attach( domElement );\n\t\tif ( camera ) this.setCamera( camera );\n\t\tif ( scene ) this.setScene( scene );\n\t\tif ( tilesRenderer ) this.setTilesRenderer( tilesRenderer );\n\n\t}\n\n\tsetScene( scene ) {\n\n\t\tthis.scene = scene;\n\n\t}\n\n\tsetCamera( camera ) {\n\n\t\tthis.camera = camera;\n\t\tthis._upInitialized = false;\n\t\tthis.zoomDirectionSet = false;\n\t\tthis.zoomPointSet = false;\n\t\tthis.needsUpdate = true;\n\t\tthis.raycaster.camera = camera;\n\t\tthis.resetState();\n\n\t}\n\n\tsetTilesRenderer( tilesRenderer ) {\n\n\t\tconsole.warn( 'EnvironmentControls: \"setTilesRenderer\" has been deprecated. Use \"setScene\" and \"setEllipsoid\", instead.' );\n\n\t\tthis.tilesRenderer = tilesRenderer;\n\t\tif ( this.tilesRenderer !== null ) {\n\n\t\t\tthis.setScene( this.tilesRenderer.group );\n\n\t\t}\n\n\t}\n\n\tattach( domElement ) {\n\n\t\tif ( this.domElement ) {\n\n\t\t\tthrow new Error( 'EnvironmentControls: Controls already attached to element' );\n\n\t\t}\n\n\t\t// set the touch action to none so the browser does not\n\t\t// drag the page to refresh or scroll\n\t\tthis.domElement = domElement;\n\t\tthis.pointerTracker.domElement = domElement;\n\t\tdomElement.style.touchAction = 'none';\n\n\t\tconst contextMenuCallback = e => {\n\n\t\t\t// exit early if the controls are disabled\n\t\t\tif ( ! this.enabled ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\te.preventDefault();\n\n\t\t};\n\n\t\tconst pointerdownCallback = e => {\n\n\t\t\t// exit early if the controls are disabled\n\t\t\tif ( ! this.enabled ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\te.preventDefault();\n\n\t\t\tconst {\n\t\t\t\tcamera,\n\t\t\t\traycaster,\n\t\t\t\tdomElement,\n\t\t\t\tup,\n\t\t\t\tpivotMesh,\n\t\t\t\tpointerTracker,\n\t\t\t\tscene,\n\t\t\t\tpivotPoint,\n\t\t\t\tenabled,\n\t\t\t} = this;\n\n\t\t\t// init the pointer\n\t\t\tpointerTracker.addPointer( e );\n\t\t\tthis.needsUpdate = true;\n\n\t\t\t// handle cases where we need to capture the pointer or\n\t\t\t// reset state when we have too many pointers\n\t\t\tif ( pointerTracker.isPointerTouch() ) {\n\n\t\t\t\tpivotMesh.visible = false;\n\n\t\t\t\tif ( pointerTracker.getPointerCount() === 0 ) {\n\n\t\t\t\t\t// TODO: is it correct to only capture a single pointer? Or do we need to do it for\n\t\t\t\t\t// every unique pointer id?\n\t\t\t\t\tdomElement.setPointerCapture( e.pointerId );\n\n\t\t\t\t} else if ( pointerTracker.getPointerCount() > 2 ) {\n\n\t\t\t\t\tthis.resetState();\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// the \"pointer\" for zooming and rotating should be based on the center point\n\t\t\tpointerTracker.getCenterPoint( _pointer );\n\t\t\tadjustedPointerToCoords( _pointer, domElement, _pointer );\n\t\t\tsetRaycasterFromCamera( raycaster, _pointer, camera );\n\n\t\t\t// prevent the drag distance from getting too severe by limiting the drag point\n\t\t\t// to a reasonable angle and reasonable distance with the drag plane\n\t\t\tconst dot = Math.abs( raycaster.ray.direction.dot( up ) );\n\t\t\tif ( dot < DRAG_PLANE_THRESHOLD || dot < DRAG_UP_THRESHOLD ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// find the hit point\n\t\t\tconst hit = this._raycast( raycaster );\n\t\t\tif ( hit ) {\n\n\t\t\t\t// if two fingers, right click, or shift click are being used then we trigger\n\t\t\t\t// a rotation action to begin\n\t\t\t\tif (\n\t\t\t\t\tpointerTracker.getPointerCount() === 2 ||\n\t\t\t\t\tpointerTracker.isRightClicked() ||\n\t\t\t\t\tpointerTracker.isLeftClicked() && e.shiftKey\n\t\t\t\t) {\n\n\t\t\t\t\tthis.setState( pointerTracker.isPointerTouch() ? WAITING : ROTATE );\n\n\t\t\t\t\tpivotPoint.copy( hit.point );\n\t\t\t\t\tpivotMesh.position.copy( hit.point );\n\t\t\t\t\tpivotMesh.visible = pointerTracker.isPointerTouch() ? false : enabled;\n\t\t\t\t\tpivotMesh.updateMatrixWorld();\n\t\t\t\t\tscene.add( pivotMesh );\n\n\t\t\t\t} else if ( pointerTracker.isLeftClicked() ) {\n\n\t\t\t\t\t// if the clicked point is coming from below the plane then don't perform the drag\n\t\t\t\t\tthis.setState( DRAG );\n\t\t\t\t\tpivotPoint.copy( hit.point );\n\n\t\t\t\t\tpivotMesh.position.copy( hit.point );\n\t\t\t\t\tpivotMesh.updateMatrixWorld();\n\t\t\t\t\tscene.add( pivotMesh );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tlet _pointerMoveQueued = false;\n\t\tconst pointermoveCallback = e => {\n\n\t\t\t// exit early if the controls are disabled\n\t\t\tconst { pointerTracker } = this;\n\t\t\tif ( ! this.enabled ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\te.preventDefault();\n\n\t\t\tconst {\n\t\t\t\tpivotMesh,\n\t\t\t\tenabled,\n\t\t\t} = this;\n\n\t\t\t// whenever the pointer moves we need to re-derive the zoom direction and point\n\t\t\tthis.zoomDirectionSet = false;\n\t\t\tthis.zoomPointSet = false;\n\n\t\t\tif ( this.state !== NONE ) {\n\n\t\t\t\tthis.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tpointerTracker.setHoverEvent( e );\n\t\t\tif ( ! pointerTracker.updatePointer( e ) ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( pointerTracker.isPointerTouch() && pointerTracker.getPointerCount() === 2 ) {\n\n\t\t\t\t// We queue this event to ensure that all pointers have been updated\n\t\t\t\tif ( ! _pointerMoveQueued ) {\n\n\t\t\t\t\t_pointerMoveQueued = true;\n\t\t\t\t\tqueueMicrotask( () => {\n\n\t\t\t\t\t\t_pointerMoveQueued = false;\n\n\t\t\t\t\t\t// adjust the pointer position to be the center point\n\t\t\t\t\t\tpointerTracker.getCenterPoint( _centerPoint );\n\n\t\t\t\t\t\t// detect zoom transition\n\t\t\t\t\t\tconst startDist = pointerTracker.getStartTouchPointerDistance();\n\t\t\t\t\t\tconst pointerDist = pointerTracker.getTouchPointerDistance();\n\t\t\t\t\t\tconst separateDelta = pointerDist - startDist;\n\t\t\t\t\t\tif ( this.state === NONE || this.state === WAITING ) {\n\n\t\t\t\t\t\t\t// check which direction was moved in first - if the pointers are pinching then\n\t\t\t\t\t\t\t// it's a zoom. But if they move in parallel it's a rotation\n\t\t\t\t\t\t\tpointerTracker.getCenterPoint( _centerPoint );\n\t\t\t\t\t\t\tpointerTracker.getStartCenterPoint( _startCenterPoint );\n\n\t\t\t\t\t\t\t// adjust the drag requirement by the dpr\n\t\t\t\t\t\t\tconst dragThreshold = 2.0 * window.devicePixelRatio;\n\t\t\t\t\t\t\tconst parallelDelta = _centerPoint.distanceTo( _startCenterPoint );\n\t\t\t\t\t\t\tif ( Math.abs( separateDelta ) > dragThreshold || parallelDelta > dragThreshold ) {\n\n\t\t\t\t\t\t\t\tif ( Math.abs( separateDelta ) > parallelDelta ) {\n\n\t\t\t\t\t\t\t\t\tthis.setState( ZOOM );\n\t\t\t\t\t\t\t\t\tthis.zoomDirectionSet = false;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tthis.setState( ROTATE );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( this.state === ZOOM ) {\n\n\t\t\t\t\t\t\tconst previousDist = pointerTracker.getPreviousTouchPointerDistance();\n\t\t\t\t\t\t\tthis.zoomDelta += pointerDist - previousDist;\n\t\t\t\t\t\t\tpivotMesh.visible = false;\n\n\t\t\t\t\t\t} else if ( this.state === ROTATE ) {\n\n\t\t\t\t\t\t\tpivotMesh.visible = enabled;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// TODO: we have the potential to fire change multiple times per frame - should we debounce?\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t};\n\n\t\tconst pointerupCallback = e => {\n\n\t\t\t// exit early if the controls are disabled\n\t\t\tconst { pointerTracker } = this;\n\t\t\tif ( ! this.enabled || pointerTracker.getPointerCount() === 0 ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tpointerTracker.deletePointer( e );\n\n\t\t\tif (\n\t\t\t\tpointerTracker.getPointerType() === 'touch' &&\n\t\t\t\tpointerTracker.getPointerCount() === 0\n\t\t\t) {\n\n\t\t\t\tdomElement.releasePointerCapture( e.pointerId );\n\n\t\t\t}\n\n\t\t\tthis.resetState();\n\t\t\tthis.needsUpdate = true;\n\n\t\t};\n\n\t\tconst wheelCallback = e => {\n\n\t\t\t// exit early if the controls are disabled\n\t\t\tif ( ! this.enabled ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\te.preventDefault();\n\n\t\t\tconst { pointerTracker } = this;\n\t\t\tpointerTracker.setHoverEvent( e );\n\t\t\tpointerTracker.updatePointer( e );\n\n\t\t\t// TODO: do we need events here?\n\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\tlet delta;\n\t\t\tswitch ( e.deltaMode ) {\n\n\t\t\t\tcase 2: // Pages\n\t\t\t\t\tdelta = e.deltaY * 800;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1: // Lines\n\t\t\t\t\tdelta = e.deltaY * 40;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0: // Pixels\n\t\t\t\t\tdelta = e.deltaY;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// use LOG to scale the scroll delta and hopefully normalize them across platforms\n\t\t\tconst deltaSign = Math.sign( delta );\n\t\t\tconst normalizedDelta = Math.abs( delta );\n\t\t\tthis.zoomDelta -= 0.25 * deltaSign * normalizedDelta;\n\t\t\tthis.needsUpdate = true;\n\n\t\t\tthis._lastUsedState = ZOOM;\n\t\t\tthis.dispatchEvent( _endEvent );\n\n\t\t};\n\n\t\tconst pointerleaveCallback = e => {\n\n\t\t\t// exit early if the controls are disabled\n\t\t\tif ( ! this.enabled ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.resetState();\n\n\t\t};\n\n\t\tdomElement.addEventListener( 'contextmenu', contextMenuCallback );\n\t\tdomElement.addEventListener( 'pointerdown', pointerdownCallback );\n\t\tdomElement.addEventListener( 'wheel', wheelCallback, { passive: false } );\n\n\t\t// Register movement events on the root element so dragging does not break when dragging over other elements.\n\t\t// Use \"getRootNode\" to enable offscreenCanvas usage.\n\t\t// \"pointerleave\" event fires when leaving the window.\n\t\tconst document = domElement.getRootNode();\n\t\tdocument.addEventListener( 'pointermove', pointermoveCallback );\n\t\tdocument.addEventListener( 'pointerup', pointerupCallback );\n\t\tdocument.addEventListener( 'pointerleave', pointerleaveCallback );\n\n\t\tthis._detachCallback = () => {\n\n\t\t\tdomElement.removeEventListener( 'contextmenu', contextMenuCallback );\n\t\t\tdomElement.removeEventListener( 'pointerdown', pointerdownCallback );\n\t\t\tdomElement.removeEventListener( 'wheel', wheelCallback );\n\n\t\t\tdocument.removeEventListener( 'pointermove', pointermoveCallback );\n\t\t\tdocument.removeEventListener( 'pointerup', pointerupCallback );\n\t\t\tdocument.removeEventListener( 'pointerleave', pointerleaveCallback );\n\n\t\t};\n\n\t}\n\n\tdetach() {\n\n\t\tthis.domElement = null;\n\n\t\tif ( this._detachCallback ) {\n\n\t\t\tthis._detachCallback();\n\t\t\tthis._detachCallback = null;\n\t\t\tthis.pointerTracker.reset();\n\n\t\t}\n\n\t}\n\n\t// override-able functions for retrieving the up direction at a point\n\tgetUpDirection( point, target ) {\n\n\t\ttarget.copy( this.up );\n\n\t}\n\n\tgetCameraUpDirection( target ) {\n\n\t\tthis.getUpDirection( this.camera.position, target );\n\n\t}\n\n\t// returns the active / last used pivot point for the scene\n\tgetPivotPoint( target ) {\n\n\t\tlet result = null;\n\n\t\t// get the last interacted point as the focus\n\t\tif ( this._lastUsedState === ZOOM ) {\n\n\t\t\tif ( this._zoomPointWasSet ) {\n\n\t\t\t\tresult = target.copy( this.zoomPoint );\n\n\t\t\t}\n\n\t\t} else if ( this._lastUsedState === ROTATE || this._lastUsedState === DRAG ) {\n\n\t\t\tresult = target.copy( this.pivotPoint );\n\n\t\t}\n\n\t\t// If the last used point is outside the camera view then skip it\n\t\tconst { camera, raycaster } = this;\n\t\tif ( result !== null ) {\n\n\t\t\t_vec.copy( result ).project( camera );\n\t\t\tif ( _vec.x < - 1 || _vec.x > 1 || _vec.y < - 1 || _vec.y > 1 ) {\n\n\t\t\t\tresult = null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// default to the raycast hit if we have not result or the hit is closer to the camera\n\t\t// set a ray in the local ellipsoid frame\n\t\tsetRaycasterFromCamera( raycaster, { x: 0, y: 0 }, camera );\n\n\t\tconst hit = this._raycast( raycaster );\n\t\tif ( hit ) {\n\n\t\t\tif ( result === null || hit.distance < result.distanceTo( raycaster.ray.origin ) ) {\n\n\t\t\t\tresult = target.copy( hit.point );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tresetState() {\n\n\t\tif ( this.state !== NONE ) {\n\n\t\t\tthis.dispatchEvent( _endEvent );\n\n\t\t}\n\n\t\tthis.state = NONE;\n\t\tthis.pivotMesh.removeFromParent();\n\t\tthis.pivotMesh.visible = this.enabled;\n\t\tthis.actionHeightOffset = 0;\n\t\tthis.pointerTracker.reset();\n\n\t}\n\n\tsetState( state = this.state, fireEvent = true ) {\n\n\t\tif ( this.state === state ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.state === NONE && fireEvent ) {\n\n\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t}\n\n\t\tthis.pivotMesh.visible = this.enabled;\n\t\tthis.dragInertia.set( 0, 0, 0 );\n\t\tthis.rotationInertia.set( 0, 0 );\n\t\tthis.inertiaStableFrames = 0;\n\t\tthis.state = state;\n\n\t\tif ( state !== NONE && state !== WAITING ) {\n\n\t\t\tthis._lastUsedState = state;\n\n\t\t}\n\n\t}\n\n\tupdate( deltaTime = Math.min( this.clock.getDelta(), 64 / 1000 ) ) {\n\n\t\tif ( ! this.enabled || ! this.camera || deltaTime === 0 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst {\n\t\t\tcamera,\n\t\t\tcameraRadius,\n\t\t\tpivotPoint,\n\t\t\tup,\n\t\t\tstate,\n\t\t\tadjustHeight,\n\t\t\tautoAdjustCameraRotation,\n\t\t} = this;\n\n\t\tcamera.updateMatrixWorld();\n\n\t\t// set the \"up\" vector immediately so it's available in the following functions\n\t\tthis.getCameraUpDirection( _localUp );\n\t\tif ( ! this._upInitialized ) {\n\n\t\t\tthis._upInitialized = true;\n\t\t\tthis.up.copy( _localUp );\n\n\t\t}\n\n\t\t// we need to update the zoom point whenever we update in case the scene is animating or changing\n\t\tthis.zoomPointSet = false;\n\n\t\t// update the actions\n\t\tconst inertiaNeedsUpdate = this._inertiaNeedsUpdate();\n\t\tconst adjustCameraRotation = this.needsUpdate || inertiaNeedsUpdate;\n\t\tif ( this.needsUpdate || inertiaNeedsUpdate ) {\n\n\t\t\tconst zoomDelta = this.zoomDelta;\n\n\t\t\tthis._updateZoom();\n\t\t\tthis._updatePosition( deltaTime );\n\t\t\tthis._updateRotation( deltaTime );\n\n\t\t\tif ( state === DRAG || state === ROTATE ) {\n\n\t\t\t\t_forward.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\t\t\tthis.inertiaTargetDistance = _vec.copy( pivotPoint ).sub( camera.position ).dot( _forward );\n\n\t\t\t} else if ( state === NONE ) {\n\n\t\t\t\tthis._updateInertia( deltaTime );\n\n\t\t\t}\n\n\t\t\tif ( state !== NONE || zoomDelta !== 0 || inertiaNeedsUpdate ) {\n\n\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t}\n\n\t\t\tthis.needsUpdate = false;\n\n\t\t}\n\n\t\t// update the up direction based on where the camera moved to\n\t\t// if using an orthographic camera then rotate around drag pivot\n\t\t// reuse the \"hit\" information since it can be slow to perform multiple hits\n\t\tconst hit = camera.isOrthographicCamera ? null : adjustHeight && this._getPointBelowCamera() || null;\n\t\tthis.getCameraUpDirection( _localUp );\n\t\tthis._setFrame( _localUp );\n\n\t\t// when dragging the camera and drag point may be moved\n\t\t// to accommodate terrain so we try to move it back down\n\t\t// to the original point.\n\t\tif ( ( this.state === DRAG || this.state === ROTATE ) && this.actionHeightOffset !== 0 ) {\n\n\t\t\tconst { actionHeightOffset } = this;\n\t\t\tcamera.position.addScaledVector( up, - actionHeightOffset );\n\t\t\tpivotPoint.addScaledVector( up, - actionHeightOffset );\n\n\t\t\t// adjust the height\n\t\t\tif ( hit ) {\n\n\t\t\t\thit.distance -= actionHeightOffset;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.actionHeightOffset = 0;\n\n\t\tif ( hit ) {\n\n\t\t\tconst dist = hit.distance;\n\t\t\tif ( dist < cameraRadius ) {\n\n\t\t\t\tconst delta = cameraRadius - dist;\n\t\t\t\tcamera.position.addScaledVector( up, delta );\n\t\t\t\tpivotPoint.addScaledVector( up, delta );\n\t\t\t\tthis.actionHeightOffset = delta;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.pointerTracker.updateFrame();\n\n\t\tif ( adjustCameraRotation && autoAdjustCameraRotation ) {\n\n\t\t\tthis.getCameraUpDirection( _localUp );\n\t\t\tthis._alignCameraUp( _localUp, 1 );\n\n\t\t\tthis.getCameraUpDirection( _localUp );\n\t\t\tthis._clampRotation( _localUp );\n\n\n\t\t}\n\n\t}\n\n\t// updates the camera to position it based on the constraints of the controls\n\tadjustCamera( camera ) {\n\n\t\tconst { adjustHeight, cameraRadius } = this;\n\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t// adjust the camera height\n\t\t\tthis.getUpDirection( camera.position, _localUp );\n\t\t\tconst hit = adjustHeight && this._getPointBelowCamera( camera.position, _localUp ) || null;\n\t\t\tif ( hit ) {\n\n\t\t\t\tconst dist = hit.distance;\n\t\t\t\tif ( dist < cameraRadius ) {\n\n\t\t\t\t\tcamera.position.addScaledVector( _localUp, cameraRadius - dist );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tthis.detach();\n\n\t}\n\n\t// private\n\t_updateInertia( deltaTime ) {\n\n\t\t// update the damping of momentum variables\n\t\tconst {\n\t\t\trotationInertia,\n\t\t\tpivotPoint,\n\t\t\tdragInertia,\n\t\t\tenableDamping,\n\t\t\tdampingFactor,\n\t\t\tcamera,\n\t\t\tcameraRadius,\n\t\t\tminDistance,\n\t\t\tinertiaTargetDistance,\n\t\t} = this;\n\n\t\tif ( ! this.enableDamping || this.inertiaStableFrames > 1 ) {\n\n\t\t\tdragInertia.set( 0, 0, 0 );\n\t\t\trotationInertia.set( 0, 0, 0 );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Based on Freya Holmer's frame-rate independent lerp function\n\t\tconst factor = Math.pow( 2, - deltaTime / dampingFactor );\n\t\tconst stableDistance = Math.max( camera.near, cameraRadius, minDistance, inertiaTargetDistance );\n\t\tconst resolution = 2 * 1e3;\n\t\tconst pixelWidth = 2 / resolution;\n\t\tconst pixelThreshold = 0.25 * pixelWidth;\n\n\t\t// scale the residual rotation motion\n\t\tif ( rotationInertia.lengthSq() > 0 ) {\n\n\t\t\t// calculate two screen points at 1 pixel apart in our notional resolution so we can stop when the delta is ~ 1 pixel\n\t\t\t// projected into world space\n\t\t\tsetRaycasterFromCamera( _ray, _vec.set( 0, 0, - 1 ), camera );\n\t\t\t_ray.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t_ray.direction.normalize();\n\t\t\t_ray.recast( - _ray.direction.dot( _ray.origin ) ).at( stableDistance / _ray.direction.z, _vec );\n\t\t\t_vec.applyMatrix4( camera.matrixWorld );\n\n\t\t\tsetRaycasterFromCamera( _ray, _delta.set( pixelThreshold, pixelThreshold, - 1 ), camera );\n\t\t\t_ray.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t_ray.direction.normalize();\n\t\t\t_ray.recast( - _ray.direction.dot( _ray.origin ) ).at( stableDistance / _ray.direction.z, _delta );\n\t\t\t_delta.applyMatrix4( camera.matrixWorld );\n\n\t\t\t// get implied angle\n\t\t\t_vec.sub( pivotPoint ).normalize();\n\t\t\t_delta.sub( pivotPoint ).normalize();\n\n\t\t\t// calculate the rotation threshold\n\t\t\tconst threshold = _vec.angleTo( _delta ) / deltaTime;\n\t\t\trotationInertia.multiplyScalar( factor );\n\t\t\tif ( rotationInertia.lengthSq() < threshold ** 2 || ! enableDamping ) {\n\n\t\t\t\trotationInertia.set( 0, 0 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// scale the residual translation motion\n\t\tif ( dragInertia.lengthSq() > 0 ) {\n\n\t\t\t// calculate two screen points at 1 pixel apart in our notional resolution so we can stop when the delta is ~ 1 pixel\n\t\t\t// projected into world space\n\t\t\tsetRaycasterFromCamera( _ray, _vec.set( 0, 0, - 1 ), camera );\n\t\t\t_ray.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t_ray.direction.normalize();\n\t\t\t_ray.recast( - _ray.direction.dot( _ray.origin ) ).at( stableDistance / _ray.direction.z, _vec );\n\t\t\t_vec.applyMatrix4( camera.matrixWorld );\n\n\t\t\tsetRaycasterFromCamera( _ray, _delta.set( pixelThreshold, pixelThreshold, - 1 ), camera );\n\t\t\t_ray.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t_ray.direction.normalize();\n\t\t\t_ray.recast( - _ray.direction.dot( _ray.origin ) ).at( stableDistance / _ray.direction.z, _delta );\n\t\t\t_delta.applyMatrix4( camera.matrixWorld );\n\n\t\t\t// calculate movement threshold\n\t\t\tconst threshold = _vec.distanceTo( _delta ) / deltaTime;\n\t\t\tdragInertia.multiplyScalar( factor );\n\t\t\tif ( dragInertia.lengthSq() < threshold ** 2 || ! enableDamping ) {\n\n\t\t\t\tdragInertia.set( 0, 0, 0 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// apply the inertia changes\n\t\tif ( rotationInertia.lengthSq() > 0 ) {\n\n\t\t\tthis._applyRotation( rotationInertia.x * deltaTime, rotationInertia.y * deltaTime, pivotPoint );\n\n\t\t}\n\n\t\tif ( dragInertia.lengthSq() > 0 ) {\n\n\t\t\tcamera.position.addScaledVector( dragInertia, deltaTime );\n\t\t\tcamera.updateMatrixWorld();\n\n\t\t}\n\n\t}\n\n\t_inertiaNeedsUpdate() {\n\n\t\tconst { rotationInertia, dragInertia } = this;\n\t\treturn rotationInertia.lengthSq() !== 0 || dragInertia.lengthSq() !== 0;\n\n\t}\n\n\t_updateZoom() {\n\n\t\tconst {\n\t\t\tzoomPoint,\n\t\t\tzoomDirection,\n\t\t\tcamera,\n\t\t\tminDistance,\n\t\t\tmaxDistance,\n\t\t\tpointerTracker,\n\t\t\tdomElement,\n\t\t\tminZoom,\n\t\t\tmaxZoom,\n\t\t\tzoomSpeed,\n\t\t\tstate,\n\t\t} = this;\n\n\t\tlet scale = this.zoomDelta;\n\t\tthis.zoomDelta = 0;\n\n\t\t// get the latest hover / touch point\n\t\tif ( ! pointerTracker.getLatestPoint( _pointer ) || ( scale === 0 && state !== ZOOM ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// reset momentum\n\t\tthis.rotationInertia.set( 0, 0 );\n\t\tthis.dragInertia.set( 0, 0, 0 );\n\n\t\tif ( camera.isOrthographicCamera ) {\n\n\t\t\t// update the zoom direction\n\t\t\tthis._updateZoomDirection();\n\n\t\t\t// zoom straight into the globe if we haven't hit anything\n\t\t\tconst zoomIntoPoint = this.zoomPointSet || this._updateZoomPoint();\n\n\t\t\t// get the mouse position before zoom\n\t\t\t_mouseBefore.unproject( camera );\n\n\t\t\t// zoom the camera\n\t\t\tconst normalizedDelta = Math.pow( 0.95, Math.abs( scale * 0.05 ) );\n\t\t\tlet scaleFactor = scale > 0 ? 1 / Math.abs( normalizedDelta ) : normalizedDelta;\n\t\t\tscaleFactor *= zoomSpeed;\n\n\t\t\tif ( scaleFactor > 1 ) {\n\n\t\t\t\tif ( maxZoom < camera.zoom * scaleFactor ) {\n\n\t\t\t\t\tscaleFactor = 1;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( minZoom > camera.zoom * scaleFactor ) {\n\n\t\t\t\t\tscaleFactor = 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcamera.zoom *= scaleFactor;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t// adjust the surface point to be in the same position if the globe is hovered over\n\t\t\tif ( zoomIntoPoint ) {\n\n\t\t\t\t// get the mouse position after zoom\n\t\t\t\tadjustedPointerToCoords( _pointer, domElement, _mouseAfter );\n\t\t\t\t_mouseAfter.unproject( camera );\n\n\t\t\t\t// shift the camera on the near plane so the mouse is in the same spot\n\t\t\t\tcamera.position.sub( _mouseAfter ).add( _mouseBefore );\n\t\t\t\tcamera.updateMatrixWorld();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// initialize the zoom direction\n\t\t\tthis._updateZoomDirection();\n\n\t\t\t// track the zoom direction we're going to use\n\t\t\tconst finalZoomDirection = _vec.copy( zoomDirection );\n\n\t\t\tif ( this.zoomPointSet || this._updateZoomPoint() ) {\n\n\t\t\t\tconst dist = zoomPoint.distanceTo( camera.position );\n\n\t\t\t\t// scale the distance based on how far there is to move\n\t\t\t\tif ( scale < 0 ) {\n\n\t\t\t\t\tconst remainingDistance = Math.min( 0, dist - maxDistance );\n\t\t\t\t\tscale = scale * dist * zoomSpeed * 0.0025;\n\t\t\t\t\tscale = Math.max( scale, remainingDistance );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst remainingDistance = Math.max( 0, dist - minDistance );\n\t\t\t\t\tscale = scale * Math.max( dist - minDistance, 0 ) * zoomSpeed * 0.0025;\n\t\t\t\t\tscale = Math.min( scale, remainingDistance );\n\n\t\t\t\t}\n\n\t\t\t\tcamera.position.addScaledVector( zoomDirection, scale );\n\t\t\t\tcamera.updateMatrixWorld();\n\n\t\t\t} else {\n\n\t\t\t\t// if we're zooming into nothing then use the distance from the ground to scale movement\n\t\t\t\tconst hit = this._getPointBelowCamera();\n\t\t\t\tif ( hit ) {\n\n\t\t\t\t\tconst dist = hit.distance;\n\t\t\t\t\tfinalZoomDirection.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\t\t\t\tcamera.position.addScaledVector( finalZoomDirection, scale * dist * 0.01 );\n\t\t\t\t\tcamera.updateMatrixWorld();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_updateZoomDirection() {\n\n\t\tif ( this.zoomDirectionSet ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst { domElement, raycaster, camera, zoomDirection, pointerTracker } = this;\n\t\tpointerTracker.getLatestPoint( _pointer );\n\t\tadjustedPointerToCoords( _pointer, domElement, _mouseBefore );\n\t\tsetRaycasterFromCamera( raycaster, _mouseBefore, camera );\n\t\tzoomDirection.copy( raycaster.ray.direction ).normalize();\n\t\tthis.zoomDirectionSet = true;\n\n\t}\n\n\t// update the point being zoomed in to based on the zoom direction\n\t_updateZoomPoint() {\n\n\t\tconst {\n\t\t\tcamera,\n\t\t\tzoomDirectionSet,\n\t\t\tzoomDirection,\n\t\t\traycaster,\n\t\t\tzoomPoint,\n\t\t\tpointerTracker,\n\t\t\tdomElement,\n\t\t} = this;\n\n\t\tthis._zoomPointWasSet = false;\n\n\t\tif ( ! zoomDirectionSet ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// If using an orthographic camera we have to account for the mouse position when picking the point\n\t\tif ( camera.isOrthographicCamera && pointerTracker.getLatestPoint( _zoomPointPointer ) ) {\n\n\t\t\tadjustedPointerToCoords( _zoomPointPointer, domElement, _zoomPointPointer );\n\t\t\tsetRaycasterFromCamera( raycaster, _zoomPointPointer, camera );\n\n\t\t} else {\n\n\t\t\traycaster.ray.origin.copy( camera.position );\n\t\t\traycaster.ray.direction.copy( zoomDirection );\n\t\t\traycaster.near = 0;\n\t\t\traycaster.far = Infinity;\n\n\t\t}\n\n\t\t// get the hit point\n\t\tconst hit = this._raycast( raycaster );\n\t\tif ( hit ) {\n\n\t\t\tzoomPoint.copy( hit.point );\n\t\t\tthis.zoomPointSet = true;\n\t\t\tthis._zoomPointWasSet = true;\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t// returns the point below the camera\n\t_getPointBelowCamera( point = this.camera.position, up = this.up ) {\n\n\t\tconst { raycaster } = this;\n\t\traycaster.ray.direction.copy( up ).multiplyScalar( - 1 );\n\t\traycaster.ray.origin.copy( point ).addScaledVector( up, 1e5 );\n\t\traycaster.near = 0;\n\t\traycaster.far = Infinity;\n\n\t\tconst hit = this._raycast( raycaster );\n\t\tif ( hit ) {\n\n\t\t\thit.distance -= 1e5;\n\n\t\t}\n\n\t\treturn hit;\n\n\t}\n\n\t// update the drag action\n\t_updatePosition( deltaTime ) {\n\n\t\tconst {\n\t\t\traycaster,\n\t\t\tcamera,\n\t\t\tpivotPoint,\n\t\t\tup,\n\t\t\tpointerTracker,\n\t\t\tdomElement,\n\t\t\tstate,\n\t\t\tdragInertia,\n\t\t} = this;\n\n\t\tif ( state === DRAG ) {\n\n\t\t\t// get the pointer and plane\n\t\t\tpointerTracker.getCenterPoint( _pointer );\n\t\t\tadjustedPointerToCoords( _pointer, domElement, _pointer );\n\n\t\t\t_plane.setFromNormalAndCoplanarPoint( up, pivotPoint );\n\t\t\tsetRaycasterFromCamera( raycaster, _pointer, camera );\n\n\t\t\t// prevent the drag distance from getting too severe by limiting the drag point\n\t\t\t// to a reasonable angle with the drag plane\n\t\t\tif ( Math.abs( raycaster.ray.direction.dot( up ) ) < DRAG_PLANE_THRESHOLD ) {\n\n\t\t\t\t// rotate the pointer direction down to the correct angle for horizontal dragging\n\t\t\t\tconst angle = Math.acos( DRAG_PLANE_THRESHOLD );\n\n\t\t\t\t_rotationAxis\n\t\t\t\t\t.crossVectors( raycaster.ray.direction, up )\n\t\t\t\t\t.normalize();\n\n\t\t\t\traycaster.ray.direction\n\t\t\t\t\t.copy( up )\n\t\t\t\t\t.applyAxisAngle( _rotationAxis, angle )\n\t\t\t\t\t.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t\t// TODO: dragging causes the camera to rise because we're getting \"pushed\" up by lower resolution tiles and\n\t\t\t// don't lower back down. We should maintain a target height above tiles where possible\n\t\t\t// prevent the drag from inverting\n\n\t\t\t// if we drag to a point that's near the edge of the earth then we want to prevent it\n\t\t\t// from wrapping around and causing unexpected rotations\n\t\t\tthis.getUpDirection( pivotPoint, _localUp );\n\t\t\tif ( Math.abs( raycaster.ray.direction.dot( _localUp ) ) < DRAG_UP_THRESHOLD ) {\n\n\t\t\t\tconst angle = Math.acos( DRAG_UP_THRESHOLD );\n\n\t\t\t\t_rotationAxis\n\t\t\t\t\t.crossVectors( raycaster.ray.direction, _localUp )\n\t\t\t\t\t.normalize();\n\n\t\t\t\traycaster.ray.direction\n\t\t\t\t\t.copy( _localUp )\n\t\t\t\t\t.applyAxisAngle( _rotationAxis, angle )\n\t\t\t\t\t.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t\t// find the point on the plane that we should drag to\n\t\t\tif ( raycaster.ray.intersectPlane( _plane, _vec ) ) {\n\n\t\t\t\t_delta.subVectors( pivotPoint, _vec );\n\t\t\t\tcamera.position.add( _delta );\n\t\t\t\tcamera.updateMatrixWorld();\n\n\t\t\t\t// update the drag inertia\n\t\t\t\t_delta.multiplyScalar( 1 / deltaTime );\n\t\t\t\tif ( pointerTracker.getMoveDistance() / deltaTime < 2 * window.devicePixelRatio ) {\n\n\t\t\t\t\tthis.inertiaStableFrames ++;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdragInertia.copy( _delta );\n\t\t\t\t\tthis.inertiaStableFrames = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_updateRotation( deltaTime ) {\n\n\t\tconst {\n\t\t\tpivotPoint,\n\t\t\tpointerTracker,\n\t\t\tdomElement,\n\t\t\tstate,\n\t\t\trotationInertia,\n\t\t} = this;\n\n\t\tif ( state === ROTATE ) {\n\n\t\t\t// get the rotation motion and divide out the container height to normalize for element size\n\t\t\tpointerTracker.getCenterPoint( _pointer );\n\t\t\tpointerTracker.getPreviousCenterPoint( _prevPointer );\n\t\t\t_deltaPointer.subVectors( _pointer, _prevPointer ).multiplyScalar( 2 * Math.PI / domElement.clientHeight );\n\n\t\t\tthis._applyRotation( _deltaPointer.x, _deltaPointer.y, pivotPoint );\n\n\t\t\t// update rotation inertia\n\t\t\t_deltaPointer.multiplyScalar( 1 / deltaTime );\n\t\t\tif ( pointerTracker.getMoveDistance() / deltaTime < 2 * window.devicePixelRatio ) {\n\n\t\t\t\tthis.inertiaStableFrames ++;\n\n\t\t\t} else {\n\n\t\t\t\trotationInertia.copy( _deltaPointer );\n\t\t\t\tthis.inertiaStableFrames = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_applyRotation( x, y, pivotPoint ) {\n\n\t\tif ( x === 0 && y === 0 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst {\n\t\t\tcamera,\n\t\t\tminAltitude,\n\t\t\tmaxAltitude,\n\t\t\trotationSpeed,\n\t\t} = this;\n\n\t\tconst azimuth = - x * rotationSpeed;\n\t\tlet altitude = y * rotationSpeed;\n\n\t\t// calculate current angles and clamp\n\t\t_forward.set( 0, 0, 1 ).transformDirection( camera.matrixWorld );\n\t\t_right.set( 1, 0, 0 ).transformDirection( camera.matrixWorld );\n\t\tthis.getUpDirection( pivotPoint, _localUp );\n\n\t\t// get the signed angle relative to the top down view\n\t\tlet angle;\n\t\tif ( _localUp.dot( _forward ) > 1 - 1e-10 ) {\n\n\t\t\tangle = 0;\n\n\t\t} else {\n\n\t\t\t_vec.crossVectors( _localUp, _forward ).normalize();\n\n\t\t\tconst sign = Math.sign( _vec.dot( _right ) );\n\t\t\tangle = sign * _localUp.angleTo( _forward );\n\n\t\t}\n\n\t\t// clamp the rotation to be within the provided limits\n\t\t// clamp to 0 here, as well, so we don't \"pop\" to the the value range\n\t\tif ( altitude > 0 ) {\n\n\t\t\taltitude = Math.min( angle - minAltitude, altitude );\n\t\t\taltitude = Math.max( 0, altitude );\n\n\t\t} else {\n\n\t\t\taltitude = Math.max( angle - maxAltitude, altitude );\n\t\t\taltitude = Math.min( 0, altitude );\n\n\t\t}\n\n\t\t// rotate around the up axis\n\t\t_quaternion.setFromAxisAngle( _localUp, azimuth );\n\t\tmakeRotateAroundPoint( pivotPoint, _quaternion, _rotMatrix );\n\t\tcamera.matrixWorld.premultiply( _rotMatrix );\n\n\t\t// get a rotation axis for altitude and rotate\n\t\t_right.set( 1, 0, 0 ).transformDirection( camera.matrixWorld );\n\t\t_quaternion.setFromAxisAngle( _right, - altitude );\n\t\tmakeRotateAroundPoint( pivotPoint, _quaternion, _rotMatrix );\n\t\tcamera.matrixWorld.premultiply( _rotMatrix );\n\n\t\t// update the transform members\n\t\tcamera.matrixWorld.decompose( camera.position, camera.quaternion, _vec );\n\n\t}\n\n\t// sets the \"up\" axis for the current surface of the tileset\n\t_setFrame( newUp ) {\n\n\t\tconst {\n\t\t\tup,\n\t\t\tcamera,\n\t\t\tzoomPoint,\n\t\t\tzoomDirectionSet,\n\t\t\tzoomPointSet,\n\t\t\tscaleZoomOrientationAtEdges,\n\t\t} = this;\n\n\t\t// If we're zooming then reorient around the zoom point\n\t\tif ( zoomDirectionSet && ( zoomPointSet || this._updateZoomPoint() ) ) {\n\n\t\t\t// get the amount needed to rotate\n\t\t\t_quaternion.setFromUnitVectors( up, newUp );\n\n\t\t\tif ( scaleZoomOrientationAtEdges ) {\n\n\t\t\t\tthis.getUpDirection( zoomPoint, _vec );\n\n\t\t\t\tlet amt = Math.max( _vec.dot( up ) - 0.6, 0 ) / 0.4;\n\t\t\t\tamt = MathUtils.mapLinear( amt, 0, 0.5, 0, 1 );\n\t\t\t\tamt = Math.min( amt, 1 );\n\n\t\t\t\t// scale the value if we're using an orthographic camera so\n\t\t\t\t// GlobeControls works correctly\n\t\t\t\tif ( camera.isOrthographicCamera ) {\n\n\t\t\t\t\tamt *= 0.1;\n\n\t\t\t\t}\n\n\t\t\t\t_quaternion.slerp( _identityQuat, 1.0 - amt );\n\n\t\t\t}\n\n\t\t\t// rotates the camera position around the point being zoomed in to\n\t\t\tmakeRotateAroundPoint( zoomPoint, _quaternion, _rotMatrix );\n\n\t\t\tcamera.updateMatrixWorld();\n\t\t\tcamera.matrixWorld.premultiply( _rotMatrix );\n\t\t\tcamera.matrixWorld.decompose( camera.position, camera.quaternion, _vec );\n\n\t\t\t// recompute the zoom direction after updating rotation to align with frame\n\t\t\tthis.zoomDirectionSet = false;\n\t\t\tthis._updateZoomDirection();\n\n\t\t}\n\n\t\tup.copy( newUp );\n\t\tcamera.updateMatrixWorld();\n\n\t}\n\n\t_raycast( raycaster ) {\n\n\t\tconst { scene, useFallbackPlane, fallbackPlane } = this;\n\t\tconst result = raycaster.intersectObject( scene )[ 0 ] || null;\n\t\tif ( result ) {\n\n\t\t\treturn result;\n\n\t\t} else if ( useFallbackPlane ) {\n\n\t\t\t// if we don't hit any geometry then try to intersect the fallback\n\t\t\t// plane so the camera can still be manipulated\n\t\t\tconst plane = fallbackPlane;\n\t\t\tif ( raycaster.ray.intersectPlane( plane, _vec ) ) {\n\n\t\t\t\tconst planeHit = {\n\t\t\t\t\tpoint: _vec.clone(),\n\t\t\t\t\tdistance: raycaster.ray.origin.distanceTo( _vec ),\n\t\t\t\t};\n\n\t\t\t\treturn planeHit;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t// tilt the camera to align with the provided \"up\" value\n\t_alignCameraUp( up, alpha = 1 ) {\n\n\t\tconst { camera, state, pivotPoint, zoomPoint, zoomPointSet } = this;\n\n\t\t// get the transform vectors\n\t\tcamera.updateMatrixWorld();\n\t\t_forward.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\t_right.set( - 1, 0, 0 ).transformDirection( camera.matrixWorld );\n\n\t\t// compute an alpha based on the camera direction so we don't try to update the up direction\n\t\t// when the camera is facing that way.\n\t\tlet multiplier = MathUtils.mapLinear( 1 - Math.abs( _forward.dot( up ) ), 0, 0.2, 0, 1 );\n\t\tmultiplier = MathUtils.clamp( multiplier, 0, 1 );\n\t\talpha *= multiplier;\n\n\t\t// calculate the target direction for the right-facing vector\n\t\t_targetRight.crossVectors( up, _forward );\n\t\t_targetRight.lerp( _right, 1 - alpha ).normalize();\n\n\t\t// adjust the camera transformation\n\t\t_quaternion.setFromUnitVectors( _right, _targetRight );\n\t\tcamera.quaternion.premultiply( _quaternion );\n\n\t\t// calculate the active point\n\t\tlet fixedPoint = null;\n\t\tif ( state === DRAG || state === ROTATE ) {\n\n\t\t\tfixedPoint = _pos.copy( pivotPoint );\n\n\t\t} else if ( zoomPointSet ) {\n\n\t\t\tfixedPoint = _pos.copy( zoomPoint );\n\n\t\t}\n\n\t\t// shift the camera in an effort to keep the fixed point in the same spot\n\t\tif ( fixedPoint ) {\n\n\t\t\t_invMatrix.copy( camera.matrixWorld ).invert();\n\t\t\t_vec.copy( fixedPoint ).applyMatrix4( _invMatrix );\n\n\t\t\tcamera.updateMatrixWorld();\n\t\t\t_vec.applyMatrix4( camera.matrixWorld );\n\n\t\t\t_center.subVectors( fixedPoint, _vec );\n\t\t\tcamera.position.add( _center );\n\n\t\t}\n\n\t\tcamera.updateMatrixWorld();\n\n\t}\n\n\t// clamp rotation to the given \"up\" vector\n\t_clampRotation( up ) {\n\n\t\tconst { camera, minAltitude, maxAltitude, state, pivotPoint, zoomPoint, zoomPointSet } = this;\n\n\t\tcamera.updateMatrixWorld();\n\n\t\t// calculate current angles and clamp\n\t\t_forward.set( 0, 0, 1 ).transformDirection( camera.matrixWorld );\n\t\t_right.set( 1, 0, 0 ).transformDirection( camera.matrixWorld );\n\n\t\t// get the signed angle relative to the top down view\n\t\tlet angle;\n\t\tif ( up.dot( _forward ) > 1 - 1e-10 ) {\n\n\t\t\tangle = 0;\n\n\t\t} else {\n\n\t\t\t_vec.crossVectors( up, _forward );\n\n\t\t\tconst sign = Math.sign( _vec.dot( _right ) );\n\t\t\tangle = sign * up.angleTo( _forward );\n\n\t\t}\n\n\t\t// find the angle to target\n\t\tlet targetAngle;\n\t\tif ( angle > maxAltitude ) {\n\n\t\t\ttargetAngle = maxAltitude;\n\n\t\t} else if ( angle < minAltitude ) {\n\n\t\t\ttargetAngle = minAltitude;\n\n\t\t} else {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// construct a rotation basis\n\t\t_forward.copy( up );\n\t\t_quaternion.setFromAxisAngle( _right, targetAngle );\n\t\t_forward.applyQuaternion( _quaternion ).normalize();\n\t\t_vec.crossVectors( _forward, _right ).normalize();\n\n\t\t_rotMatrix.makeBasis( _right, _vec, _forward );\n\t\tcamera.quaternion.setFromRotationMatrix( _rotMatrix );\n\n\t\t// calculate the active point\n\t\tlet fixedPoint = null;\n\t\tif ( state === DRAG || state === ROTATE ) {\n\n\t\t\tfixedPoint = _pos.copy( pivotPoint );\n\n\t\t} else if ( zoomPointSet ) {\n\n\t\t\tfixedPoint = _pos.copy( zoomPoint );\n\n\t\t}\n\n\t\t// shift the camera in an effort to keep the fixed point in the same spot\n\t\tif ( fixedPoint ) {\n\n\t\t\t_invMatrix.copy( camera.matrixWorld ).invert();\n\t\t\t_vec.copy( fixedPoint ).applyMatrix4( _invMatrix );\n\n\t\t\tcamera.updateMatrixWorld();\n\t\t\t_vec.applyMatrix4( camera.matrixWorld );\n\n\t\t\t_center.subVectors( fixedPoint, _vec );\n\t\t\tcamera.position.add( _center );\n\n\t\t}\n\n\t\tcamera.updateMatrixWorld();\n\n\t}\n\n}\n"],"names":["PivotPointMesh","Mesh","PlaneGeometry","PivotMaterial","renderer","uniforms","ShaderMaterial","Vector2","_vec","_vec2","PointerTracker","previousPositions","pointerPositions","id","e","target","rect","x","y","position","pointerOrder","id0","id1","p0","p1","_matrix","Matrix4","makeRotateAroundPoint","point","quat","adjustedPointerToCoords","pointer","element","setRaycasterFromCamera","raycaster","coords","camera","ray","Ray","origin","direction","NONE","DRAG","ROTATE","ZOOM","WAITING","DRAG_PLANE_THRESHOLD","DRAG_UP_THRESHOLD","_rotMatrix","_invMatrix","_delta","Vector3","_pos","_center","_forward","_right","_targetRight","_rotationAxis","_quaternion","Quaternion","_plane","Plane","_localUp","_mouseBefore","_mouseAfter","_identityQuat","_ray","_zoomPointPointer","_pointer","_prevPointer","_deltaPointer","_centerPoint","_startCenterPoint","_changeEvent","_startEvent","_endEvent","EnvironmentControls","EventDispatcher","v","scene","domElement","tilesRenderer","Raycaster","Clock","contextMenuCallback","pointerdownCallback","up","pivotMesh","pointerTracker","pivotPoint","enabled","dot","hit","_pointerMoveQueued","pointermoveCallback","startDist","pointerDist","separateDelta","dragThreshold","parallelDelta","previousDist","pointerupCallback","wheelCallback","delta","deltaSign","normalizedDelta","pointerleaveCallback","document","result","state","fireEvent","deltaTime","cameraRadius","adjustHeight","autoAdjustCameraRotation","inertiaNeedsUpdate","adjustCameraRotation","zoomDelta","actionHeightOffset","dist","rotationInertia","dragInertia","enableDamping","dampingFactor","minDistance","inertiaTargetDistance","factor","stableDistance","pixelThreshold","threshold","zoomPoint","zoomDirection","maxDistance","minZoom","maxZoom","zoomSpeed","scale","zoomIntoPoint","scaleFactor","finalZoomDirection","remainingDistance","zoomDirectionSet","angle","minAltitude","maxAltitude","rotationSpeed","azimuth","altitude","newUp","zoomPointSet","scaleZoomOrientationAtEdges","amt","MathUtils","useFallbackPlane","fallbackPlane","plane","alpha","multiplier","fixedPoint","targetAngle"],"mappings":"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"}