import{Q as N,G as W,l as I,m as D,ae as O,M as c,V as A}from"./three.module-DBfedTbk.js";import{E as G,N as Z,s as z,m as w,D as j,a as H,Z as L}from"./EnvironmentControls-BBSDix_Q.js";import{E as q}from"./Ellipsoid-CLPX16sm.js";import{W as R}from"./I3DMLoader-Co8j1K3i.js";const E=new I,y=new I,u=new D,r=new D,_=new D,g=new D,k=new D,b=new D,f=new N,V=new D,C=new D,a=new O,S=new q,v=new A,U={},Q=2550;class $ extends G{get tilesGroup(){return console.warn('GlobeControls: "tilesGroup" has been deprecated. Use "ellipsoidGroup", instead.'),this.ellipsoidFrame}get ellipsoidFrame(){return this.ellipsoidGroup.matrixWorld}get ellipsoidFrameInverse(){const{ellipsoidGroup:t,ellipsoidFrame:i,_ellipsoidFrameInverse:e}=this;return t.matrixWorldInverse?t.matrixWorldInverse:e.copy(i).invert()}constructor(t=null,i=null,e=null,s=null){super(t,i,e),this.isGlobeControls=!0,this._dragMode=0,this._rotationMode=0,this.maxZoom=.01,this.nearMargin=.25,this.farMargin=0,this.useFallbackPlane=!1,this.autoAdjustCameraRotation=!1,this.globeInertia=new N,this.globeInertiaFactor=0,this.ellipsoid=R.clone(),this.ellipsoidGroup=new W,this._ellipsoidFrameInverse=new I,s!==null&&this.setTilesRenderer(s)}setTilesRenderer(t){super.setTilesRenderer(t),t!==null&&this.setEllipsoid(t.ellipsoid,t.group)}setEllipsoid(t,i){this.ellipsoid=t||R.clone(),this.ellipsoidGroup=i||new W}getPivotPoint(t){const{camera:i,ellipsoidFrame:e,ellipsoidFrameInverse:s,ellipsoid:o}=this;return g.set(0,0,-1).transformDirection(i.matrixWorld),a.origin.copy(i.position),a.direction.copy(g),a.applyMatrix4(s),o.closestPointToRayEstimate(a,r).applyMatrix4(e),(super.getPivotPoint(t)===null||u.subVectors(t,a.origin).dot(a.direction)>u.subVectors(r,a.origin).dot(a.direction))&&t.copy(r),t}getVectorToCenter(t){const{ellipsoidFrame:i,camera:e}=this;return t.setFromMatrixPosition(i).sub(e.position)}getDistanceToCenter(){return this.getVectorToCenter(r).length()}getUpDirection(t,i){const{ellipsoidFrame:e,ellipsoidFrameInverse:s,ellipsoid:o}=this;r.copy(t).applyMatrix4(s),o.getPositionToNormal(r,i),i.transformDirection(e)}getCameraUpDirection(t){const{ellipsoidFrame:i,ellipsoidFrameInverse:e,ellipsoid:s,camera:o}=this;o.isOrthographicCamera?(this._getVirtualOrthoCameraPosition(r),r.applyMatrix4(e),s.getPositionToNormal(r,t),t.transformDirection(i)):this.getUpDirection(o.position,t)}update(t=Math.min(this.clock.getDelta(),64/1e3)){if(!this.enabled||!this.camera||t===0)return;const{camera:i,pivotMesh:e}=this;this._isNearControls()?this.scaleZoomOrientationAtEdges=this.zoomDelta<0:(this.state!==Z&&this._dragMode!==1&&this._rotationMode!==1&&(e.visible=!1),this.scaleZoomOrientationAtEdges=!1);const s=this.needsUpdate||this._inertiaNeedsUpdate();super.update(t),this.adjustCamera(i),s&&this._isNearControls()&&(this.getCameraUpDirection(b),this._alignCameraUp(b,1),this.getCameraUpDirection(b),this._clampRotation(b))}adjustCamera(t){super.adjustCamera(t);const{ellipsoidFrame:i,ellipsoidFrameInverse:e,ellipsoid:s,nearMargin:o,farMargin:n}=this,l=Math.max(...s.radius);if(t.isPerspectiveCamera){const p=r.setFromMatrixPosition(i).sub(t.position).length(),h=o*l,d=c.clamp((p-l)/h,0,1),m=c.lerp(1,1e3,d);t.near=Math.max(m,p-l-h),u.copy(t.position).applyMatrix4(e),s.getPositionToCartographic(u,U);const M=Math.max(s.getPositionElevation(u),Q),x=s.calculateHorizonDistance(U.lat,M);t.far=x+.1+l*n,t.updateProjectionMatrix()}else{this._getVirtualOrthoCameraPosition(t.position,t),t.updateMatrixWorld(),E.copy(t.matrixWorld).invert(),r.setFromMatrixPosition(i).applyMatrix4(E);const p=-r.z;t.near=p-l*(1+o),t.far=p+.1+l*n,t.position.addScaledVector(g,t.near),t.far-=t.near,t.near=0,t.updateProjectionMatrix(),t.updateMatrixWorld()}}setState(...t){super.setState(...t),this._dragMode=0,this._rotationMode=0}_updateInertia(t){super._updateInertia(t);const{globeInertia:i,enableDamping:e,dampingFactor:s,camera:o,cameraRadius:n,minDistance:l,inertiaTargetDistance:p,ellipsoidFrame:h}=this;if(!this.enableDamping||this.inertiaStableFrames>1){this.globeInertiaFactor=0,this.globeInertia.identity();return}const d=Math.pow(2,-t/s),m=Math.max(o.near,n,l,p),F=.25*(2/(2*1e3));if(_.setFromMatrixPosition(h),this.globeInertiaFactor!==0){z(a,r.set(0,0,-1),o),a.applyMatrix4(o.matrixWorldInverse),a.direction.normalize(),a.recast(-a.direction.dot(a.origin)).at(m/a.direction.z,r),r.applyMatrix4(o.matrixWorld),z(a,u.set(F,F,-1),o),a.applyMatrix4(o.matrixWorldInverse),a.direction.normalize(),a.recast(-a.direction.dot(a.origin)).at(m/a.direction.z,u),u.applyMatrix4(o.matrixWorld),r.sub(_).normalize(),u.sub(_).normalize(),this.globeInertiaFactor*=d;const P=r.angleTo(u)/t;(2*Math.acos(i.w)*this.globeInertiaFactor<P||!e)&&(this.globeInertiaFactor=0,i.identity())}this.globeInertiaFactor!==0&&(i.w===1&&(i.x!==0||i.y!==0||i.z!==0)&&(i.w=Math.min(i.w,1-1e-9)),_.setFromMatrixPosition(h),f.identity().slerp(i,this.globeInertiaFactor*t),w(_,f,y),o.matrixWorld.premultiply(y),o.matrixWorld.decompose(o.position,o.quaternion,r))}_inertiaNeedsUpdate(){return super._inertiaNeedsUpdate()||this.globeInertiaFactor!==0}_updatePosition(t){if(this.state===j){this._dragMode===0&&(this._dragMode=this._isNearControls()?1:-1);const{raycaster:i,camera:e,pivotPoint:s,pointerTracker:o,domElement:n,ellipsoidFrame:l,ellipsoidFrameInverse:p}=this,h=u,d=k;o.getCenterPoint(v),H(v.x,v.y,n,v),z(i,v,e),i.ray.applyMatrix4(p);const m=r.copy(s).applyMatrix4(p).length();if(S.radius.setScalar(m),!S.intersectRay(i.ray,r)){this.resetState(),this._updateInertia(t);return}r.applyMatrix4(l),_.setFromMatrixPosition(l),h.subVectors(s,_).normalize(),d.subVectors(r,_).normalize(),f.setFromUnitVectors(d,h),w(_,f,y),e.matrixWorld.premultiply(y),e.matrixWorld.decompose(e.position,e.quaternion,r),o.getMoveDistance()/t<2*window.devicePixelRatio?this.inertiaStableFrames++:(this.globeInertia.copy(f),this.globeInertiaFactor=1/t,this.inertiaStableFrames=0)}}_updateRotation(...t){this._rotationMode===1||this._isNearControls()?(this._rotationMode=1,super._updateRotation(...t)):(this.pivotMesh.visible=!1,this._rotationMode=-1)}_updateZoom(){const{zoomDelta:t,ellipsoid:i,zoomSpeed:e,zoomPoint:s,camera:o,maxZoom:n,state:l}=this;if(l!==L&&t===0)return;this.rotationInertia.set(0,0),this.dragInertia.set(0,0,0),this.globeInertia.identity(),this.globeInertiaFactor=0;const p=c.clamp(c.mapLinear(Math.abs(t),0,20,0,1),0,1);if(this._isNearControls()||t>0){if(this._updateZoomDirection(),t<0&&(this.zoomPointSet||this._updateZoomPoint())){g.set(0,0,-1).transformDirection(o.matrixWorld).normalize(),C.copy(this.up).multiplyScalar(-1),this.getUpDirection(s,V);const h=c.clamp(c.mapLinear(-V.dot(C),1,.95,0,1),0,1),d=1-g.dot(C),m=o.isOrthographicCamera?.05:1,M=c.clamp(p*3,0,1),x=Math.min(h*d*m*M,.1);C.lerpVectors(g,C,x).normalize(),f.setFromUnitVectors(g,C),w(s,f,y),o.matrixWorld.premultiply(y),o.matrixWorld.decompose(o.position,o.quaternion,C),this.zoomDirection.subVectors(s,o.position).normalize()}super._updateZoom()}else if(o.isPerspectiveCamera){const h=this._getPerspectiveTransitionDistance(),d=this._getMaxPerspectiveDistance(),m=c.mapLinear(this.getDistanceToCenter(),h,d,0,1);this._tiltTowardsCenter(c.lerp(0,.4,m*p)),this._alignCameraUpToNorth(c.lerp(0,.2,m*p));const M=this.getDistanceToCenter()-i.radius.x,x=t*M*e*.0025,F=Math.max(x,Math.min(this.getDistanceToCenter()-d,0));this.getVectorToCenter(r).normalize(),this.camera.position.addScaledVector(r,F),this.camera.updateMatrixWorld(),this.zoomDelta=0}else{const h=this._getOrthographicTransitionZoom(),d=this._getMinOrthographicZoom(),m=c.mapLinear(o.zoom,h,d,0,1);this._tiltTowardsCenter(c.lerp(0,.4,m*p)),this._alignCameraUpToNorth(c.lerp(0,.2,m*p));const M=this.zoomDelta,x=Math.pow(.95,Math.abs(M*.05)),F=M>0?1/Math.abs(x):x,P=d/o.zoom,T=Math.max(F*e,Math.min(P,1));o.zoom=Math.min(n,o.zoom*T),o.updateProjectionMatrix(),this.zoomDelta=0,this.zoomDirectionSet=!1}}_alignCameraUpToNorth(t){const{ellipsoidFrame:i}=this;b.set(0,0,1).transformDirection(i),this._alignCameraUp(b,t)}_tiltTowardsCenter(t){const{camera:i,ellipsoidFrame:e}=this;g.set(0,0,-1).transformDirection(i.matrixWorld).normalize(),r.setFromMatrixPosition(e).sub(i.position).normalize(),r.lerp(g,1-t).normalize(),f.setFromUnitVectors(g,r),i.quaternion.premultiply(f),i.updateMatrixWorld()}_getPerspectiveTransitionDistance(){const{camera:t,ellipsoid:i}=this;if(!t.isPerspectiveCamera)throw new Error;const e=Math.max(...i.radius),s=2*Math.atan(Math.tan(c.DEG2RAD*t.fov*.5)*t.aspect),o=e/Math.tan(c.DEG2RAD*t.fov*.5),n=e/Math.tan(s*.5);return Math.max(o,n)}_getMaxPerspectiveDistance(){const{camera:t,ellipsoid:i}=this;if(!t.isPerspectiveCamera)throw new Error;const e=Math.max(...i.radius),s=2*Math.atan(Math.tan(c.DEG2RAD*t.fov*.5)*t.aspect),o=e/Math.tan(c.DEG2RAD*t.fov*.5),n=e/Math.tan(s*.5);return 2*Math.max(o,n)}_getOrthographicTransitionZoom(){const{camera:t,ellipsoid:i}=this;if(!t.isOrthographicCamera)throw new Error;const e=t.top-t.bottom,s=t.right-t.left,o=Math.max(e,s),l=2*Math.max(...i.radius);return 2*o/l}_getMinOrthographicZoom(){const{camera:t,ellipsoid:i}=this;if(!t.isOrthographicCamera)throw new Error;const e=t.top-t.bottom,s=t.right-t.left,o=Math.min(e,s),l=2*Math.max(...i.radius);return .7*o/l}_getVirtualOrthoCameraPosition(t,i=this.camera){const{ellipsoidFrame:e,ellipsoidFrameInverse:s,ellipsoid:o}=this;if(!i.isOrthographicCamera)throw new Error;a.origin.copy(i.position),a.direction.set(0,0,-1).transformDirection(i.matrixWorld),a.applyMatrix4(s),o.closestPointToRayEstimate(a,u).applyMatrix4(e);const n=i.top-i.bottom,l=i.right-i.left,p=Math.max(n,l)/i.zoom;g.set(0,0,-1).transformDirection(i.matrixWorld);const h=u.sub(i.position).dot(g);t.copy(i.position).addScaledVector(g,h-p*4)}_isNearControls(){const{camera:t}=this;return t.isPerspectiveCamera?this.getDistanceToCenter()<this._getPerspectiveTransitionDistance():t.zoom>this._getOrthographicTransitionZoom()}_raycast(t){const i=super._raycast(t);if(i===null){const{ellipsoid:e,ellipsoidFrame:s,ellipsoidFrameInverse:o}=this;a.copy(t.ray).applyMatrix4(o);const n=e.intersectRay(a,r);return n!==null?(n.applyMatrix4(s),{point:n.clone(),distance:n.distanceTo(t.ray.origin)}):null}else return i}}export{$ as G};
//# sourceMappingURL=GlobeControls-CXYtrMsa.js.map
