{"version":3,"file":"googleMapsExample-hR_MLlaW.js","sources":["../../../src/three/plugins/UnloadTilesPlugin.js","../../../src/three/plugins/batched/ModelViewBatchedMesh.js","../../../src/three/plugins/batched/ExpandingBatchedMesh.js","../../../src/three/plugins/batched/utilities.js","../../../src/three/plugins/batched/BatchedTilesPlugin.js","../../three/googleMapsExample.js"],"sourcesContent":["import { LRUCache } from '3d-tiles-renderer/core';\n\n// Plugin that disposes tiles on unload to remove them from the GPU, saving memory\n\n// TODO:\n// - abstract the \"tile visible\" callback so fade tiles can call it when tiles are _actually_ marked as non-visible\nexport class UnloadTilesPlugin {\n\n\tset delay( v ) {\n\n\t\tthis.deferCallbacks.delay = v;\n\n\t}\n\n\tget delay() {\n\n\t\treturn this.deferCallbacks.delay;\n\n\t}\n\n\tset bytesTarget( v ) {\n\n\t\tthis.lruCache.minBytesSize = v;\n\n\t}\n\n\tget bytesTarget() {\n\n\t\treturn this.lruCache.minBytesSize;\n\n\t}\n\n\tget estimatedGpuBytes() {\n\n\t\treturn this.lruCache.cachedBytes;\n\n\t}\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tbytesTarget = 0,\n\t\t} = options;\n\n\t\tthis.name = 'UNLOAD_TILES_PLUGIN';\n\n\t\tthis.tiles = null;\n\t\tthis.lruCache = new LRUCache();\n\t\tthis.deferCallbacks = new DeferCallbackManager();\n\n\t\tthis.delay = delay;\n\t\tthis.bytesTarget = bytesTarget;\n\n\t}\n\n\tinit( tiles ) {\n\n\t\tthis.tiles = tiles;\n\n\t\tconst { lruCache, deferCallbacks } = this;\n\t\tdeferCallbacks.callback = tile => {\n\n\t\t\tlruCache.markUnused( tile );\n\t\t\tlruCache.scheduleUnload( false );\n\n\t\t};\n\n\t\tconst unloadCallback = tile => {\n\n\t\t\tconst scene = tile.engineData.scene;\n\t\t\tconst visible = tiles.visibleTiles.has( tile );\n\n\t\t\tif ( ! visible ) {\n\n\t\t\t\ttiles.invokeOnePlugin( plugin => plugin.unloadTileFromGPU && plugin.unloadTileFromGPU( scene, tile ) );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis._onUpdateBefore = () => {\n\n\t\t\t// update lruCache in \"update\" in case the callback values change\n\t\t\tlruCache.unloadPriorityCallback = tiles.lruCache.unloadPriorityCallback;\n\t\t\tlruCache.computeMemoryUsageCallback = tiles.lruCache.computeMemoryUsageCallback;\n\t\t\tlruCache.minSize = Infinity;\n\t\t\tlruCache.maxSize = Infinity;\n\t\t\tlruCache.maxBytesSize = Infinity;\n\t\t\tlruCache.unloadPercent = 1;\n\t\t\tlruCache.autoMarkUnused = false;\n\n\t\t};\n\n\t\tthis._onVisibilityChangeCallback = ( { tile, visible } ) => {\n\n\t\t\tif ( visible ) {\n\n\t\t\t\tlruCache.add( tile, unloadCallback );\n\t\t\t\ttiles.markTileUsed( tile );\n\t\t\t\tdeferCallbacks.cancel( tile );\n\n\t\t\t} else {\n\n\t\t\t\tdeferCallbacks.run( tile );\n\n\t\t\t}\n\n\t\t};\n\n\t\ttiles.forEachLoadedModel( ( scene, tile ) => {\n\n\t\t\tconst visible = tiles.visibleTiles.has( tile );\n\t\t\tthis._onVisibilityChangeCallback( { scene, visible } );\n\n\t\t} );\n\n\t\ttiles.addEventListener( 'tile-visibility-change', this._onVisibilityChangeCallback );\n\t\ttiles.addEventListener( 'update-before', this._onUpdateBefore );\n\n\t}\n\n\tunloadTileFromGPU( scene, tile ) {\n\n\t\tif ( scene ) {\n\n\t\t\tscene.traverse( c => {\n\n\t\t\t\tif ( c.material ) {\n\n\t\t\t\t\tconst material = c.material;\n\t\t\t\t\tmaterial.dispose();\n\n\t\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\t\tconst value = material[ key ];\n\t\t\t\t\t\tif ( value && value.isTexture ) {\n\n\t\t\t\t\t\t\tvalue.dispose();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( c.geometry ) {\n\n\t\t\t\t\tc.geometry.dispose();\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tthis.tiles.removeEventListener( 'tile-visibility-change', this._onVisibilityChangeCallback );\n\t\tthis.tiles.removeEventListener( 'update-before', this._onUpdateBefore );\n\t\tthis.deferCallbacks.cancelAll();\n\n\t}\n\n}\n\n// Manager for running callbacks after a certain amount of time\nclass DeferCallbackManager {\n\n\tconstructor( callback = () => {} ) {\n\n\t\tthis.map = new Map();\n\t\tthis.callback = callback;\n\t\tthis.delay = 0;\n\n\t}\n\n\trun( tile ) {\n\n\t\tconst { map, delay } = this;\n\t\tif ( map.has( tile ) ) {\n\n\t\t\tthrow new Error( 'DeferCallbackManager: Callback already initialized.' );\n\n\t\t}\n\n\t\tif ( delay === 0 ) {\n\n\t\t\tthis.callback( tile );\n\n\t\t} else {\n\n\t\t\tmap.set( tile, setTimeout( () => this.callback( tile ), delay ) );\n\n\t\t}\n\n\t}\n\n\tcancel( tile ) {\n\n\t\tconst { map } = this;\n\t\tif ( map.has( tile ) ) {\n\n\t\t\tclearTimeout( map.get( tile ) );\n\t\t\tmap.delete( tile );\n\n\t\t}\n\n\t}\n\n\tcancelAll() {\n\n\t\tthis.map.forEach( ( value, tile ) => {\n\n\t\t\tthis.cancel( tile );\n\n\t\t} );\n\n\t}\n\n}\n","import { BatchedMesh, Matrix4, Vector3, Source } from 'three';\n\nconst matrix = /* @__PURE__ */ new Matrix4();\nconst vec1 = /* @__PURE__ */ new Vector3();\nconst vec2 = /* @__PURE__ */ new Vector3();\nexport class ModelViewBatchedMesh extends BatchedMesh {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.resetDistance = 1e4;\n\t\tthis._matricesTextureHandle = null;\n\t\tthis._lastCameraPos = new Matrix4();\n\t\tthis._forceUpdate = true;\n\n\t\tthis._matrices = [];\n\n\t}\n\n\tsetMatrixAt( instanceId, matrix ) {\n\n\t\tsuper.setMatrixAt( instanceId, matrix );\n\t\tthis._forceUpdate = true;\n\n\t\t// save the matrices in their original float64 format to avoid\n\t\t// precision errors when multiplying later\n\t\tconst matrices = this._matrices;\n\t\twhile ( matrices.length <= instanceId ) {\n\n\t\t\tmatrices.push( new Matrix4() );\n\n\t\t}\n\n\t\tmatrices[ instanceId ].copy( matrix );\n\n\t}\n\n\tsetInstanceCount( ...args ) {\n\n\t\tsuper.setInstanceCount( ...args );\n\n\t\tconst matrices = this._matrices;\n\t\twhile ( matrices.length > this.instanceCount ) {\n\n\t\t\tmatrices.pop();\n\n\t\t}\n\n\t}\n\n\tonBeforeRender( renderer, scene, camera, geometry, material, group ) {\n\n\t\t// ensure matrices are complete and up to date\n\t\tsuper.onBeforeRender( renderer, scene, camera, geometry, material, group );\n\n\t\t// retrieve camera before and after camera positions\n\t\tvec1.setFromMatrixPosition( camera.matrixWorld );\n\t\tvec2.setFromMatrixPosition( this._lastCameraPos );\n\n\t\t// initialize the model-view matrix texture if needed\n\t\tconst matricesTexture = this._matricesTexture;\n\t\tlet modelViewMatricesTexture = this._modelViewMatricesTexture;\n\t\tif (\n\t\t\t! modelViewMatricesTexture ||\n\t\t\tmodelViewMatricesTexture.image.width !== matricesTexture.image.width ||\n\t\t\tmodelViewMatricesTexture.image.height !== matricesTexture.image.height\n\t\t) {\n\n\t\t\tif ( modelViewMatricesTexture ) {\n\n\t\t\t\tmodelViewMatricesTexture.dispose();\n\n\t\t\t}\n\n\t\t\tmodelViewMatricesTexture = matricesTexture.clone();\n\t\t\tmodelViewMatricesTexture.source = new Source( {\n\t\t\t\t...modelViewMatricesTexture.image,\n\t\t\t\tdata: modelViewMatricesTexture.image.data.slice(),\n\t\t\t} );\n\n\t\t\tthis._modelViewMatricesTexture = modelViewMatricesTexture;\n\n\t\t}\n\n\t\t// check if we need to update the model view matrices\n\t\tif ( this._forceUpdate || vec1.distanceTo( vec2 ) > this.resetDistance ) {\n\n\t\t\t// transform each objects matrix into local camera frame to avoid precision issues\n\t\t\tconst matrices = this._matrices;\n\t\t\tconst modelViewArray = modelViewMatricesTexture.image.data;\n\t\t\tfor ( let i = 0; i < this.maxInstanceCount; i ++ ) {\n\n\t\t\t\tconst instanceMatrix = matrices[ i ];\n\t\t\t\tif ( instanceMatrix ) {\n\n\t\t\t\t\tmatrix.copy( instanceMatrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmatrix.identity();\n\n\t\t\t\t}\n\n\t\t\t\tmatrix\n\t\t\t\t\t.premultiply( this.matrixWorld )\n\t\t\t\t\t.premultiply( camera.matrixWorldInverse )\n\t\t\t\t\t.toArray( modelViewArray, i * 16 );\n\n\t\t\t}\n\n\t\t\tmodelViewMatricesTexture.needsUpdate = true;\n\t\t\tthis._lastCameraPos.copy( camera.matrixWorld );\n\t\t\tthis._forceUpdate = false;\n\n\t\t}\n\n\t\t// save handles, and transform the matrix world into the camera frame used to position the mesh instances\n\t\t// to offset the position shift.\n\t\tthis._matricesTextureHandle = this._matricesTexture;\n\t\tthis._matricesTexture = this._modelViewMatricesTexture;\n\t\tthis.matrixWorld.copy( this._lastCameraPos );\n\n\t}\n\n\tonAfterRender() {\n\n\t\tthis.updateMatrixWorld();\n\t\tthis._matricesTexture = this._matricesTextureHandle;\n\t\tthis._matricesTextureHandle = null;\n\n\t}\n\n\tonAfterShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial/* , group */ ) {\n\n\t\tthis.onAfterRender( renderer, null, shadowCamera, geometry, depthMaterial );\n\n\t}\n\n\tdispose() {\n\n\t\tsuper.dispose();\n\n\t\tif ( this._modelViewMatricesTexture ) {\n\n\t\t\tthis._modelViewMatricesTexture.dispose();\n\n\t\t}\n\n\t}\n\n}\n","import { Mesh, Box3, Sphere } from 'three';\nimport { ModelViewBatchedMesh } from './ModelViewBatchedMesh.js';\n\nconst _raycastMesh = /* @__PURE__ */ new Mesh();\nconst _batchIntersects = [];\n\n// Implementation of BatchedMesh that automatically expands\nexport class ExpandingBatchedMesh extends ModelViewBatchedMesh {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.expandPercent = 0.25;\n\t\tthis.maxInstanceExpansionSize = Infinity;\n\n\t\t// set of available geometry ids that are no longer being used\n\t\tthis._freeGeometryIds = [];\n\n\t}\n\n\t// Finds a free id that can fit the geometry with the requested ranges. Returns -1 if it could not be found.\n\tfindFreeId( geometry, reservedVertexRange, reservedIndexRange ) {\n\n\t\tconst needsIndex = Boolean( this.geometry.index );\n\t\tconst neededIndexCount = Math.max( needsIndex ? geometry.index.count : - 1, reservedIndexRange );\n\t\tconst neededVertexCount = Math.max( geometry.attributes.position.count, reservedVertexRange );\n\n\t\tlet bestIndex = - 1;\n\t\tlet bestScore = Infinity;\n\t\tconst freeGeometryIds = this._freeGeometryIds;\n\t\tfreeGeometryIds.forEach( ( id, i ) => {\n\n\t\t\t// if indices are not needed then they default to - 1\n\t\t\tconst geometryInfo = this.getGeometryRangeAt( id );\n\t\t\tconst { reservedIndexCount, reservedVertexCount } = geometryInfo;\n\t\t\tif ( reservedIndexCount >= neededIndexCount && reservedVertexCount >= neededVertexCount ) {\n\n\t\t\t\t// generate score that is a combination of how much unused space a geometry would have if used and pick the\n\t\t\t\t// one with the least amount of unused space.\n\t\t\t\tconst score = ( neededIndexCount - reservedIndexCount ) + ( neededVertexCount - reservedVertexCount );\n\t\t\t\tif ( score < bestScore ) {\n\n\t\t\t\t\tbestIndex = i;\n\t\t\t\t\tbestScore = score;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( bestIndex !== - 1 ) {\n\n\t\t\t// remove the id from the array\n\t\t\tconst id = freeGeometryIds[ bestIndex ];\n\t\t\tfreeGeometryIds.splice( bestIndex, 1 );\n\n\t\t\treturn id;\n\n\t\t} else {\n\n\t\t\treturn - 1;\n\n\t\t}\n\n\t}\n\n\t// Overrides addGeometry to find an option geometry slot, expand, or optimized if needed\n\taddGeometry( geometry, reservedVertexRange, reservedIndexRange ) {\n\n\t\t// expand the reserved range to what geometry needs since add geometry will throw an error otherwise\n\t\tconst needsIndex = Boolean( this.geometry.index );\n\t\treservedIndexRange = Math.max( needsIndex ? geometry.index.count : - 1, reservedIndexRange );\n\t\treservedVertexRange = Math.max( geometry.attributes.position.count, reservedVertexRange );\n\n\t\tconst { expandPercent, _freeGeometryIds } = this;\n\t\tlet resultId = this.findFreeId( geometry, reservedVertexRange, reservedIndexRange );\n\t\tif ( resultId !== - 1 ) {\n\n\t\t\t// insert the geometry in the found empty space\n\t\t\tthis.setGeometryAt( resultId, geometry );\n\n\t\t} else {\n\n\t\t\tconst needsMoreSpace = () => {\n\n\t\t\t\tconst vertexNeedsSpace = this.unusedVertexCount < reservedVertexRange;\n\t\t\t\tconst indexNeedsSpace = this.unusedIndexCount < reservedIndexRange;\n\t\t\t\treturn vertexNeedsSpace || indexNeedsSpace;\n\n\t\t\t};\n\n\t\t\tconst index = geometry.index;\n\t\t\tconst position = geometry.attributes.position;\n\t\t\treservedVertexRange = Math.max( reservedVertexRange, position.count );\n\t\t\treservedIndexRange = Math.max( reservedIndexRange, index ? index.count : 0 );\n\n\t\t\tif ( needsMoreSpace() ) {\n\n\t\t\t\t// shift all the unused geometries to try to make space\n\t\t\t\t_freeGeometryIds.forEach( id => this.deleteGeometry( id ) );\n\t\t\t\t_freeGeometryIds.length = 0;\n\n\t\t\t\tthis.optimize();\n\n\t\t\t\tif ( needsMoreSpace() ) {\n\n\t\t\t\t\t// lastly try to expand the batched mesh size so the new geometry fits\n\n\t\t\t\t\tconst batchedIndex = this.geometry.index;\n\t\t\t\t\tconst batchedPosition = this.geometry.attributes.position;\n\n\t\t\t\t\t// compute the new geometry size to expand to accounting for the case where the geometry is not initialized\n\t\t\t\t\tlet newIndexCount, newVertexCount;\n\t\t\t\t\tif ( batchedIndex ) {\n\n\t\t\t\t\t\tconst addIndexCount = Math.ceil( expandPercent * batchedIndex.count );\n\t\t\t\t\t\tnewIndexCount = Math.max( addIndexCount, reservedIndexRange, index.count ) + batchedIndex.count;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnewIndexCount = Math.max( this.unusedIndexCount, reservedIndexRange );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( batchedPosition ) {\n\n\t\t\t\t\t\tconst addVertexCount = Math.ceil( expandPercent * batchedPosition.count );\n\t\t\t\t\t\tnewVertexCount = Math.max( addVertexCount, reservedVertexRange, position.count ) + batchedPosition.count;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnewVertexCount = Math.max( this.unusedVertexCount, reservedVertexRange );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.setGeometrySize( newVertexCount, newIndexCount );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tresultId = super.addGeometry( geometry, reservedVertexRange, reservedIndexRange );\n\n\t\t}\n\n\t\treturn resultId;\n\n\t}\n\n\t// add an instance and automatically expand the number of instances if necessary\n\taddInstance( geometryId ) {\n\n\t\tif ( this.maxInstanceCount === this.instanceCount ) {\n\n\t\t\tconst newCount = Math.ceil( this.maxInstanceCount * ( 1 + this.expandPercent ) );\n\t\t\tthis.setInstanceCount( Math.min( newCount, this.maxInstanceExpansionSize ) );\n\n\t\t}\n\n\t\treturn super.addInstance( geometryId );\n\n\t}\n\n\t// delete an instance, keeping note that the geometry id is now unused\n\tdeleteInstance( instanceId ) {\n\n\t\tconst geometryId = this.getGeometryIdAt( instanceId );\n\t\tif ( geometryId !== - 1 ) {\n\n\t\t\tthis._freeGeometryIds.push( geometryId );\n\n\t\t}\n\n\t\treturn super.deleteInstance( instanceId );\n\n\t}\n\n\t// add a function for raycasting per tile\n\traycastInstance( instanceId, raycaster, intersects ) {\n\n\t\tconst batchGeometry = this.geometry;\n\t\tconst geometryId = this.getGeometryIdAt( instanceId );\n\n\t\t// initialize the mesh\n\t\t_raycastMesh.material = this.material;\n\t\t_raycastMesh.geometry.index = batchGeometry.index;\n\t\t_raycastMesh.geometry.attributes = batchGeometry.attributes;\n\n\t\t// initialize the geometry\n\t\tconst drawRange = this.getGeometryRangeAt( geometryId );\n\t\t_raycastMesh.geometry.setDrawRange( drawRange.start, drawRange.count );\n\t\tif ( _raycastMesh.geometry.boundingBox === null ) {\n\n\t\t\t_raycastMesh.geometry.boundingBox = new Box3();\n\n\t\t}\n\n\t\tif ( _raycastMesh.geometry.boundingSphere === null ) {\n\n\t\t\t_raycastMesh.geometry.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\t// get the intersects\n\t\tthis.getMatrixAt( instanceId, _raycastMesh.matrixWorld ).premultiply( this.matrixWorld );\n\t\tthis.getBoundingBoxAt( geometryId, _raycastMesh.geometry.boundingBox );\n\t\tthis.getBoundingSphereAt( geometryId, _raycastMesh.geometry.boundingSphere );\n\t\t_raycastMesh.raycast( raycaster, _batchIntersects );\n\n\t\t// add batch id to the intersects\n\t\tfor ( let j = 0, l = _batchIntersects.length; j < l; j ++ ) {\n\n\t\t\tconst intersect = _batchIntersects[ j ];\n\t\t\tintersect.object = this;\n\t\t\tintersect.batchId = instanceId;\n\t\t\tintersects.push( intersect );\n\n\t\t}\n\n\t\t_batchIntersects.length = 0;\n\n\t}\n\n}\n","// Returns whether the passed color is white or not\nexport function isColorWhite( color ) {\n\n\treturn color.r === 1 && color.g === 1 && color.b === 1;\n\n}\n\n// Adjusts the given material to take an ArrayTexture for a map\nexport function convertMapToArrayTexture( material ) {\n\n\tmaterial.needsUpdate = true;\n\tmaterial.onBeforeCompile = shader => {\n\n\t\tshader.vertexShader = shader.vertexShader\n\t\t\t.replace(\n\t\t\t\t'#include <common>',\n\t\t\t\t/* glsl */`\n\t\t\t\t#include <common>\n\t\t\t\tvarying float texture_index;\n\t\t\t\t`,\n\t\t\t)\n\t\t\t.replace(\n\t\t\t\t'#include <uv_vertex>',\n\t\t\t\t/* glsl */`\n\t\t\t\t#include <uv_vertex>\n\t\t\t\ttexture_index = getIndirectIndex( gl_DrawID );\n\t\t\t\t`,\n\t\t\t);\n\n\t\tshader.fragmentShader = shader.fragmentShader\n\t\t\t.replace(\n\t\t\t\t'#include <map_pars_fragment>',\n\t\t\t\t/* glsl */`\n\t\t\t\t#ifdef USE_MAP\n\t\t\t\tprecision highp sampler2DArray;\n\t\t\t\tuniform sampler2DArray map;\n\t\t\t\tvarying float texture_index;\n\t\t\t\t#endif\n\t\t\t\t`,\n\t\t\t)\n\t\t\t.replace(\n\t\t\t\t'#include <map_fragment>',\n\t\t\t\t/* glsl */`\n\t\t\t\t#ifdef USE_MAP\n\t\t\t\t\tdiffuseColor *= texture( map, vec3( vMapUv, texture_index ) );\n\t\t\t\t#endif\n\t\t\t\t`\n\t\t\t);\n\n\t};\n\n}\n","import { WebGLArrayRenderTarget, MeshBasicMaterial, DataTexture, REVISION } from 'three';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { ExpandingBatchedMesh } from './ExpandingBatchedMesh.js';\nimport { convertMapToArrayTexture, isColorWhite } from './utilities.js';\n\nconst _textureRenderQuad = new FullScreenQuad( new MeshBasicMaterial() );\nconst _whiteTex = new DataTexture( new Uint8Array( [ 255, 255, 255, 255 ] ), 1, 1 );\n_whiteTex.needsUpdate = true;\n\nexport class BatchedTilesPlugin {\n\n\tconstructor( options = {} ) {\n\n\t\tif ( parseInt( REVISION ) < 170 ) {\n\n\t\t\tthrow new Error( 'BatchedTilesPlugin: Three.js revision 170 or higher required.' );\n\n\t\t}\n\n\t\toptions = {\n\t\t\tinstanceCount: 500,\n\t\t\tvertexCount: 750,\n\t\t\tindexCount: 2000,\n\t\t\texpandPercent: 0.25,\n\t\t\tmaxInstanceCount: Infinity,\n\t\t\tdiscardOriginalContent: true,\n\t\t\ttextureSize: null,\n\n\t\t\tmaterial: null,\n\t\t\trenderer: null,\n\t\t\t...options\n\t\t};\n\n\t\tthis.name = 'BATCHED_TILES_PLUGIN';\n\t\tthis.priority = - 1;\n\n\t\t// limit the amount of instances to the size of a 3d texture to avoid over flowing the\n\t\tconst gl = options.renderer.getContext();\n\n\t\t// save options\n\t\tthis.instanceCount = options.instanceCount;\n\t\tthis.vertexCount = options.vertexCount;\n\t\tthis.indexCount = options.indexCount;\n\t\tthis.material = options.material ? options.material.clone() : null;\n\t\tthis.expandPercent = options.expandPercent;\n\t\tthis.maxInstanceCount = Math.min( options.maxInstanceCount, gl.getParameter( gl.MAX_3D_TEXTURE_SIZE ) );\n\t\tthis.renderer = options.renderer;\n\t\tthis.discardOriginalContent = options.discardOriginalContent;\n\t\tthis.textureSize = options.textureSize;\n\n\t\t// local variables\n\t\tthis.batchedMesh = null;\n\t\tthis.arrayTarget = null;\n\t\tthis.tiles = null;\n\t\tthis._onLoadModel = null;\n\t\tthis._onDisposeModel = null;\n\t\tthis._onVisibilityChange = null;\n\t\tthis._tileToInstanceId = new Map();\n\n\t}\n\n\tinit( tiles ) {\n\n\t\tthis._onDisposeModel = ( { scene, tile } ) => {\n\n\t\t\tthis.removeSceneFromBatchedMesh( scene, tile );\n\n\t\t};\n\n\t\t// register events\n\t\ttiles.addEventListener( 'dispose-model', this._onDisposeModel );\n\t\tthis.tiles = tiles;\n\n\t}\n\n\tinitTextureArray( target ) {\n\n\t\tif ( this.arrayTarget !== null || target.material.map === null ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst { instanceCount, renderer, textureSize, batchedMesh } = this;\n\n\t\t// init the array texture render target\n\t\tconst map = target.material.map;\n\t\tconst textureOptions = {\n\t\t\tcolorSpace: map.colorSpace,\n\t\t\twrapS: map.wrapS,\n\t\t\twrapT: map.wrapT,\n\t\t\twrapR: map.wrapS,\n\t\t\t// TODO: Generating mipmaps for the volume every time a new texture is added is extremely slow\n\t\t\t// generateMipmaps: map.generateMipmaps,\n\t\t\t// minFilter: map.minFilter,\n\t\t\tmagFilter: map.magFilter,\n\t\t};\n\n\t\tconst arrayTarget = new WebGLArrayRenderTarget( textureSize || map.image.width, textureSize || map.image.height, instanceCount );\n\t\tObject.assign( arrayTarget.texture, textureOptions );\n\t\trenderer.initRenderTarget( arrayTarget );\n\n\t\t// assign the material\n\t\tbatchedMesh.material.map = arrayTarget.texture;\n\n\t\tthis.arrayTarget = arrayTarget;\n\n\t\t// once the texture array is initialized we fill in textures for all previously-initialized instances\n\t\t// since they may have been skipped due to not having textures\n\t\tthis._tileToInstanceId.forEach( value => {\n\n\t\t\tvalue.forEach( id => {\n\n\t\t\t\tthis.assignTextureToLayer( _whiteTex, id );\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\t// init the batched mesh if it's not ready\n\tinitBatchedMesh( target ) {\n\n\t\tif ( this.batchedMesh !== null ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// init the batched mesh\n\t\tconst { instanceCount, vertexCount, indexCount, tiles } = this;\n\t\tconst material = this.material ? this.material : new target.material.constructor();\n\t\tconst batchedMesh = new ExpandingBatchedMesh( instanceCount, instanceCount * vertexCount, instanceCount * indexCount, material );\n\t\tbatchedMesh.name = 'BatchTilesPlugin';\n\t\tbatchedMesh.frustumCulled = false;\n\t\ttiles.group.add( batchedMesh );\n\t\tbatchedMesh.updateMatrixWorld();\n\n\t\tconvertMapToArrayTexture( batchedMesh.material );\n\n\t\tthis.batchedMesh = batchedMesh;\n\n\t}\n\n\tsetTileVisible( tile, visible ) {\n\n\t\tconst scene = tile.engineData.scene;\n\t\tif ( visible ) {\n\n\t\t\t// Add tileset to the batched mesh if it hasn't been added already\n\t\t\tthis.addSceneToBatchedMesh( scene, tile );\n\n\t\t}\n\n\t\tif ( this._tileToInstanceId.has( tile ) ) {\n\n\t\t\tconst instanceIds = this._tileToInstanceId.get( tile );\n\t\t\tinstanceIds.forEach( instanceId => {\n\n\t\t\t\tthis.batchedMesh.setVisibleAt( instanceId, visible );\n\n\t\t\t} );\n\n\t\t\t// TODO: this should be handled by the base tiles renderer\n\t\t\tconst tiles = this.tiles;\n\t\t\tif ( visible ) {\n\n\t\t\t\ttiles.visibleTiles.add( tile );\n\n\t\t\t} else {\n\n\t\t\t\ttiles.visibleTiles.delete( tile );\n\n\t\t\t}\n\n\t\t\t// dispatch the event that is blocked otherwise\n\t\t\ttiles.dispatchEvent( {\n\t\t\t\ttype: 'tile-visibility-change',\n\t\t\t\tscene,\n\t\t\t\ttile,\n\t\t\t\tvisible,\n\t\t\t} );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tunloadTileFromGPU( scene, tile ) {\n\n\t\tif ( ! this.discardOriginalContent && this._tileToInstanceId.has( tile ) ) {\n\n\t\t\tthis.removeSceneFromBatchedMesh( scene, tile );\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t// render the given into the given layer\n\tassignTextureToLayer( texture, layer ) {\n\n\t\t// if the array target has not been created yet then skip the assignment and expansion\n\t\tif ( ! this.arrayTarget ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.expandArrayTargetIfNeeded();\n\n\t\tconst { renderer } = this;\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\t// render the layer\n\t\trenderer.setRenderTarget( this.arrayTarget, layer );\n\t\t_textureRenderQuad.material.map = texture;\n\t\t_textureRenderQuad.render( renderer );\n\n\t\t// TODO: perform a copy if the texture is already the appropriate size\n\n\t\t// reset state\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\t\t_textureRenderQuad.material.map = null;\n\t\ttexture.dispose();\n\n\t}\n\n\t// check if the array texture target needs to be expanded\n\texpandArrayTargetIfNeeded() {\n\n\t\tconst { batchedMesh, arrayTarget, renderer } = this;\n\t\tconst targetDepth = Math.min( batchedMesh.maxInstanceCount, this.maxInstanceCount );\n\t\tif ( targetDepth > arrayTarget.depth ) {\n\n\t\t\t// create a new array texture target\n\t\t\tconst textureOptions = {\n\t\t\t\tcolorSpace: arrayTarget.texture.colorSpace,\n\t\t\t\twrapS: arrayTarget.texture.wrapS,\n\t\t\t\twrapT: arrayTarget.texture.wrapT,\n\t\t\t\tgenerateMipmaps: arrayTarget.texture.generateMipmaps,\n\t\t\t\tminFilter: arrayTarget.texture.minFilter,\n\t\t\t\tmagFilter: arrayTarget.texture.magFilter,\n\t\t\t};\n\n\t\t\tconst newArrayTarget = new WebGLArrayRenderTarget( arrayTarget.width, arrayTarget.height, targetDepth );\n\t\t\tObject.assign( newArrayTarget.texture, textureOptions );\n\n\t\t\t// copy the contents\n\t\t\trenderer.initRenderTarget( newArrayTarget );\n\t\t\trenderer.copyTextureToTexture( arrayTarget.texture, newArrayTarget.texture );\n\n\t\t\t// replace the old array target\n\t\t\tarrayTarget.dispose();\n\t\t\tbatchedMesh.material.map = newArrayTarget.texture;\n\t\t\tthis.arrayTarget = newArrayTarget;\n\n\t\t}\n\n\t}\n\n\tremoveSceneFromBatchedMesh( scene, tile ) {\n\n\t\tif ( this._tileToInstanceId.has( tile ) ) {\n\n\t\t\tconst instanceIds = this._tileToInstanceId.get( tile );\n\t\t\tthis._tileToInstanceId.delete( tile );\n\t\t\tinstanceIds.forEach( instanceId => {\n\n\t\t\t\tthis.batchedMesh.deleteInstance( instanceId );\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\taddSceneToBatchedMesh( scene, tile ) {\n\n\t\tif ( this._tileToInstanceId.has( tile ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// find the meshes in the scene\n\t\tconst meshes = [];\n\t\tscene.traverse( c => {\n\n\t\t\tif ( c.isMesh ) {\n\n\t\t\t\tmeshes.push( c );\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// don't add the geometry if it doesn't have the right attributes\n\t\tlet hasCorrectAttributes = true;\n\t\tmeshes.forEach( mesh => {\n\n\t\t\tif ( this.batchedMesh && hasCorrectAttributes ) {\n\n\t\t\t\tconst attrs = mesh.geometry.attributes;\n\t\t\t\tconst batchedAttrs = this.batchedMesh.geometry.attributes;\n\t\t\t\tfor ( const key in batchedAttrs ) {\n\n\t\t\t\t\tif ( ! ( key in attrs ) ) {\n\n\t\t\t\t\t\thasCorrectAttributes = false;\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tconst canAddMeshes = ! this.batchedMesh || this.batchedMesh.instanceCount + meshes.length <= this.maxInstanceCount;\n\t\tif ( hasCorrectAttributes && canAddMeshes ) {\n\n\t\t\tscene.updateMatrixWorld();\n\n\t\t\tconst instanceIds = [];\n\t\t\tthis._tileToInstanceId.set( tile, instanceIds );\n\n\t\t\tmeshes.forEach( mesh => {\n\n\t\t\t\tthis.initBatchedMesh( mesh );\n\t\t\t\tthis.initTextureArray( mesh );\n\n\t\t\t\tconst { geometry, material } = mesh;\n\t\t\t\tconst { batchedMesh, expandPercent } = this;\n\n\t\t\t\t// assign expandPercent in case it has changed\n\t\t\t\tbatchedMesh.expandPercent = expandPercent;\n\n\t\t\t\tconst geometryId = batchedMesh.addGeometry( geometry, this.vertexCount, this.indexCount );\n\t\t\t\tconst instanceId = batchedMesh.addInstance( geometryId );\n\t\t\t\tinstanceIds.push( instanceId );\n\t\t\t\tbatchedMesh.setMatrixAt( instanceId, mesh.matrixWorld );\n\t\t\t\tbatchedMesh.setVisibleAt( instanceId, false );\n\t\t\t\tif ( ! isColorWhite( material.color ) ) {\n\n\t\t\t\t\tmaterial.color.setHSL( Math.random(), 0.5, 0.5 );\n\t\t\t\t\tbatchedMesh.setColorAt( instanceId, material.color );\n\n\t\t\t\t}\n\n\t\t\t\t// render the material\n\t\t\t\tconst texture = material.map;\n\t\t\t\tif ( texture ) {\n\n\t\t\t\t\tthis.assignTextureToLayer( texture, instanceId );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.assignTextureToLayer( _whiteTex, instanceId );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\n\t\t\t// discard all data if the option is set\n\t\t\t// TODO: this would be best done in a more general way\n\t\t\tif ( this.discardOriginalContent ) {\n\n\t\t\t\ttile.engineData.textures.forEach( tex => {\n\n\t\t\t\t\tif ( tex.image instanceof ImageBitmap ) {\n\n\t\t\t\t\t\ttex.image.close();\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\ttile.engineData.scene = null;\n\t\t\t\ttile.engineData.materials = [];\n\t\t\t\ttile.engineData.geometries = [];\n\t\t\t\ttile.engineData.textures = [];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Override raycasting per tile to defer to the batched mesh\n\traycastTile( tile, scene, raycaster, intersects ) {\n\n\t\tif ( ! this._tileToInstanceId.has( tile ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst instanceIds = this._tileToInstanceId.get( tile );\n\t\tinstanceIds.forEach( instanceId => {\n\n\t\t\tthis.batchedMesh.raycastInstance( instanceId, raycaster, intersects );\n\n\t\t} );\n\n\t\treturn true;\n\n\t}\n\n\tdispose() {\n\n\t\tconst { arrayTarget, tiles, batchedMesh } = this;\n\t\tif ( arrayTarget ) {\n\n\t\t\tarrayTarget.dispose();\n\n\t\t}\n\n\t\tif ( batchedMesh ) {\n\n\t\t\tbatchedMesh.material.dispose();\n\t\t\tbatchedMesh.geometry.dispose();\n\t\t\tbatchedMesh.dispose();\n\t\t\tbatchedMesh.removeFromParent();\n\n\t\t}\n\n\t\ttiles.removeEventListener( 'dispose-model', this._onDisposeModel );\n\n\t}\n\n\tgetTileBatchIds( tile ) {\n\n\t\treturn this._tileToInstanceId.get( tile );\n\n\t}\n\n}\n","import {\n\tWGS84_ELLIPSOID,\n\tCAMERA_FRAME,\n\tGeoUtils,\n\tGlobeControls,\n\tCameraTransitionManager,\n\tTilesRenderer,\n} from '3d-tiles-renderer';\nimport {\n\tTilesFadePlugin,\n\tUpdateOnChangePlugin,\n\tTileCompressionPlugin,\n\tUnloadTilesPlugin,\n\tGLTFExtensionsPlugin,\n\tBatchedTilesPlugin,\n\tCesiumIonAuthPlugin,\n} from '3d-tiles-renderer/plugins';\nimport {\n\tScene,\n\tWebGLRenderer,\n\tPerspectiveCamera,\n\tMathUtils,\n\tOrthographicCamera,\n} from 'three';\nimport { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';\nimport { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js';\nimport Stats from 'three/examples/jsm/libs/stats.module.js';\nimport { TopoLinesPlugin } from './src/plugins/topolines/TopoLinesPlugin.js';\n\nlet controls, scene, renderer, tiles, transition;\nlet statsContainer, stats;\n\nconst params = {\n\n\torthographic: false,\n\n\toptimizedLoadStrategy: false,\n\tloadSiblings: true,\n\n\tenableCacheDisplay: false,\n\tenableRendererStats: false,\n\tuseBatchedMesh: Boolean( new URLSearchParams( window.location.hash.replace( /^#/, '' ) ).get( 'batched' ) ),\n\tuseFadePlugin: true,\n\tdisplayTopoLines: false,\n\terrorTarget: 20,\n\n\treload: reinstantiateTiles,\n\n};\n\ninit();\nanimate();\n\nfunction reinstantiateTiles() {\n\n\tif ( tiles ) {\n\n\t\tscene.remove( tiles.group );\n\t\ttiles.dispose();\n\t\ttiles = null;\n\n\t}\n\n\ttiles = new TilesRenderer();\n\ttiles.lruCache.minSize = 0;\n\ttiles.registerPlugin( new CesiumIonAuthPlugin( { apiToken: import.meta.env.VITE_ION_KEY, assetId: '2275207', autoRefreshToken: true } ) );\n\ttiles.registerPlugin( new TileCompressionPlugin() );\n\ttiles.registerPlugin( new UpdateOnChangePlugin() );\n\ttiles.registerPlugin( new UnloadTilesPlugin() );\n\ttiles.registerPlugin( new TopoLinesPlugin( { projection: 'ellipsoid' } ) );\n\ttiles.registerPlugin( new GLTFExtensionsPlugin( {\n\t\t// Note the DRACO compression files need to be supplied via an explicit source.\n\t\t// We use unpkg here but in practice should be provided by the application.\n\t\tdracoLoader: new DRACOLoader().setDecoderPath( 'https://unpkg.com/three@0.153.0/examples/jsm/libs/draco/gltf/' )\n\t} ) );\n\ttiles.optimizedLoadStrategy = params.optimizedLoadStrategy;\n\ttiles.loadSiblings = params.loadSiblings;\n\n\tif ( params.useFadePlugin ) {\n\n\t\ttiles.registerPlugin( new TilesFadePlugin() );\n\n\t}\n\n\tif ( params.useBatchedMesh ) {\n\n\t\ttiles.registerPlugin( new BatchedTilesPlugin( {\n\t\t\trenderer,\n\t\t\tdiscardOriginalContent: false,\n\t\t\tinstanceCount: 250,\n\t\t} ) );\n\n\t}\n\n\ttiles.group.rotation.x = - Math.PI / 2;\n\tscene.add( tiles.group );\n\n\ttiles.setResolutionFromRenderer( transition.camera, renderer );\n\ttiles.setCamera( transition.camera );\n\n\tcontrols.setEllipsoid( tiles.ellipsoid, tiles.group );\n\n}\n\nfunction init() {\n\n\t// renderer\n\trenderer = new WebGLRenderer( { antialias: true } );\n\trenderer.setClearColor( 0x151c1f );\n\tdocument.body.appendChild( renderer.domElement );\n\n\t// scene\n\tscene = new Scene();\n\n\t// camera and transition set up\n\ttransition = new CameraTransitionManager(\n\t\tnew PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 160000000 ),\n\t\tnew OrthographicCamera( - 1, 1, 1, - 1, 1, 160000000 ),\n\t);\n\ttransition.perspectiveCamera.position.set( 4800000, 2570000, 14720000 );\n\ttransition.perspectiveCamera.lookAt( 0, 0, 0 );\n\ttransition.autoSync = false;\n\n\ttransition.addEventListener( 'camera-change', ( { camera, prevCamera } ) => {\n\n\t\ttiles.deleteCamera( prevCamera );\n\t\ttiles.setCamera( camera );\n\t\tcontrols.setCamera( camera );\n\n\t} );\n\n\t// disable adjusting the orthographic camera position for zoom since globe controls will do this\n\ttransition.orthographicPositionalZoom = false;\n\n\t// controls\n\tcontrols = new GlobeControls( scene, transition.camera, renderer.domElement, null );\n\tcontrols.enableDamping = true;\n\n\t// initialize tiles\n\treinstantiateTiles();\n\n\tonWindowResize();\n\twindow.addEventListener( 'resize', onWindowResize, false );\n\twindow.addEventListener( 'hashchange', initFromHash );\n\n\t// GUI\n\tconst gui = new GUI();\n\tgui.width = 300;\n\n\tgui.add( params, 'orthographic' ).onChange( v => {\n\n\t\tcontrols.getPivotPoint( transition.fixedPoint );\n\n\t\t// don't update the cameras if they are already being animated\n\t\tif ( ! transition.animating ) {\n\n\t\t\t// sync the camera positions and then adjust the camera views\n\t\t\ttransition.syncCameras();\n\t\t\tcontrols.adjustCamera( transition.perspectiveCamera );\n\t\t\tcontrols.adjustCamera( transition.orthographicCamera );\n\n\t\t}\n\n\t\ttransition.toggle();\n\n\t} );\n\n\tconst mapsOptions = gui.addFolder( 'Google Photorealistic Tiles' );\n\tif ( new URLSearchParams( window.location.search ).has( 'showOptimizedSettings' ) ) {\n\n\t\tparams.optimizedLoadStrategy = true;\n\t\ttiles.optimizedLoadStrategy = true;\n\t\tmapsOptions.add( params, 'optimizedLoadStrategy' ).listen();\n\t\tmapsOptions.add( params, 'loadSiblings' ).listen();\n\n\t}\n\n\tmapsOptions.add( params, 'useBatchedMesh' ).listen();\n\tmapsOptions.add( params, 'useFadePlugin' ).listen();\n\tmapsOptions.add( params, 'reload' );\n\n\tconst exampleOptions = gui.addFolder( 'Example Options' );\n\texampleOptions.add( params, 'displayTopoLines' ).listen();\n\texampleOptions.add( params, 'enableCacheDisplay' );\n\texampleOptions.add( params, 'enableRendererStats' );\n\texampleOptions.add( params, 'errorTarget', 5, 100, 1 ).onChange( () => {\n\n\t\ttiles.getPluginByName( 'UPDATE_ON_CHANGE_PLUGIN' ).needsUpdate = true;\n\n\t} );\n\n\t// add stats\n\tstatsContainer = document.createElement( 'div' );\n\tdocument.getElementById( 'info' ).appendChild( statsContainer );\n\n\t// Stats\n\tstats = new Stats();\n\tstats.showPanel( 0 );\n\tdocument.body.appendChild( stats.dom );\n\n\t// run hash functions\n\tinitFromHash();\n\tsetInterval( updateHash, 100 );\n\n}\n\nfunction onWindowResize() {\n\n\tconst { perspectiveCamera, orthographicCamera } = transition;\n\tconst aspect = window.innerWidth / window.innerHeight;\n\n\tperspectiveCamera.aspect = aspect;\n\tperspectiveCamera.updateProjectionMatrix();\n\n\torthographicCamera.left = - orthographicCamera.top * aspect;\n\torthographicCamera.right = - orthographicCamera.left;\n\torthographicCamera.updateProjectionMatrix();\n\n\trenderer.setSize( window.innerWidth, window.innerHeight );\n\trenderer.setPixelRatio( window.devicePixelRatio );\n\n}\n\nfunction updateHash() {\n\n\tif ( ! tiles ) {\n\n\t\treturn;\n\n\t}\n\n\tif ( transition.mode !== 'perspective' && ! transition.animating ) {\n\n\t\tcontrols.getPivotPoint( transition.fixedPoint );\n\t\ttransition.syncCameras();\n\n\t}\n\n\tconst camera = transition.perspectiveCamera;\n\tconst cartographicResult = {};\n\tconst tilesMatInv = tiles.group.matrixWorld.clone().invert();\n\tconst localCameraMat = camera.matrixWorld.clone().premultiply( tilesMatInv );\n\n\t// get the data\n\tWGS84_ELLIPSOID.getCartographicFromObjectFrame( localCameraMat, cartographicResult, CAMERA_FRAME );\n\n\t// convert to DEG\n\tcartographicResult.azimuth *= MathUtils.RAD2DEG;\n\tcartographicResult.elevation *= MathUtils.RAD2DEG;\n\tcartographicResult.roll *= MathUtils.RAD2DEG;\n\tcartographicResult.lat *= MathUtils.RAD2DEG;\n\tcartographicResult.lon *= MathUtils.RAD2DEG;\n\n\t// update hash\n\tconst urlParams = new URLSearchParams();\n\turlParams.set( 'lat', cartographicResult.lat.toFixed( 4 ) );\n\turlParams.set( 'lon', cartographicResult.lon.toFixed( 4 ) );\n\turlParams.set( 'height', cartographicResult.height.toFixed( 2 ) );\n\turlParams.set( 'az', cartographicResult.azimuth.toFixed( 2 ) );\n\turlParams.set( 'el', cartographicResult.elevation.toFixed( 2 ) );\n\turlParams.set( 'roll', cartographicResult.roll.toFixed( 2 ) );\n\n\tif ( params.useBatchedMesh ) {\n\n\t\turlParams.set( 'batched', 1 );\n\n\t}\n\n\twindow.history.replaceState( undefined, undefined, `#${ urlParams }` );\n\n}\n\nfunction initFromHash() {\n\n\tconst hash = window.location.hash.replace( /^#/, '' );\n\tconst urlParams = new URLSearchParams( hash );\n\tif ( urlParams.has( 'batched' ) ) {\n\n\t\tparams.useBatchedMesh = Boolean( urlParams.get( 'batched' ) );\n\n\t}\n\n\tif ( ! urlParams.has( 'lat' ) && ! urlParams.has( 'lon' ) ) {\n\n\t\treturn;\n\n\t}\n\n\t// update the tiles matrix world so we can use it\n\ttiles.group.updateMatrixWorld();\n\n\t// get the position fields\n\tconst camera = transition.perspectiveCamera;\n\tconst lat = parseFloat( urlParams.get( 'lat' ) );\n\tconst lon = parseFloat( urlParams.get( 'lon' ) );\n\tconst height = parseFloat( urlParams.get( 'height' ) ) || 1000;\n\n\tif ( urlParams.has( 'az' ) && urlParams.has( 'el' ) ) {\n\n\t\t// get the az el fields for rotation if present\n\t\tconst az = parseFloat( urlParams.get( 'az' ) );\n\t\tconst el = parseFloat( urlParams.get( 'el' ) );\n\t\tconst roll = parseFloat( urlParams.get( 'roll' ) ) || 0;\n\n\t\t// extract the east-north-up frame into matrix world\n\t\tWGS84_ELLIPSOID.getObjectFrame(\n\t\t\tlat * MathUtils.DEG2RAD, lon * MathUtils.DEG2RAD, height,\n\t\t\taz * MathUtils.DEG2RAD, el * MathUtils.DEG2RAD, roll * MathUtils.DEG2RAD,\n\t\t\tcamera.matrixWorld, CAMERA_FRAME,\n\t\t);\n\n\t\t// apply the necessary tiles transform\n\t\tcamera.matrixWorld.premultiply( tiles.group.matrixWorld );\n\t\tcamera.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );\n\n\t} else {\n\n\t\t// default to looking down if no az el are present\n\t\tWGS84_ELLIPSOID.getCartographicToPosition( lat * MathUtils.DEG2RAD, lon * MathUtils.DEG2RAD, height, camera.position );\n\t\tcamera.position.applyMatrix4( tiles.group.matrixWorld );\n\t\tcamera.lookAt( 0, 0, 0 );\n\n\t}\n\n\tif ( transition.mode !== 'perspective' ) {\n\n\t\tconst currentMode = transition.mode;\n\t\ttransition.mode = 'perspective';\n\t\ttransition.syncCameras();\n\t\ttransition.mode = currentMode;\n\n\t}\n\n}\n\nfunction animate() {\n\n\trequestAnimationFrame( animate );\n\n\tif ( ! tiles ) return;\n\n\t// ensure transforms are up to date for controls update\n\tscene.updateMatrixWorld();\n\n\tcontrols.enabled = ! transition.animating;\n\tcontrols.update();\n\ttransition.update();\n\n\t// update options\n\tconst camera = transition.camera;\n\ttiles.setResolutionFromRenderer( camera, renderer );\n\ttiles.setCamera( camera );\n\n\tconst plugin = tiles.getPluginByName( 'TOPO_LINES_PLUGIN' );\n\tplugin.topoOpacity = params.displayTopoLines ? 0.5 : 0;\n\tplugin.cartoOpacity = params.displayTopoLines ? 0.5 : 0;\n\n\t// update tiles\n\tcamera.updateMatrixWorld();\n\ttiles.errorTarget = params.errorTarget;\n\ttiles.update();\n\n\trenderer.render( scene, camera );\n\tstats.update();\n\n\tupdateHtml();\n\n}\n\nfunction updateHtml() {\n\n\t// render html text updates\n\tlet str = '';\n\n\tif ( params.enableCacheDisplay ) {\n\n\t\tconst lruCache = tiles.lruCache;\n\t\tconst cacheFullness = lruCache.cachedBytes / lruCache.maxBytesSize;\n\t\tstr += `Queued: ${ tiles.stats.queued } Downloading: ${ tiles.stats.downloading } Parsing: ${ tiles.stats.parsing } Loaded: ${ tiles.stats.loaded }<br/>Visible: ${ tiles.visibleTiles.size } Active: ${ tiles.activeTiles.size }<br/>`;\n\t\tstr += `Cache: ${ ( 100 * cacheFullness ).toFixed( 2 ) }% ~${ ( lruCache.cachedBytes / 1000 / 1000 ).toFixed( 2 ) }mb<br/>`;\n\n\t}\n\n\tif ( params.enableRendererStats ) {\n\n\t\tconst memory = renderer.info.memory;\n\t\tconst render = renderer.info.render;\n\t\tconst programCount = renderer.info.programs.length;\n\t\tstr += `Geometries: ${ memory.geometries } Textures: ${ memory.textures } Programs: ${ programCount } Draw Calls: ${ render.calls }`;\n\n\t\tconst batchPlugin = tiles.getPluginByName( 'BATCHED_TILES_PLUGIN' );\n\t\tconst fadePlugin = tiles.getPluginByName( 'FADE_TILES_PLUGIN' );\n\t\tif ( batchPlugin ) {\n\n\t\t\tlet tot = 0;\n\t\t\tbatchPlugin.batchedMesh?._instanceInfo.forEach( info => {\n\n\t\t\t\tif ( info.visible && info.active ) tot ++;\n\n\t\t\t} );\n\n\t\t\tfadePlugin?.batchedMesh?._instanceInfo.forEach( info => {\n\n\t\t\t\tif ( info.visible && info.active ) tot ++;\n\n\t\t\t} );\n\n\t\t\tstr += ', Batched: ' + tot;\n\n\t\t}\n\n\t}\n\n\tif ( statsContainer.innerHTML !== str ) {\n\n\t\tstatsContainer.innerHTML = str;\n\n\t}\n\n\tconst mat = tiles.group.matrixWorld.clone().invert();\n\tconst vec = transition.camera.position.clone().applyMatrix4( mat );\n\n\tconst res = {};\n\tWGS84_ELLIPSOID.getPositionToCartographic( vec, res );\n\n\tconst attributions = tiles.getAttributions()[ 0 ]?.value || '';\n\tdocument.getElementById( 'credits' ).innerText = GeoUtils.toLatLonString( res.lat, res.lon ) + '\\n' + attributions;\n\n}\n"],"names":["UnloadTilesPlugin","v","options","delay","bytesTarget","LRUCache","DeferCallbackManager","tiles","lruCache","deferCallbacks","tile","unloadCallback","scene","plugin","visible","c","material","key","value","callback","map","matrix","Matrix4","vec1","Vector3","vec2","ModelViewBatchedMesh","BatchedMesh","args","instanceId","matrices","renderer","camera","geometry","group","matricesTexture","modelViewMatricesTexture","Source","modelViewArray","i","instanceMatrix","object","shadowCamera","depthMaterial","_raycastMesh","Mesh","_batchIntersects","ExpandingBatchedMesh","reservedVertexRange","reservedIndexRange","needsIndex","neededIndexCount","neededVertexCount","bestIndex","bestScore","freeGeometryIds","id","geometryInfo","reservedIndexCount","reservedVertexCount","score","expandPercent","_freeGeometryIds","resultId","needsMoreSpace","vertexNeedsSpace","indexNeedsSpace","index","position","batchedIndex","batchedPosition","newIndexCount","newVertexCount","addIndexCount","addVertexCount","geometryId","newCount","raycaster","intersects","batchGeometry","drawRange","Box3","Sphere","j","l","intersect","isColorWhite","color","convertMapToArrayTexture","shader","_textureRenderQuad","FullScreenQuad","MeshBasicMaterial","_whiteTex","DataTexture","BatchedTilesPlugin","REVISION","gl","target","instanceCount","textureSize","batchedMesh","textureOptions","arrayTarget","WebGLArrayRenderTarget","vertexCount","indexCount","texture","layer","currentRenderTarget","targetDepth","newArrayTarget","instanceIds","meshes","hasCorrectAttributes","mesh","attrs","batchedAttrs","canAddMeshes","tex","controls","transition","statsContainer","stats","params","reinstantiateTiles","init","animate","TilesRenderer","CesiumIonAuthPlugin","TileCompressionPlugin","UpdateOnChangePlugin","TopoLinesPlugin","GLTFExtensionsPlugin","DRACOLoader","TilesFadePlugin","WebGLRenderer","Scene","CameraTransitionManager","PerspectiveCamera","OrthographicCamera","prevCamera","GlobeControls","onWindowResize","initFromHash","gui","GUI","mapsOptions","exampleOptions","Stats","updateHash","perspectiveCamera","orthographicCamera","aspect","cartographicResult","tilesMatInv","localCameraMat","WGS84_ELLIPSOID","CAMERA_FRAME","MathUtils","urlParams","hash","lat","lon","height","az","el","roll","currentMode","updateHtml","str","cacheFullness","memory","render","programCount","batchPlugin","fadePlugin","tot","_a","info","_b","mat","vec","res","attributions","_c","GeoUtils.toLatLonString"],"mappings":"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"}