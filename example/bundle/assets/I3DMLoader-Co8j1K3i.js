import{L as q,r as Y,F as K,B as X,a as tt,g as et}from"./BatchTable-CRr3zuRk.js";import{aY as at,l as M,m as u,bk as st,Q as Z}from"./three.module-DBfedTbk.js";import{G as nt}from"./GLTFLoader-BjagHNWe.js";import{E as ot}from"./Ellipsoid-CLPX16sm.js";const ht=-1,Lt=0,pt=1,ut=2,Et=3,H=6378137,rt=6356752314245179e-9;class it extends q{parse(r){const n=new DataView(r),a=Y(n);console.assert(a==="i3dm");const S=n.getUint32(4,!0);console.assert(S===1);const _=n.getUint32(8,!0);console.assert(_===r.byteLength);const U=n.getUint32(12,!0),I=n.getUint32(16,!0),c=n.getUint32(20,!0),E=n.getUint32(24,!0),f=n.getUint32(28,!0),g=32,y=r.slice(g,g+U+I),o=new K(y,0,U,I),e=g+U+I,s=r.slice(e,e+c+E),O=new X(s,o.getData("INSTANCES_LENGTH"),0,c,E),m=e+c+E,A=new Uint8Array(r,m,_-m);let T=null,h=null,L=null;if(f)T=A,h=Promise.resolve();else{const N=this.resolveExternalURL(tt(A));L=et(N),h=fetch(N,this.fetchOptions).then(i=>{if(!i.ok)throw new Error(`I3DMLoaderBase : Failed to load file "${N}" with status ${i.status} : ${i.statusText}`);return i.arrayBuffer()}).then(i=>{T=new Uint8Array(i)})}return h.then(()=>({version:S,featureTable:o,batchTable:O,glbBytes:T,gltfWorkingPath:L}))}}const $=new ot(H,H,rt);$.name="WGS84 Earth";const W=new u,F=new u,C=new u,P=new u,x=new Z,D=new u,w=new M,Q=new M,k=new u,v=new M,B=new Z,G={};class ft extends it{constructor(r=at){super(),this.manager=r,this.adjustmentTransform=new M,this.ellipsoid=$.clone()}resolveExternalURL(r){return this.manager.resolveURL(super.resolveExternalURL(r))}parse(r){return super.parse(r).then(n=>{const{featureTable:a,batchTable:S}=n,_=n.glbBytes.slice().buffer;return new Promise((U,I)=>{const c=this.fetchOptions,E=this.manager,f=E.getHandler("path.gltf")||new nt(E);c.credentials==="include"&&c.mode==="cors"&&f.setCrossOrigin("use-credentials"),"credentials"in c&&f.setWithCredentials(c.credentials==="include"),c.headers&&f.setRequestHeader(c.headers);let g=n.gltfWorkingPath??this.workingPath;/[\\/]$/.test(g)||(g+="/");const y=this.adjustmentTransform;f.parse(_,g,o=>{const e=a.getData("INSTANCES_LENGTH");let s=a.getData("POSITION",e,"FLOAT","VEC3");const O=a.getData("POSITION_QUANTIZED",e,"UNSIGNED_SHORT","VEC3"),m=a.getData("QUANTIZED_VOLUME_OFFSET",1,"FLOAT","VEC3"),A=a.getData("QUANTIZED_VOLUME_SCALE",1,"FLOAT","VEC3"),T=a.getData("NORMAL_UP",e,"FLOAT","VEC3"),h=a.getData("NORMAL_RIGHT",e,"FLOAT","VEC3"),L=a.getData("SCALE_NON_UNIFORM",e,"FLOAT","VEC3"),N=a.getData("SCALE",e,"FLOAT","SCALAR"),i=a.getData("RTC_CENTER",1,"FLOAT","VEC3"),z=a.getData("EAST_NORTH_UP");if(["NORMAL_UP_OCT32P","NORMAL_RIGHT_OCT32P"].forEach(t=>{t in a.header&&console.warn(`I3DMLoader: Unsupported FeatureTable feature "${t}" detected.`)}),!s&&O){s=new Float32Array(e*3);for(let t=0;t<e;t++)s[t*3+0]=m[0]+O[t*3+0]/65535*A[0],s[t*3+1]=m[1]+O[t*3+1]/65535*A[1],s[t*3+2]=m[2]+O[t*3+2]/65535*A[2]}const p=new u;for(let t=0;t<e;t++)p.x+=s[t*3+0]/e,p.y+=s[t*3+1]/e,p.z+=s[t*3+2]/e;const b=[],V=[];o.scene.updateMatrixWorld(),o.scene.traverse(t=>{if(t.isMesh){V.push(t);const{geometry:d,material:R}=t,l=new st(d,R,e);l.position.copy(p),i&&(l.position.x+=i[0],l.position.y+=i[1],l.position.z+=i[2]),b.push(l)}});for(let t=0;t<e;t++){P.set(s[t*3+0]-p.x,s[t*3+1]-p.y,s[t*3+2]-p.z),x.identity(),T&&(F.set(T[t*3+0],T[t*3+1],T[t*3+2]),C.set(h[t*3+0],h[t*3+1],h[t*3+2]),W.crossVectors(C,F).normalize(),w.makeBasis(C,F,W),x.setFromRotationMatrix(w)),D.set(1,1,1),L&&D.set(L[t*3+0],L[t*3+1],L[t*3+2]),N&&D.multiplyScalar(N[t]);for(let d=0,R=b.length;d<R;d++){const l=b[d];B.copy(x),z&&(l.updateMatrixWorld(),k.copy(P).applyMatrix4(l.matrixWorld),this.ellipsoid.getPositionToCartographic(k,G),this.ellipsoid.getEastNorthUpFrame(G.lat,G.lon,v),B.setFromRotationMatrix(v)),w.compose(P,B,D).multiply(y);const J=V[d];Q.multiplyMatrices(w,J.matrixWorld),l.setMatrixAt(t,Q)}}o.scene.clear(),o.scene.add(...b),o.batchTable=S,o.featureTable=a,o.scene.batchTable=S,o.scene.featureTable=a,U(o)},I)})})}}export{ht as F,ft as I,Et as L,ut as P,Lt as U,$ as W,H as a,pt as b};
//# sourceMappingURL=I3DMLoader-Co8j1K3i.js.map
