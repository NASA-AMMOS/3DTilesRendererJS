{"version":3,"file":"ImageOverlayPlugin-BMd81k7-.js","sources":["../../../src/three/plugins/images/overlays/TiledTextureComposer.js","../../../src/three/plugins/images/overlays/utils.js","../../../src/three/plugins/images/overlays/wrapOverlaysMaterial.js","../../../src/three/plugins/images/sources/GeoJSONImageSource.js","../../../src/three/plugins/images/ImageOverlayPlugin.js"],"sourcesContent":["import { ShaderMaterial, MathUtils, Vector2, PlaneGeometry, OrthographicCamera, Mesh, Color, DoubleSide } from 'three';\n\nconst _camera = /* @__PURE__ */ new OrthographicCamera();\nconst _color = /* @__PURE__ */ new Color();\n\n// Utility for composing a series of tiled textures together onto a target texture in a given range\nexport class TiledTextureComposer {\n\n\tconstructor( renderer ) {\n\n\t\tthis.renderer = renderer;\n\t\tthis.renderTarget = null;\n\t\tthis.range = [ 0, 0, 1, 1 ];\n\t\tthis.quad = new Mesh( new PlaneGeometry(), new ComposeTextureMaterial() );\n\n\t}\n\n\t// set the target render texture and the range that represents the full span\n\tsetRenderTarget( renderTarget, range ) {\n\n\t\tthis.renderTarget = renderTarget;\n\t\tthis.range = [ ...range ];\n\n\t}\n\n\t// draw the given texture at the given span with the provided projection\n\tdraw( texture, span ) {\n\n\t\t// draw the texture at the given sub range\n\t\tconst { range, renderer, quad, renderTarget } = this;\n\t\tconst material = quad.material;\n\t\tmaterial.map = texture;\n\n\t\t// map the range to draw the texture to\n\t\tmaterial.minRange.x = MathUtils.mapLinear( span[ 0 ], range[ 0 ], range[ 2 ], - 1, 1 );\n\t\tmaterial.minRange.y = MathUtils.mapLinear( span[ 1 ], range[ 1 ], range[ 3 ], - 1, 1 );\n\n\t\tmaterial.maxRange.x = MathUtils.mapLinear( span[ 2 ], range[ 0 ], range[ 2 ], - 1, 1 );\n\t\tmaterial.maxRange.y = MathUtils.mapLinear( span[ 3 ], range[ 1 ], range[ 3 ], - 1, 1 );\n\n\t\t// draw the texture\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\t\trenderer.setRenderTarget( renderTarget );\n\t\trenderer.render( quad, _camera );\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\t\trenderer.autoClear = currentAutoClear;\n\n\t\tmaterial.map = null;\n\n\t}\n\n\t// clear the set target\n\tclear( color, alpha = 1 ) {\n\n\t\t// clear the texture\n\t\tconst { renderer, renderTarget } = this;\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentClearColor = renderer.getClearColor( _color );\n\t\tconst currentClearAlpha = renderer.getClearAlpha();\n\n\t\trenderer.setClearColor( color, alpha );\n\t\trenderer.setRenderTarget( renderTarget );\n\t\trenderer.clear();\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\t\trenderer.setClearColor( currentClearColor, currentClearAlpha );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.quad.material.dispose();\n\t\tthis.quad.geometry.dispose();\n\n\t}\n\n}\n\n// Draws the given texture with no depth testing at the given bounds defined by \"minRange\" and \"maxRange\"\nclass ComposeTextureMaterial extends ShaderMaterial {\n\n\t// the [ - 1, 1 ] NDC ranges to draw the texture at\n\tget minRange() {\n\n\t\treturn this.uniforms.minRange.value;\n\n\t}\n\n\tget maxRange() {\n\n\t\treturn this.uniforms.maxRange.value;\n\n\t}\n\n\t// access the map being drawn\n\tget map() {\n\n\t\treturn this.uniforms.map.value;\n\n\t}\n\n\tset map( v ) {\n\n\t\tthis.uniforms.map.value = v;\n\n\t}\n\n\tconstructor() {\n\n\t\tsuper( {\n\t\t\tdepthWrite: false,\n\t\t\tdepthTest: false,\n\t\t\ttransparent: false,\n\t\t\tside: DoubleSide,\n\t\t\tpremultipliedAlpha: true,\n\t\t\tuniforms: {\n\t\t\t\tmap: { value: null },\n\n\t\t\t\t// the normalized [0, 1] range of the target to draw to\n\t\t\t\tminRange: { value: new Vector2() },\n\t\t\t\tmaxRange: { value: new Vector2() },\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tuniform vec2 minRange;\n\t\t\t\tuniform vec2 maxRange;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = vec4( mix( minRange, maxRange, uv ), 0, 1 );\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tuniform sampler2D map;\n\t\t\t\tuniform vec2 minRange;\n\t\t\t\tuniform vec2 maxRange;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t// sample the texture\n\t\t\t\t\tgl_FragColor = texture( map, vUv );\n\t\t\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t\t\t}\n\n\t\t\t`,\n\t\t} );\n\n\n\t}\n\n}\n","import { Vector3, Matrix4, MathUtils } from 'three';\n\n// iterates over all present tiles in the given tile set at the given level in the given range\nexport function forEachTileInBounds( range, level, tiling, normalized, callback ) {\n\n\t// pull the bounds in a bit to avoid loading unnecessary tiles. 1e-8 was chosen since smaller values\n\t// are not larger enough and cause extra tiles to load in cases where 1-to-1 tile-to-image should occur\n\tlet [ minLon, minLat, maxLon, maxLat ] = range;\n\tminLat += 1e-8;\n\tminLon += 1e-8;\n\tmaxLat -= 1e-8;\n\tmaxLon -= 1e-8;\n\n\tconst clampedLevel = Math.max( Math.min( level, tiling.maxLevel ), tiling.minLevel );\n\tconst [ minX, minY, maxX, maxY ] = tiling.getTilesInRange( minLon, minLat, maxLon, maxLat, clampedLevel, normalized );\n\tfor ( let x = minX; x <= maxX; x ++ ) {\n\n\t\tfor ( let y = minY; y <= maxY; y ++ ) {\n\n\t\t\tcallback( x, y, clampedLevel );\n\n\t\t}\n\n\t}\n\n}\n\n// functions for generating UVs for cartographic-projected UVs\nfunction getGeometryCartographicChannel( geometry, geomToEllipsoidMatrix, ellipsoid ) {\n\n\tconst _vec = new Vector3();\n\tconst _cart = {};\n\tconst uv = [];\n\tconst posAttr = geometry.getAttribute( 'position' );\n\n\tgeometry.computeBoundingBox();\n\tgeometry.boundingBox.getCenter( _vec ).applyMatrix4( geomToEllipsoidMatrix );\n\n\t// find a rough mid lat / lon point\n\tellipsoid.getPositionToCartographic( _vec, _cart );\n\tconst centerLat = _cart.lat;\n\tconst centerLon = _cart.lon;\n\n\tlet minLat = Infinity;\n\tlet minLon = Infinity;\n\tlet minHeight = Infinity;\n\tlet maxLat = - Infinity;\n\tlet maxLon = - Infinity;\n\tlet maxHeight = - Infinity;\n\tfor ( let i = 0; i < posAttr.count; i ++ ) {\n\n\t\t// get the lat / lon values per vertex\n\t\t_vec.fromBufferAttribute( posAttr, i ).applyMatrix4( geomToEllipsoidMatrix );\n\t\tellipsoid.getPositionToCartographic( _vec, _cart );\n\n\t\t// The latitude calculations are not so stable at the poles so force the lat value to\n\t\t// the mid point to ensure we don't load an unnecessarily large of tiles\n\t\t// NOTE: this can distort the texture a bit at the poles\n\t\tif ( Math.abs( Math.abs( _cart.lat ) - Math.PI / 2 ) < 1e-5 ) {\n\n\t\t\t_cart.lon = centerLon;\n\n\t\t}\n\n\t\t// ensure we're not wrapping on the same geometry\n\t\tif ( Math.abs( centerLon - _cart.lon ) > Math.PI ) {\n\n\t\t\t_cart.lon += Math.sign( centerLon - _cart.lon ) * Math.PI * 2;\n\n\t\t}\n\n\t\tif ( Math.abs( centerLat - _cart.lat ) > Math.PI ) {\n\n\t\t\t_cart.lat += Math.sign( centerLat - _cart.lat ) * Math.PI * 2;\n\n\t\t}\n\n\t\tuv.push( _cart.lon, _cart.lat, _cart.height );\n\n\t\tminLat = Math.min( minLat, _cart.lat );\n\t\tmaxLat = Math.max( maxLat, _cart.lat );\n\n\t\tminLon = Math.min( minLon, _cart.lon );\n\t\tmaxLon = Math.max( maxLon, _cart.lon );\n\n\t\tminHeight = Math.min( minHeight, _cart.height );\n\t\tmaxHeight = Math.max( maxHeight, _cart.height );\n\n\t}\n\n\tconst range = [ minLon, minLat, maxLon, maxLat ];\n\tconst region = [ ...range, minHeight, maxHeight ];\n\treturn {\n\t\tuv,\n\t\trange,\n\t\tregion,\n\t};\n\n}\n\nexport function getMeshesCartographicRange( meshes, ellipsoid, meshToEllipsoidMatrix = null, tiling = null ) {\n\n\t// find the lat / lon ranges\n\tlet minLat = Infinity;\n\tlet minLon = Infinity;\n\tlet minHeight = Infinity;\n\tlet maxLat = - Infinity;\n\tlet maxLon = - Infinity;\n\tlet maxHeight = - Infinity;\n\tconst uvs = [];\n\n\tconst _matrix = new Matrix4();\n\tmeshes.forEach( mesh => {\n\n\t\t// multiply in the ellipsoid matrix if necessary\n\t\t_matrix.copy( mesh.matrixWorld );\n\t\tif ( meshToEllipsoidMatrix ) {\n\n\t\t\t_matrix.premultiply( meshToEllipsoidMatrix );\n\n\t\t}\n\n\t\tconst { uv, region } = getGeometryCartographicChannel( mesh.geometry, _matrix, ellipsoid );\n\t\tuvs.push( uv );\n\n\t\t// save the min and max values\n\t\tminLat = Math.min( minLat, region[ 1 ] );\n\t\tmaxLat = Math.max( maxLat, region[ 3 ] );\n\n\t\tminLon = Math.min( minLon, region[ 0 ] );\n\t\tmaxLon = Math.max( maxLon, region[ 2 ] );\n\n\t\tminHeight = Math.min( minHeight, region[ 4 ] );\n\t\tmaxHeight = Math.max( maxHeight, region[ 5 ] );\n\n\t} );\n\n\tlet clampedRange = [ minLon, minLat, maxLon, maxLat ];\n\tif ( tiling !== null ) {\n\n\t\t// Clamp the lat lon range to the bounds of the projection scheme. Note that clamping the data\n\t\t// allows for \"stretching\" the texture look at the edges of the projection which leads to a nicer\n\t\t// looking overlay. Eg at the poles of a web-mercator projection - otherwise there will be gaps\n\t\t// that show the underlying tile data. It's arguable which one is better but in all supported\n\t\t// ellipsoid projections (Web mercator, equirect) the projection ranges always span the entire\n\t\t// globe range.\n\t\t// const clampedRange = [ minLon, minLat, maxLon, maxLat ];\n\t\tclampedRange = tiling.clampToProjectionBounds( [ minLon, minLat, maxLon, maxLat ] );\n\t\tconst [ minU, minV, maxU, maxV ] = tiling.toNormalizedRange( clampedRange );\n\t\tuvs.forEach( uv => {\n\n\t\t\tfor ( let i = 0, l = uv.length; i < l; i += 3 ) {\n\n\t\t\t\tconst lon = uv[ i + 0 ];\n\t\t\t\tconst lat = uv[ i + 1 ];\n\t\t\t\tconst h = uv[ i + 2 ];\n\n\t\t\t\tconst [ u, v ] = tiling.toNormalizedPoint( lon, lat );\n\t\t\t\tuv[ i + 0 ] = MathUtils.mapLinear( u, minU, maxU, 0, 1 );\n\t\t\t\tuv[ i + 1 ] = MathUtils.mapLinear( v, minV, maxV, 0, 1 );\n\t\t\t\tuv[ i + 2 ] = MathUtils.mapLinear( h, minHeight, maxHeight, 0, 1 );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\treturn {\n\t\tuvs,\n\t\trange: clampedRange,\n\t\tregion: [ minLon, minLat, maxLon, maxLat, minHeight, maxHeight ],\n\t};\n\n}\n\n// functions for generating UVs for planar-projected UVs\nfunction getGeometryPlanarChannel( geometry, meshToFrame, aspectRatio ) {\n\n\tconst _vec = new Vector3();\n\tconst uv = [];\n\tconst posAttr = geometry.getAttribute( 'position' );\n\n\tlet minU = Infinity;\n\tlet minV = Infinity;\n\tlet minW = Infinity;\n\tlet maxU = - Infinity;\n\tlet maxV = - Infinity;\n\tlet maxW = - Infinity;\n\tfor ( let i = 0; i < posAttr.count; i ++ ) {\n\n\t\t// divide U by the aspect to stretch the U dimension to the aspect of the image\n\t\t_vec.fromBufferAttribute( posAttr, i ).applyMatrix4( meshToFrame );\n\t\t_vec.x /= aspectRatio;\n\n\t\tuv.push( _vec.x, _vec.y, _vec.z );\n\n\t\tminU = Math.min( minU, _vec.x );\n\t\tmaxU = Math.max( maxU, _vec.x );\n\n\t\tminV = Math.min( minV, _vec.y );\n\t\tmaxV = Math.max( maxV, _vec.y );\n\n\t\tminW = Math.min( minW, _vec.z );\n\t\tmaxW = Math.max( maxW, _vec.z );\n\n\t}\n\n\t// TODO: output a more complete bounds definition relative to the frame\n\tconst range = [ minU, minV, maxU, maxV ];\n\treturn {\n\t\tuv,\n\t\trange,\n\t\theightRange: [ minW, maxW ],\n\t};\n\n}\n\nexport function getMeshesPlanarRange( meshes, worldToFrame, tiling ) {\n\n\t// find the U / V ranges\n\tlet minU = Infinity;\n\tlet minV = Infinity;\n\tlet minW = Infinity;\n\tlet maxU = - Infinity;\n\tlet maxV = - Infinity;\n\tlet maxW = - Infinity;\n\tconst uvs = [];\n\n\tconst _matrix = new Matrix4();\n\tmeshes.forEach( mesh => {\n\n\t\t// multiply in the ellipsoid matrix if necessary\n\t\t_matrix.copy( mesh.matrixWorld );\n\t\tif ( worldToFrame ) {\n\n\t\t\t_matrix.premultiply( worldToFrame );\n\n\t\t}\n\n\t\tconst { uv, range, heightRange } = getGeometryPlanarChannel( mesh.geometry, _matrix, tiling.aspectRatio );\n\t\tuvs.push( uv );\n\n\t\t// save the min and max values\n\t\tminU = Math.min( minU, range[ 0 ] );\n\t\tmaxU = Math.max( maxU, range[ 2 ] );\n\n\t\tminV = Math.min( minV, range[ 1 ] );\n\t\tmaxV = Math.max( maxV, range[ 3 ] );\n\n\t\tminW = Math.min( minW, heightRange[ 0 ] );\n\t\tmaxW = Math.max( maxW, heightRange[ 1 ] );\n\n\t} );\n\n\tuvs.forEach( uv => {\n\n\t\tfor ( let i = 0, l = uv.length; i < l; i += 3 ) {\n\n\t\t\tconst u = uv[ i + 0 ];\n\t\t\tconst v = uv[ i + 1 ];\n\n\t\t\tuv[ i + 0 ] = MathUtils.mapLinear( u, minU, maxU, 0, 1 );\n\t\t\tuv[ i + 1 ] = MathUtils.mapLinear( v, minV, maxV, 0, 1 );\n\n\t\t}\n\n\t} );\n\n\t// TODO: output a more complete bounds definition relative to the frame\n\treturn {\n\t\tuvs,\n\t\trange: [ minU, minV, maxU, maxV ],\n\t\theightRange: [ minW, maxW ],\n\t};\n\n}\n","const OVERLAY_PARAMS = Symbol( 'OVERLAY_PARAMS' );\n\n// before compile can be used to chain shader adjustments. Returns the added uniforms used for fading.\nexport function wrapOverlaysMaterial( material, previousOnBeforeCompile ) {\n\n\t// if the material has already been wrapped then return the params\n\tif ( material[ OVERLAY_PARAMS ] ) {\n\n\t\treturn material[ OVERLAY_PARAMS ];\n\n\t}\n\n\tconst params = {\n\t\tlayerMaps: { value: [] },\n\t\tlayerColor: { value: [] },\n\t};\n\n\tmaterial[ OVERLAY_PARAMS ] = params;\n\n\tmaterial.defines = {\n\t\t...( material.defines || {} ),\n\t\tLAYER_COUNT: 0,\n\t};\n\n\tmaterial.onBeforeCompile = shader => {\n\n\t\tif ( previousOnBeforeCompile ) {\n\n\t\t\tpreviousOnBeforeCompile( shader );\n\n\t\t}\n\n\t\tshader.uniforms = {\n\t\t\t...shader.uniforms,\n\t\t\t...params,\n\t\t};\n\n\t\tshader.vertexShader = shader\n\t\t\t.vertexShader\n\t\t\t.replace( /void main\\(\\s*\\)\\s*{/, value => /* glsl */`\n\n\t\t\t\t#pragma unroll_loop_start\n\t\t\t\t\tfor ( int i = 0; i < 10; i ++ ) {\n\n\t\t\t\t\t\t#if UNROLLED_LOOP_INDEX < LAYER_COUNT\n\n\t\t\t\t\t\t\tattribute vec3 layer_uv_UNROLLED_LOOP_INDEX;\n\t\t\t\t\t\t\tvarying vec3 v_layer_uv_UNROLLED_LOOP_INDEX;\n\n\t\t\t\t\t\t#endif\n\n\n\t\t\t\t\t}\n\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t\t${ value }\n\n\t\t\t\t#pragma unroll_loop_start\n\t\t\t\t\tfor ( int i = 0; i < 10; i ++ ) {\n\n\t\t\t\t\t\t#if UNROLLED_LOOP_INDEX < LAYER_COUNT\n\n\t\t\t\t\t\t\tv_layer_uv_UNROLLED_LOOP_INDEX = layer_uv_UNROLLED_LOOP_INDEX;\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t}\n\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t` );\n\n\t\tshader.fragmentShader = shader\n\t\t\t.fragmentShader\n\t\t\t.replace( /void main\\(/, value => /* glsl */`\n\n\t\t\t\t#if LAYER_COUNT != 0\n\t\t\t\t\tstruct LayerTint {\n\t\t\t\t\t\tvec3 color;\n\t\t\t\t\t\tfloat opacity;\n\t\t\t\t\t};\n\n\t\t\t\t\tuniform sampler2D layerMaps[ LAYER_COUNT ];\n\t\t\t\t\tuniform LayerTint layerColor[ LAYER_COUNT ];\n\t\t\t\t#endif\n\n\t\t\t\t#pragma unroll_loop_start\n\t\t\t\t\tfor ( int i = 0; i < 10; i ++ ) {\n\n\t\t\t\t\t\t#if UNROLLED_LOOP_INDEX < LAYER_COUNT\n\n\t\t\t\t\t\t\tvarying vec3 v_layer_uv_UNROLLED_LOOP_INDEX;\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t}\n\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t\t${ value }\n\n\t\t\t` )\n\t\t\t.replace( /#include <color_fragment>/, value => /* glsl */`\n\n\t\t\t\t${ value }\n\n\t\t\t\t#if LAYER_COUNT != 0\n\t\t\t\t{\n\t\t\t\t\tvec4 tint;\n\t\t\t\t\tvec3 layerUV;\n\t\t\t\t\tfloat layerOpacity;\n\t\t\t\t\tfloat wOpacity;\n\t\t\t\t\tfloat wDelta;\n\t\t\t\t\t#pragma unroll_loop_start\n\t\t\t\t\t\tfor ( int i = 0; i < 10; i ++ ) {\n\n\t\t\t\t\t\t\t#if UNROLLED_LOOP_INDEX < LAYER_COUNT\n\n\t\t\t\t\t\t\t\tlayerUV = v_layer_uv_UNROLLED_LOOP_INDEX;\n\t\t\t\t\t\t\t\ttint = texture( layerMaps[ i ], layerUV.xy );\n\n\t\t\t\t\t\t\t\t// discard texture outside 0, 1 on w\n\t\t\t\t\t\t\t\twDelta = fwidth( layerUV.z );\n\t\t\t\t\t\t\t\twOpacity = smoothstep( - wDelta, 0.0, layerUV.z ) * smoothstep( 1.0 + wDelta, 1.0, layerUV.z );\n\n\t\t\t\t\t\t\t\t// apply tint & opacity\n\t\t\t\t\t\t\t\ttint.rgb *= layerColor[ i ].color;\n\t\t\t\t\t\t\t\ttint.rgba *= layerColor[ i ].opacity * wOpacity;\n\n\t\t\t\t\t\t\t\t// premultiplied alpha equation\n\t\t\t\t\t\t\t\tdiffuseColor = tint + diffuseColor * ( 1.0 - tint.a );\n\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t}\n\t\t\t\t\t#pragma unroll_loop_end\n\t\t\t\t}\n\t\t\t\t#endif\n\t\t\t` );\n\n\t};\n\n\treturn params;\n\n}\n","import { CanvasTexture, MathUtils, Vector3 } from 'three';\nimport { TiledImageSource } from './TiledImageSource.js';\nimport { ProjectionScheme } from '../utils/ProjectionScheme.js';\nimport { WGS84_ELLIPSOID } from '3d-tiles-renderer/three';\n\n// TODO: Add support for limited bounds\n// TODO: Add support for padding of tiles to avoid clipping \"wide\" elements\n// TODO: Need to clip / fix geojson shapes across the 180 degree boundary\n// TODO: Add support for easy regeneration when colors / styles / geojson change\n// TODO: Consider option to support world-space thickness definitions. Eg world-space point size or line thickness in meters.\n\n// function for calculating the the change in arc length at a given cartographic point\n// in order to preserve a circular look when drawing points\nconst _v0 = /* @__PURE__ */ new Vector3();\nconst _v1 = /* @__PURE__ */ new Vector3();\nfunction calculateArcRatioAtPoint( ellipsoid, lat, lon ) {\n\n\tconst DELTA = 0.01;\n\tellipsoid.getCartographicToPosition( lat, lon, 0, _v0 );\n\tellipsoid.getCartographicToPosition( lat + DELTA, lon, 0, _v1 );\n\n\tconst latDelta = _v0.distanceTo( _v1 );\n\tellipsoid.getCartographicToPosition( lat, lon + DELTA, 0, _v1 );\n\n\tconst lonDelta = _v0.distanceTo( _v1 );\n\treturn lonDelta / latDelta;\n\n}\n\nexport class GeoJSONImageSource extends TiledImageSource {\n\n\tconstructor( {\n\t\tgeojson = null,\n\t\turl = null, // URL or GeoJson object can be provided\n\t\ttileDimension = 256,\n\t\tlevels = 20,\n\t\tpointRadius = 6,\n\t\tstrokeStyle = 'white',\n\t\tstrokeWidth = 2,\n\t\tfillStyle = 'rgba( 255, 255, 255, 0.5 )',\n\t} = {} ) {\n\n\t\tsuper();\n\t\tthis.geojson = geojson;\n\t\tthis.url = url;\n\t\tthis.tileDimension = tileDimension;\n\t\tthis.levels = levels;\n\n\t\tthis.pointRadius = pointRadius;\n\t\tthis.strokeStyle = strokeStyle;\n\t\tthis.strokeWidth = strokeWidth;\n\t\tthis.fillStyle = fillStyle;\n\n\t}\n\n\tasync init() {\n\n\t\t// configure tiling to content bounds and levels\n\t\tconst { tiling, levels, tileDimension, geojson, url } = this;\n\t\tconst projection = new ProjectionScheme();\n\t\ttiling.setProjection( projection );\n\t\ttiling.setContentBounds( ...projection.getBounds() );\n\n\t\ttiling.generateLevels(\n\t\t\tlevels,\n\t\t\tprojection.tileCountX,\n\t\t\tprojection.tileCountY,\n\t\t\t{\n\t\t\t\ttilePixelWidth: tileDimension,\n\t\t\t\ttilePixelHeight: tileDimension,\n\t\t\t},\n\t\t);\n\n\t\t// If a URL was provided and no geojson object yet, fetch it now (use fetchData so overlay can inject headers)\n\t\tif ( ! geojson && url ) {\n\n\t\t\tconst res = await this.fetchData( url );\n\t\t\tthis.geojson = await res.json();\n\n\t\t}\n\n\t\t// TODO: If geojson present, compute bounds from data (with padding) and set as content bounds.\n\t\t// Falls back to full projection bounds if no geojson or unable to compute an extent.\n\n\t\t// seems that this approach to optimize rendering by defining bounds\n\t\t// doesn't work if not using a very large offset for the bounds, maybe an error?\n\t\tconst geoBounds = this._geoJSONBounds( 50 ).map( v => v * MathUtils.DEG2RAD );\n\t\tthis.tiling.setContentBounds( ...geoBounds );\n\n\t}\n\n\t// main fetch per tile - > returns .Texture\n\tasync fetchItem( tokens, signal ) {\n\n\t\treturn this.drawCanvasImage( tokens );\n\n\t}\n\n\tdrawCanvasImage( tokens ) {\n\n\t\tconst { tiling, tileDimension, geojson } = this;\n\t\tconst [ x, y, level ] = tokens;\n\t\tconst tileBoundsDeg = tiling.getTileBounds( x, y, level, false, false ).map( v => MathUtils.RAD2DEG * v );\n\n\t\t// create canvas\n\t\tconst canvas = document.createElement( 'canvas' );\n\t\tcanvas.width = tileDimension;\n\t\tcanvas.height = tileDimension;\n\n\t\t// draw features\n\t\tconst ctx = canvas.getContext( '2d' );\n\t\tconst features = this._featuresFromGeoJSON( geojson );\n\t\tfor ( let i = 0; i < features.length; i ++ ) {\n\n\t\t\tconst feature = features[ i ];\n\t\t\tif ( this._featureIntersectsTile( feature, tileBoundsDeg ) ) {\n\n\t\t\t\tthis._drawFeatureOnCanvas( ctx, feature, tileBoundsDeg, canvas.width, canvas.height );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst tex = new CanvasTexture( canvas );\n\t\ttex.needsUpdate = true;\n\t\treturn tex;\n\n\t}\n\n\t// bbox quick test in projected units\n\t_featureIntersectsTile( feature, boundsDeg ) {\n\n\t\tconst featureBoundsDeg = this._getFeatureBounds( feature );\n\t\tif ( ! featureBoundsDeg ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// check for intersection between bounds\n\t\tconst [ fminX, fminY, fmaxX, fmaxY ] = featureBoundsDeg;\n\t\tconst [ minX, minY, maxX, maxY ] = boundsDeg;\n\t\treturn ! ( fmaxX < minX || fminX > maxX || fmaxY < minY || fminY > maxY );\n\n\t}\n\n\t_getFeatureBounds( feature ) {\n\n\t\tconst { geometry } = feature;\n\t\tif ( ! geometry ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst { type, coordinates } = geometry;\n\t\tlet minLon = Infinity;\n\t\tlet minLat = Infinity;\n\t\tlet maxLon = - Infinity;\n\t\tlet maxLat = - Infinity;\n\n\t\tconst expandBoundsByPoint = ( lon, lat ) => {\n\n\t\t\tminLon = Math.min( minLon, lon );\n\t\t\tmaxLon = Math.max( maxLon, lon );\n\t\t\tminLat = Math.min( minLat, lat );\n\t\t\tmaxLat = Math.max( maxLat, lat );\n\n\t\t};\n\n\t\tif ( type === 'Point' ) {\n\n\t\t\texpandBoundsByPoint( coordinates[ 0 ], coordinates[ 1 ] );\n\n\t\t} else if ( type === 'MultiPoint' || type === 'LineString' ) {\n\n\t\t\tcoordinates.forEach( c => expandBoundsByPoint( c[ 0 ], c[ 1 ] ) );\n\n\t\t} else if ( type === 'MultiLineString' || type === 'Polygon' ) {\n\n\t\t\tcoordinates.forEach( ring => ring.forEach( c => expandBoundsByPoint( c[ 0 ], c[ 1 ] ) ) );\n\n\t\t} else if ( type === 'MultiPolygon' ) {\n\n\t\t\tcoordinates.forEach( polygon =>\n\t\t\t\tpolygon.forEach( ring => ring.forEach( c => expandBoundsByPoint( c[ 0 ], c[ 1 ] ) ) ),\n\t\t\t);\n\n\t\t}\n\n\t\treturn [ minLon, minLat, maxLon, maxLat ];\n\n\t}\n\n\t// Normalize top-level geojson into an array of Feature objects\n\t_featuresFromGeoJSON( root ) {\n\n\t\tconst type = root.type;\n\t\tconst geomTypes = new Set( [ 'Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon' ] );\n\n\t\tif ( type === 'FeatureCollection' ) {\n\n\t\t\treturn root.features;\n\n\t\t} else if ( type === 'Feature' ) {\n\n\t\t\treturn [ root ];\n\n\t\t} else if ( type === 'GeometryCollection' ) {\n\n\t\t\treturn root.geometries.map( g => ( { type: 'Feature', geometry: g, properties: {} } ) );\n\n\t\t} else if ( geomTypes.has( type ) ) {\n\n\t\t\treturn [ { type: 'Feature', geometry: root, properties: {} } ];\n\n\t\t} else {\n\n\t\t\treturn [];\n\n\t\t}\n\n\t}\n\n\t// draw feature on canvas ( assumes intersects already )\n\t_drawFeatureOnCanvas( ctx, feature, tileBoundsDeg, width, height ) {\n\n\t\tconst { geometry = null, properties = {} } = feature;\n\t\tif ( ! geometry ) {\n\n\t\t\t// A feature may have null geometry in GeoJSON\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst [ minLonDeg, minLatDeg, maxLonDeg, maxLatDeg ] = tileBoundsDeg;\n\t\tconst strokeStyle = properties.strokeStyle || this.strokeStyle;\n\t\tconst fillStyle = properties.fillStyle || this.fillStyle;\n\t\tconst pointRadius = properties.pointRadius || this.pointRadius;\n\t\tconst strokeWidth = properties.strokeWidth || this.strokeWidth;\n\n\t\tctx.save();\n\t\tctx.strokeStyle = strokeStyle;\n\t\tctx.fillStyle = fillStyle;\n\t\tctx.lineWidth = strokeWidth;\n\n\t\t// Compute pixel from cartographic coordinates and tile bounds\n\t\tconst arr = new Array( 2 );\n\t\tconst projectPoint = ( lon, lat, target = arr ) => {\n\n\t\t\t// canvas y origin is top, projection y increases north -> flip\n\t\t\tconst x = MathUtils.mapLinear( lon, minLonDeg, maxLonDeg, 0, width );\n\t\t\tconst y = height - MathUtils.mapLinear( lat, minLatDeg, maxLatDeg, 0, height );\n\n\t\t\t// round to integer to gain performance\n\t\t\t// https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas#avoid_floating-point_coordinates_and_use_integers_instead\n\t\t\ttarget[ 0 ] = Math.round( x );\n\t\t\ttarget[ 1 ] = Math.round( y );\n\t\t\treturn target;\n\n\t\t};\n\n\t\tconst calculateAspectRatio = ( lon, lat ) => {\n\n\t\t\t// calculates the aspect ratio with which to draw points\n\t\t\tconst latRad = lat * MathUtils.DEG2RAD;\n\t\t\tconst lonRad = lon * MathUtils.DEG2RAD;\n\t\t\tconst pxLat = ( maxLatDeg - minLatDeg ) / height;\n\t\t\tconst pxLon = ( maxLonDeg - minLonDeg ) / width;\n\t\t\tconst pixelRatio = pxLon / pxLat;\n\n\t\t\t// TODO: this should use the ellipsoid defined on the relevant tiles renderer\n\t\t\treturn pixelRatio * calculateArcRatioAtPoint( WGS84_ELLIPSOID, latRad, lonRad );\n\n\t\t};\n\n\t\tconst type = geometry.type;\n\t\tif ( type === 'Point' ) {\n\n\t\t\tconst [ lon, lat ] = geometry.coordinates;\n\t\t\tconst [ px, py ] = projectPoint( lon, lat );\n\t\t\tconst drawRatio = calculateAspectRatio( lon, lat );\n\n\t\t\tctx.beginPath();\n\t\t\tctx.ellipse( px, py, pointRadius / drawRatio, pointRadius, 0, 0, Math.PI * 2 );\n\t\t\tctx.fill();\n\t\t\tctx.stroke();\n\n\t\t} else if ( type === 'MultiPoint' ) {\n\n\t\t\tgeometry.coordinates.forEach( ( [ lon, lat ] ) => {\n\n\t\t\t\tconst [ px, py ] = projectPoint( lon, lat );\n\t\t\t\tconst drawRatio = calculateAspectRatio( lon, lat );\n\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.ellipse( px, py, pointRadius / drawRatio, pointRadius, 0, 0, Math.PI * 2 );\n\t\t\t\tctx.fill();\n\t\t\t\tctx.stroke();\n\n\t\t\t} );\n\n\t\t} else if ( type === 'LineString' ) {\n\n\t\t\tctx.beginPath();\n\t\t\tgeometry.coordinates.forEach( ( [ lon, lat ], i ) => {\n\n\t\t\t\tconst [ px, py ] = projectPoint( lon, lat );\n\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\tctx.moveTo( px, py );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tctx.lineTo( px, py );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tctx.stroke();\n\n\t\t} else if ( type === 'MultiLineString' ) {\n\n\t\t\tctx.beginPath();\n\t\t\tgeometry.coordinates.forEach( ( line ) => {\n\n\t\t\t\tline.forEach( ( [ lon, lat ], i ) => {\n\n\t\t\t\t\tconst [ px, py ] = projectPoint( lon, lat );\n\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\tctx.moveTo( px, py );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tctx.lineTo( px, py );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t} );\n\t\t\tctx.stroke();\n\n\t\t} else if ( type === 'Polygon' ) {\n\n\t\t\tctx.beginPath();\n\t\t\tgeometry.coordinates.forEach( ( ring, rIndex ) => {\n\n\t\t\t\tring.forEach( ( [ lon, lat ], i ) => {\n\n\t\t\t\t\tconst [ px, py ] = projectPoint( lon, lat );\n\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\tctx.moveTo( px, py );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tctx.lineTo( px, py );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\t\t\t\tctx.closePath();\n\n\t\t\t} );\n\t\t\tctx.fill( 'evenodd' );\n\t\t\tctx.stroke();\n\n\t\t} else if ( type === 'MultiPolygon' ) {\n\n\t\t\tgeometry.coordinates.forEach( ( polygon ) => {\n\n\t\t\t\tctx.beginPath();\n\t\t\t\tpolygon.forEach( ( ring, rIndex ) => {\n\n\t\t\t\t\tring.forEach( ( [ lon, lat ], i ) => {\n\n\t\t\t\t\t\tconst [ px, py ] = projectPoint( lon, lat );\n\t\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\t\tctx.moveTo( px, py );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tctx.lineTo( px, py );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\t\t\t\t\tctx.closePath();\n\n\t\t\t\t} );\n\t\t\t\tctx.fill( 'evenodd' );\n\t\t\t\tctx.stroke();\n\n\t\t\t} );\n\n\t\t}\n\n\t\tctx.restore();\n\n\t}\n\n\t// Compute geographic bounds in degrees from current geojson.\n\t_geoJSONBounds() {\n\n\t\t// TODO: add support for padding the bounding boxes\n\t\tconst features = this._featuresFromGeoJSON( this.geojson );\n\t\tlet minLon = Infinity;\n\t\tlet minLat = Infinity;\n\t\tlet maxLon = - Infinity;\n\t\tlet maxLat = - Infinity;\n\n\t\tfeatures.forEach( feature => {\n\n\t\t\tconst [ fMinLon, fMinLat, fMaxLon, fMaxLat ] = this._getFeatureBounds( feature );\n\t\t\tminLon = Math.min( minLon, fMinLon );\n\t\t\tminLat = Math.min( minLat, fMinLat );\n\t\t\tmaxLon = Math.max( maxLon, fMaxLon );\n\t\t\tmaxLat = Math.max( maxLat, fMaxLat );\n\n\t\t} );\n\n\t\treturn [ minLon, minLat, maxLon, maxLat ];\n\n\t}\n\n}\n","import { WebGLRenderTarget, Color, SRGBColorSpace, BufferAttribute, Matrix4, Vector3, Box3, Triangle, CanvasTexture } from 'three';\nimport { PriorityQueue } from '3d-tiles-renderer/core';\nimport { CesiumIonAuth, GoogleCloudAuth } from '3d-tiles-renderer/core/plugins';\nimport { TiledTextureComposer } from './overlays/TiledTextureComposer.js';\nimport { XYZImageSource } from './sources/XYZImageSource.js';\nimport { TMSImageSource } from './sources/TMSImageSource.js';\nimport { forEachTileInBounds, getMeshesCartographicRange, getMeshesPlanarRange } from './overlays/utils.js';\nimport { wrapOverlaysMaterial } from './overlays/wrapOverlaysMaterial.js';\nimport { GeometryClipper } from '../utilities/GeometryClipper.js';\nimport { WMTSImageSource } from './sources/WMTSImageSource.js';\nimport { MemoryUtils } from '3d-tiles-renderer/three';\nimport { GeoJSONImageSource } from './sources/GeoJSONImageSource.js';\nimport { WMSImageSource } from './sources/WMSImageSource.js';\n\nconst _matrix = /* @__PURE__ */ new Matrix4();\nconst _vec = /* @__PURE__ */ new Vector3();\nconst _center = /* @__PURE__ */ new Vector3();\nconst _sphereCenter = /* @__PURE__ */ new Vector3();\nconst _normal = /* @__PURE__ */ new Vector3();\nconst _box = /* @__PURE__ */ new Box3();\nconst SPLIT_TILE_DATA = Symbol( 'SPLIT_TILE_DATA' );\nconst SPLIT_HASH = Symbol( 'SPLIT_HASH' );\n\n// function for marking and releasing images in the given overlay\nfunction markOverlayImages( range, level, overlay, doRelease ) {\n\n\t// return null immediately if possible to allow for drawing without delay where possible\n\tif ( Array.isArray( overlay ) ) {\n\n\t\tconst promises = overlay\n\t\t\t.map( o => markOverlayImages( range, level, o, doRelease ) )\n\t\t\t.filter( p => p !== null );\n\n\t\tif ( promises.length === 0 ) {\n\n\t\t\treturn null;\n\n\t\t} else {\n\n\t\t\treturn Promise.all( promises );\n\n\t\t}\n\n\t}\n\n\tif ( ! overlay.isReady ) {\n\n\t\treturn overlay.whenReady().then( markImages );\n\n\t} else {\n\n\t\treturn markImages();\n\n\t}\n\n\tfunction markImages() {\n\n\t\tconst promises = [];\n\t\tconst { imageSource, tiling } = overlay;\n\t\tforEachTileInBounds( range, level, tiling, overlay.isPlanarProjection, ( tx, ty, tl ) => {\n\n\t\t\tif ( doRelease ) {\n\n\t\t\t\timageSource.release( tx, ty, tl );\n\n\t\t\t} else {\n\n\t\t\t\tpromises.push( imageSource.lock( tx, ty, tl ) );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tconst filteredPromises = promises.filter( p => p instanceof Promise );\n\t\tif ( filteredPromises.length !== 0 ) {\n\n\t\t\treturn Promise.all( filteredPromises );\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n}\n\n// returns the total number of tiles that will be drawn for the provided range\nfunction countTilesInRange( range, level, overlay ) {\n\n\tlet total = 0;\n\tforEachTileInBounds( range, level, overlay.tiling, overlay.isPlanarProjection, ( x, y, l ) => {\n\n\t\ttotal ++;\n\n\t} );\n\n\treturn total;\n\n}\n\n// Plugin for overlaying tiled image data on top of 3d tiles geometry.\nexport class ImageOverlayPlugin {\n\n\tget enableTileSplitting() {\n\n\t\treturn this._enableTileSplitting;\n\n\t}\n\n\tset enableTileSplitting( v ) {\n\n\t\tif ( this._enableTileSplitting !== v ) {\n\n\t\t\tthis._enableTileSplitting = v;\n\t\t\tthis._markNeedsUpdate();\n\n\t\t}\n\n\t}\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\toverlays = [],\n\t\t\tresolution = 256,\n\t\t\trenderer = null,\n\t\t\tenableTileSplitting = true,\n\t\t} = options;\n\n\t\t// plugin needs to run before other plugins that fetch data since content\n\t\t// is handled and loaded in a custom way\n\t\tthis.name = 'IMAGE_OVERLAY_PLUGIN';\n\t\tthis.priority = - 15;\n\n\t\t// options\n\t\tthis.renderer = renderer;\n\t\tthis.resolution = resolution;\n\t\tthis._enableTileSplitting = enableTileSplitting;\n\t\tthis.overlays = [];\n\n\t\t// internal\n\t\tthis.needsUpdate = false;\n\t\tthis.tiles = null;\n\t\tthis.tileComposer = null;\n\t\tthis.tileControllers = new Map();\n\t\tthis.overlayInfo = new Map();\n\t\tthis.usedTextures = new Set();\n\t\tthis.meshParams = new WeakMap();\n\t\tthis.pendingTiles = new Map();\n\t\tthis.processQueue = null;\n\t\tthis._onUpdateAfter = null;\n\t\tthis._onTileDownloadStart = null;\n\t\tthis._cleanupScheduled = false;\n\t\tthis._virtualChildResetId = 0;\n\t\tthis._bytesUsed = new WeakMap();\n\n\t\toverlays.forEach( overlay => {\n\n\t\t\tthis.addOverlay( overlay );\n\n\t\t} );\n\n\t}\n\n\t// plugin functions\n\tinit( tiles ) {\n\n\t\tconst tileComposer = new TiledTextureComposer( this.renderer );\n\t\tconst processQueue = new PriorityQueue();\n\t\tprocessQueue.maxJobs = 10;\n\t\tprocessQueue.priorityCallback = ( a, b ) => {\n\n\t\t\tconst tileA = a.tile;\n\t\t\tconst tileB = b.tile;\n\n\t\t\tconst visibleA = tiles.visibleTiles.has( tileA );\n\t\t\tconst visibleB = tiles.visibleTiles.has( tileB );\n\t\t\tif ( visibleA !== visibleB ) {\n\n\t\t\t\t// load visible tiles first\n\t\t\t\treturn visibleA ? 1 : - 1;\n\n\t\t\t} else {\n\n\t\t\t\t// the fallback to the download queue tile priority\n\t\t\t\treturn tiles.downloadQueue.priorityCallback( tileA, tileB );\n\n\t\t\t}\n\n\t\t\t// TODO: we could prioritize by overlay order here to ensure consistency\n\n\t\t};\n\n\t\t// save variables\n\t\tthis.tiles = tiles;\n\t\tthis.tileComposer = tileComposer;\n\t\tthis.processQueue = processQueue;\n\n\t\t// init all existing tiles\n\t\ttiles.forEachLoadedModel( ( scene, tile ) => {\n\n\t\t\tthis._processTileModel( scene, tile, true );\n\n\t\t} );\n\n\t\t// update callback for when overlays have changed\n\t\tthis._onUpdateAfter = async () => {\n\n\t\t\t// check if the projection changed for any of the overlays and refresh them\n\t\t\tlet overlayChanged = false;\n\t\t\tthis.overlayInfo.forEach( ( info, overlay ) => {\n\n\t\t\t\tif (\n\t\t\t\t\tBoolean( overlay.frame ) !== Boolean( info.frame ) ||\n\t\t\t\t\toverlay.frame && info.frame && ! info.frame.equals( overlay.frame )\n\t\t\t\t) {\n\n\t\t\t\t\tconst order = info.order;\n\t\t\t\t\tthis.deleteOverlay( overlay, false );\n\t\t\t\t\tthis.addOverlay( overlay, order );\n\n\t\t\t\t\toverlayChanged = true;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\t// trigger redraws for visible tiles if overlays updated\n\t\t\tif ( overlayChanged ) {\n\n\t\t\t\tconst maxJobs = processQueue.maxJobs;\n\t\t\t\tlet count = 0;\n\t\t\t\tprocessQueue.items.forEach( info => {\n\n\t\t\t\t\tif ( tiles.visibleTiles.has( info.tile ) ) {\n\n\t\t\t\t\t\tcount ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tprocessQueue.maxJobs = count + processQueue.currJobs;\n\t\t\t\tprocessQueue.tryRunJobs();\n\t\t\t\tprocessQueue.maxJobs = maxJobs;\n\n\t\t\t\tthis.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\t// update all the layer uvs\n\t\t\tif ( this.needsUpdate ) {\n\n\t\t\t\tthis.needsUpdate = false;\n\n\t\t\t\tconst { overlays, overlayInfo } = this;\n\t\t\t\toverlays.sort( ( a, b ) => {\n\n\t\t\t\t\treturn overlayInfo.get( a ).order - overlayInfo.get( b ).order;\n\n\t\t\t\t} );\n\n\t\t\t\ttiles.forEachLoadedModel( ( scene, tile ) => {\n\n\t\t\t\t\tthis._updateLayers( tile );\n\n\t\t\t\t} );\n\n\t\t\t\tthis.resetVirtualChildren( ! this.enableTileSplitting );\n\t\t\t\ttiles.recalculateBytesUsed();\n\n\t\t\t\ttiles.dispatchEvent( { type: 'needs-rerender' } );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis._onTileDownloadStart = ( { tile } ) => {\n\n\t\t\tthis._initTileOverlayInfo( tile );\n\n\t\t};\n\n\t\ttiles.addEventListener( 'update-after', this._onUpdateAfter );\n\t\ttiles.addEventListener( 'tile-download-start', this._onTileDownloadStart );\n\n\t\tthis.overlays.forEach( overlay => {\n\n\t\t\tthis._initOverlay( overlay );\n\n\t\t} );\n\n\t}\n\n\tdisposeTile( tile ) {\n\n\t\tconst { overlayInfo, tileControllers, processQueue, pendingTiles } = this;\n\n\t\t// Cancel any ongoing tasks. If a tile is cancelled while downloading\n\t\t// this will not have been created, yet.\n\t\tif ( tileControllers.has( tile ) ) {\n\n\t\t\ttileControllers.get( tile ).abort();\n\t\t\ttileControllers.delete( tile );\n\t\t\tpendingTiles.delete( tile );\n\n\t\t}\n\n\t\t// stop any tile loads\n\t\toverlayInfo.forEach( ( ( { tileInfo }, overlay ) => {\n\n\t\t\tif ( tileInfo.has( tile ) ) {\n\n\t\t\t\tconst { meshInfo, range, meshRange, level, target, meshRangeMarked, rangeMarked } = tileInfo.get( tile );\n\n\t\t\t\t// release the ranges\n\t\t\t\tif ( meshRange !== null && meshRangeMarked ) {\n\n\t\t\t\t\tmarkOverlayImages( meshRange, level, overlay, true );\n\n\t\t\t\t}\n\n\t\t\t\tif ( range !== null && rangeMarked ) {\n\n\t\t\t\t\tmarkOverlayImages( range, level, overlay, true );\n\n\t\t\t\t}\n\n\t\t\t\tif ( target !== null ) {\n\n\t\t\t\t\t// release the render targets\n\t\t\t\t\ttarget.dispose();\n\n\t\t\t\t}\n\n\t\t\t\ttileInfo.delete( tile );\n\t\t\t\tmeshInfo.clear();\n\n\t\t\t}\n\n\t\t} ) );\n\n\t\t// Remove any items that reference the tile being disposed\n\t\tprocessQueue.removeByFilter( item => {\n\n\t\t\treturn item.tile === tile;\n\n\t\t} );\n\n\t}\n\n\tcalculateBytesUsed( tile ) {\n\n\t\tconst { overlayInfo } = this;\n\t\tconst bytesUsed = this._bytesUsed;\n\n\t\tlet bytes = null;\n\t\toverlayInfo.forEach( ( { tileInfo }, overlay ) => {\n\n\t\t\tif ( tileInfo.has( tile ) ) {\n\n\t\t\t\tconst { target } = tileInfo.get( tile );\n\t\t\t\tbytes = bytes || 0;\n\t\t\t\tbytes += MemoryUtils.safeTextureGetByteLength( target?.texture );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( bytes !== null ) {\n\n\t\t\tbytesUsed.set( tile, bytes );\n\t\t\treturn bytes;\n\n\t\t} else if ( bytesUsed.has( tile ) ) {\n\n\t\t\treturn bytesUsed.get( tile );\n\n\t\t} else {\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\tprocessTileModel( scene, tile ) {\n\n\t\treturn this._processTileModel( scene, tile );\n\n\t}\n\n\tasync _processTileModel( scene, tile, initialization = false ) {\n\n\t\tthis.tileControllers.set( tile, new AbortController() );\n\n\t\tif ( ! initialization ) {\n\n\t\t\t// we save all these pending tiles so that they can be correctly initialized if an\n\t\t\t// overlay is added in the time between when this function starts and after the async\n\t\t\t// await call. Otherwise the tile could be missed. But if we're initializing the plugin\n\t\t\t// then we don't need to do this because the tiles are already included in the traversal.\n\t\t\tthis.pendingTiles.set( tile, scene );\n\n\t\t}\n\n\t\tthis._wrapMaterials( scene );\n\t\tthis._initTileOverlayInfo( tile );\n\t\tawait this._initTileSceneOverlayInfo( scene, tile );\n\t\tthis.expandVirtualChildren( scene, tile );\n\t\tthis._updateLayers( tile );\n\n\t\tthis.pendingTiles.delete( tile );\n\n\t}\n\n\tdispose() {\n\n\t\tconst { tileComposer, tiles } = this;\n\n\t\t// dispose textures\n\t\ttileComposer.dispose();\n\n\t\t// dispose of all overlays\n\t\tconst overlays = [ ...this.overlays ];\n\t\toverlays.forEach( overlay => {\n\n\t\t\tthis.deleteOverlay( overlay );\n\n\t\t} );\n\n\t\t// reset the textures of the meshes\n\t\ttiles.forEachLoadedModel( ( scene, tile ) => {\n\n\t\t\tthis._updateLayers( tile );\n\t\t\tthis.disposeTile( tile );\n\n\t\t\tdelete tile[ SPLIT_HASH ];\n\n\t\t} );\n\n\t\ttiles.removeEventListener( 'update-after', this._onUpdateAfter );\n\n\t\tthis.resetVirtualChildren( true );\n\n\t}\n\n\tgetAttributions( target ) {\n\n\t\tthis.overlays.forEach( overlay => {\n\n\t\t\tif ( overlay.opacity > 0 ) {\n\n\t\t\t\toverlay.getAttributions( target );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\tparseToMesh( buffer, tile, extension, uri ) {\n\n\t\tif ( extension === 'image_overlay_tile_split' ) {\n\n\t\t\treturn tile[ SPLIT_TILE_DATA ];\n\n\t\t}\n\n\t}\n\n\tasync resetVirtualChildren( fullDispose = false ) {\n\n\t\t// only run this if all the overlays are ready and tile targets have been generated, etc\n\t\t// so we can make an effort to only remove the necessary tiles.\n\t\tthis._virtualChildResetId ++;\n\t\tconst id = this._virtualChildResetId;\n\n\t\tawait Promise.all( this.overlays.map( o => o.whenReady() ) );\n\n\t\tif ( id !== this._virtualChildResetId ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// collect the tiles split into virtual tiles\n\t\tconst { tiles } = this;\n\t\tconst parents = new Set();\n\t\ttiles.forEachLoadedModel( ( scene, tile ) => {\n\n\t\t\tif ( SPLIT_HASH in tile ) {\n\n\t\t\t\tparents.add( tile );\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// dispose of the virtual children if this tile would not be split or the spilt could change\n\t\t// under the current overlays used.\n\t\tparents.forEach( parent => {\n\n\t\t\tif ( parent.parent === null ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst clone = parent.cached.scene.clone();\n\t\t\tclone.updateMatrixWorld();\n\n\t\t\tconst { hash } = this._getSplitVectors( clone, parent );\n\t\t\tif ( parent[ SPLIT_HASH ] !== hash || fullDispose ) {\n\n\t\t\t\t// TODO: if are parent tile is forcibly remove then we should make sure that all the children are, too?\n\t\t\t\tconst children = collectChildren( parent );\n\t\t\t\tchildren.sort( ( a, b ) => ( b.__depth || 0 ) - ( a.__depth || 0 ) );\n\n\t\t\t\t// note that we need to remove children from the processing queue in this case\n\t\t\t\t// because we are forcibly evicting them from the cache.\n\t\t\t\tchildren.forEach( child => {\n\n\t\t\t\t\ttiles.processNodeQueue.remove( child );\n\t\t\t\t\ttiles.lruCache.remove( child );\n\t\t\t\t\tchild.parent = null;\n\n\t\t\t\t} );\n\n\t\t\t\tparent.children.length = 0;\n\t\t\t\tparent.__childrenProcessed = 0;\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// re-expand tiles if needed\n\t\tif ( ! fullDispose ) {\n\n\t\t\ttiles.forEachLoadedModel( ( scene, tile ) => {\n\n\t\t\t\tthis.expandVirtualChildren( scene, tile );\n\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction collectChildren( root, target = [] ) {\n\n\t\t\troot.children.forEach( child => {\n\n\t\t\t\ttarget.push( child );\n\t\t\t\tcollectChildren( child, target );\n\n\t\t\t} );\n\t\t\treturn target;\n\n\t\t}\n\n\t}\n\n\t_getSplitVectors( scene, tile, centerTarget = _center ) {\n\n\t\tconst { tiles, overlayInfo } = this;\n\n\t\t// get the center of the content\n\t\tconst box = new Box3();\n\t\tbox.setFromObject( scene );\n\t\tbox.getCenter( centerTarget );\n\n\t\t// find the vectors that are orthogonal to every overlay projection\n\t\tconst splitDirections = [];\n\t\tconst hashTokens = [];\n\t\toverlayInfo.forEach( ( { tileInfo }, overlay ) => {\n\n\t\t\t// if the tile has a render target associated with the overlay and the last level of detail\n\t\t\t// is not being displayed, yet, then we need to split\n\t\t\tconst info = tileInfo.get( tile );\n\t\t\tif ( info && info.target && overlay.tiling.maxLevel > info.level ) {\n\n\t\t\t\t// get the vector representing the projection direction\n\t\t\t\tif ( overlay.frame ) {\n\n\t\t\t\t\t_normal.set( 0, 0, 1 ).transformDirection( overlay.frame );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttiles.ellipsoid.getPositionToNormal( centerTarget, _normal );\n\t\t\t\t\tif ( _normal.length() < 1e-6 ) {\n\n\t\t\t\t\t\t_normal.set( 1, 0, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// dedupe vectors in the hash\n\t\t\t\tconst token = `${ _normal.x.toFixed( 3 ) },${ _normal.y.toFixed( 3 ) },${ _normal.z.toFixed( 3 ) }_`;\n\t\t\t\tif ( ! hashTokens.includes( token ) ) {\n\n\t\t\t\t\thashTokens.push( token );\n\n\t\t\t\t}\n\n\t\t\t\t// construct the orthogonal vectors\n\t\t\t\tconst other = _vec.set( 0, 0, 1 );\n\t\t\t\tif ( Math.abs( _normal.dot( other ) ) > 1 - 1e-4 ) {\n\n\t\t\t\t\tother.set( 1, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tconst ortho0 = new Vector3().crossVectors( _normal, other ).normalize();\n\t\t\t\tconst ortho1 = new Vector3().crossVectors( _normal, ortho0 ).normalize();\n\t\t\t\tsplitDirections.push( ortho0, ortho1 );\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// Generate a reduced set of vectors by averages directions in a 45 degree cone so\n\t\t// we don't split unnecessarily\n\t\tconst directions = [];\n\t\twhile ( splitDirections.length !== 0 ) {\n\n\t\t\tconst normalized = splitDirections.pop().clone();\n\t\t\tconst average = normalized.clone();\n\t\t\tfor ( let i = 0; i < splitDirections.length; i ++ ) {\n\n\t\t\t\tconst dir = splitDirections[ i ];\n\t\t\t\tconst dotProduct = normalized.dot( dir );\n\t\t\t\tif ( Math.abs( dotProduct ) > Math.cos( Math.PI / 8 ) ) {\n\n\t\t\t\t\taverage.addScaledVector( dir, Math.sign( dotProduct ) );\n\t\t\t\t\tnormalized.copy( average ).normalize();\n\t\t\t\t\tsplitDirections.splice( i, 1 );\n\t\t\t\t\ti --;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdirections.push( average.normalize() );\n\n\t\t}\n\n\t\treturn { directions, hash: hashTokens.join( '' ) };\n\n\t}\n\n\tasync expandVirtualChildren( scene, tile ) {\n\n\t\tif ( tile.children.length !== 0 || this.enableTileSplitting === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// create a copy of the content to transform and split\n\t\tconst clone = scene.clone();\n\t\tclone.updateMatrixWorld();\n\n\t\t// get the directions to split on\n\t\tconst { directions, hash } = this._getSplitVectors( clone, tile, _center );\n\t\ttile[ SPLIT_HASH ] = hash;\n\n\t\t// if there are no directions to split on then exit early\n\t\tif ( directions.length === 0 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// set up the splitter to ignore overlay uvs\n\t\tconst clipper = new GeometryClipper();\n\t\tclipper.attributeList = key => ! /^layer_uv_\\d+/.test( key );\n\t\tdirections.map( splitDirection => {\n\n\t\t\tclipper.addSplitOperation( ( geometry, i0, i1, i2, barycoord, matrixWorld ) => {\n\n\t\t\t\tTriangle.getInterpolatedAttribute( geometry.attributes.position, i0, i1, i2, barycoord, _vec );\n\t\t\t\treturn _vec.applyMatrix4( matrixWorld ).sub( _center ).dot( splitDirection );\n\n\t\t\t} );\n\n\t\t} );\n\n\t\t// run the clipping operations by performing every permutation of sides\n\t\t// defined by the split directions\n\t\tconst children = [];\n\t\tclipper.forEachSplitPermutation( () => {\n\n\t\t\t// clip the object itself\n\t\t\tconst result = clipper.clipObject( clone );\n\n\t\t\t// remove the parent transform because it will be multiplied back in after the fact\n\t\t\tresult.matrix\n\t\t\t\t.premultiply( tile.cached.transformInverse )\n\t\t\t\t.decompose( result.position, result.quaternion, result.scale );\n\n\t\t\t// collect the meshes\n\t\t\tconst meshes = [];\n\t\t\tresult.traverse( c => {\n\n\t\t\t\tif ( c.isMesh ) {\n\n\t\t\t\t\tconst material = c.material.clone();\n\t\t\t\t\tc.material = material;\n\t\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\t\tconst value = material[ key ];\n\t\t\t\t\t\tif ( value && value.isTexture ) {\n\n\t\t\t\t\t\t\tif ( value.source.data instanceof ImageBitmap ) {\n\n\t\t\t\t\t\t\t\t// clone any image bitmap textures using canvas because if we share the texture then when\n\t\t\t\t\t\t\t\t// the clipped child is disposed then it will dispose of the parent tile texture data, as well.\n\t\t\t\t\t\t\t\tconst canvas = document.createElement( 'canvas' );\n\t\t\t\t\t\t\t\tcanvas.width = value.image.width;\n\t\t\t\t\t\t\t\tcanvas.height = value.image.height;\n\n\t\t\t\t\t\t\t\tconst ctx = canvas.getContext( '2d' );\n\t\t\t\t\t\t\t\tctx.scale( 1, - 1 );\n\t\t\t\t\t\t\t\tctx.drawImage( value.source.data, 0, 0, canvas.width, - canvas.height );\n\n\t\t\t\t\t\t\t\tconst tex = new CanvasTexture( canvas );\n\t\t\t\t\t\t\t\ttex.mapping = value.mapping;\n\t\t\t\t\t\t\t\ttex.wrapS = value.wrapS;\n\t\t\t\t\t\t\t\ttex.wrapT = value.wrapT;\n\t\t\t\t\t\t\t\ttex.minFilter = value.minFilter;\n\t\t\t\t\t\t\t\ttex.magFilter = value.magFilter;\n\t\t\t\t\t\t\t\ttex.format = value.format;\n\t\t\t\t\t\t\t\ttex.type = value.type;\n\t\t\t\t\t\t\t\ttex.anisotropy = value.anisotropy;\n\t\t\t\t\t\t\t\ttex.colorSpace = value.colorSpace;\n\t\t\t\t\t\t\t\ttex.generateMipmaps = value.generateMipmaps;\n\n\t\t\t\t\t\t\t\tmaterial[ key ] = tex;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmeshes.push( c );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tif ( meshes.length === 0 ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// generate a region bounding volume\n\t\t\tconst boundingVolume = {};\n\t\t\tif ( tile.boundingVolume.region ) {\n\n\t\t\t\tboundingVolume.region = getMeshesCartographicRange( meshes, this.tiles.ellipsoid ).region;\n\n\t\t\t}\n\n\t\t\t// create a sphere bounding volume\n\t\t\tif ( tile.boundingVolume.box || tile.boundingVolume.sphere ) {\n\n\t\t\t\t// TODO: we create a sphere even when a region is present because currently the handling of region volumes\n\t\t\t\t// is a bit flaky especially at small scales. OBBs are generated which can be imperfect resulting rays passing\n\t\t\t\t// through tiles. The same may be the case with frustum checks. In theory, though, we should not need a sphere\n\t\t\t\t// bounds if a region bounds are present.\n\n\t\t\t\t// compute the sphere center\n\t\t\t\t_box\n\t\t\t\t\t.setFromObject( result, true )\n\t\t\t\t\t.getCenter( _sphereCenter );\n\n\t\t\t\t// calculate the sq radius from all vertices\n\t\t\t\tlet maxSqRadius = 0;\n\t\t\t\tresult.traverse( c => {\n\n\t\t\t\t\tconst geometry = c.geometry;\n\t\t\t\t\tif ( geometry ) {\n\n\t\t\t\t\t\tconst position = geometry.attributes.position;\n\t\t\t\t\t\tfor ( let i = 0, l = position.count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst sqRadius = _vec\n\t\t\t\t\t\t\t\t.fromBufferAttribute( position, i )\n\t\t\t\t\t\t\t\t.applyMatrix4( c.matrixWorld )\n\t\t\t\t\t\t\t\t.distanceToSquared( _sphereCenter );\n\n\t\t\t\t\t\t\tmaxSqRadius = Math.max( maxSqRadius, sqRadius );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tboundingVolume.sphere = [ ..._sphereCenter, Math.sqrt( maxSqRadius ) ];\n\n\t\t\t}\n\n\t\t\tchildren.push( {\n\t\t\t\trefine: 'REPLACE',\n\t\t\t\tgeometricError: tile.geometricError * 0.5,\n\t\t\t\tboundingVolume: boundingVolume,\n\t\t\t\tcontent: { uri: './child.image_overlay_tile_split' },\n\t\t\t\tchildren: [],\n\t\t\t\t[ SPLIT_TILE_DATA ]: result,\n\t\t\t} );\n\n\t\t} );\n\n\t\ttile.children.push( ...children );\n\n\t}\n\n\tfetchData( uri, options ) {\n\n\t\t// if this is our custom url indicating a tile split then return fake response\n\t\tif ( /image_overlay_tile_split/.test( uri ) ) {\n\n\t\t\treturn new ArrayBuffer();\n\n\t\t}\n\n\t}\n\n\t// public\n\taddOverlay( overlay, order = null ) {\n\n\t\tconst { tiles, overlays, overlayInfo } = this;\n\n\t\tif ( order === null ) {\n\n\t\t\t// set the order to the next largest order value\n\t\t\torder = overlays.reduce( ( v, o ) => Math.max( v, o.order + 1 ), 0 );\n\n\t\t}\n\n\t\tconst controller = new AbortController();\n\t\toverlays.push( overlay );\n\t\toverlayInfo.set( overlay, {\n\t\t\torder: order,\n\t\t\tuniforms: {},\n\t\t\ttileInfo: new Map(),\n\t\t\tcontroller: controller,\n\t\t\tframe: overlay.frame ? overlay.frame.clone() : null,\n\t\t} );\n\n\t\tif ( tiles !== null ) {\n\n\t\t\tthis._initOverlay( overlay );\n\n\t\t}\n\n\t}\n\n\tsetOverlayOrder( overlay, order ) {\n\n\t\tconst index = this.overlays.indexOf( overlay );\n\t\tif ( index !== - 1 ) {\n\n\t\t\tthis.overlayInfo.get( overlay ).order = order;\n\t\t\tthis._markNeedsUpdate();\n\n\t\t}\n\n\t}\n\n\tdeleteOverlay( overlay, forceDispose = true ) {\n\n\t\tconst { overlays, overlayInfo, processQueue } = this;\n\t\tconst index = overlays.indexOf( overlay );\n\t\tif ( index !== - 1 ) {\n\n\t\t\tconst { tileInfo, controller } = overlayInfo.get( overlay );\n\t\t\ttileInfo.forEach( ( { meshInfo, target } ) => {\n\n\t\t\t\tif ( target !== null ) {\n\n\t\t\t\t\ttarget.dispose();\n\n\t\t\t\t}\n\n\t\t\t\tmeshInfo.clear();\n\n\t\t\t} );\n\n\t\t\ttileInfo.clear();\n\t\t\toverlayInfo.delete( overlay );\n\t\t\tcontroller.abort();\n\n\t\t\t// Remove any items that reference the overlay being disposed\n\t\t\tprocessQueue.removeByFilter( item => {\n\n\t\t\t\treturn item.overlay === overlay;\n\n\t\t\t} );\n\n\t\t\toverlays.splice( index, 1 );\n\t\t\tif ( forceDispose ) {\n\n\t\t\t\toverlay.dispose();\n\n\t\t\t}\n\n\t\t\tthis._markNeedsUpdate();\n\n\t\t}\n\n\t}\n\n\t// internal\n\t_calculateLevelFromOverlay( overlay, range, tile, normalized = false ) {\n\n\t\tif ( overlay.isPlanarProjection ) {\n\n\t\t\tconst { resolution } = this;\n\t\t\tconst { tiling } = overlay;\n\n\t\t\tconst normalizedRange = normalized ? range : tiling.toNormalizedRange( range );\n\t\t\tconst [ minX, minY, maxX, maxY ] = normalizedRange;\n\t\t\tconst w = maxX - minX;\n\t\t\tconst h = maxY - minY;\n\n\t\t\tlet level = 0;\n\t\t\tconst { maxLevel } = tiling;\n\t\t\tfor ( ; level < maxLevel; level ++ ) {\n\n\t\t\t\t// the number of pixels per image on each axis\n\t\t\t\tconst wProj = resolution / w;\n\t\t\t\tconst hProj = resolution / h;\n\n\t\t\t\tconst { pixelWidth, pixelHeight } = tiling.getLevel( level );\n\t\t\t\tif ( pixelWidth >= wProj || pixelHeight >= hProj ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// TODO: should this be one layer higher LoD?\n\t\t\treturn level;\n\n\t\t} else {\n\n\t\t\treturn tile.__depthFromRenderedParent - 1;\n\n\t\t}\n\n\t}\n\n\t// initialize the overlay to use the right fetch options, load all data for existing tiles\n\t_initOverlay( overlay ) {\n\n\t\tconst { tiles } = this;\n\t\toverlay.imageSource.fetchOptions = tiles.fetchOptions;\n\t\tif ( ! overlay.isInitialized ) {\n\n\t\t\toverlay.imageSource.fetchData = ( ...args ) => tiles\n\t\t\t\t.downloadQueue\n\t\t\t\t.add( { priority: - performance.now() }, () => {\n\n\t\t\t\t\treturn overlay.fetch( ...args );\n\n\t\t\t\t} );\n\t\t\toverlay.init();\n\n\t\t}\n\n\t\tconst promises = [];\n\t\tconst initTile = async ( scene, tile ) => {\n\n\t\t\tthis._initTileOverlayInfo( tile, overlay );\n\n\t\t\tconst promise = this._initTileSceneOverlayInfo( scene, tile, overlay );\n\t\t\tpromises.push( promise );\n\n\t\t\t// mark tiles as needing an update after initialized so we get a trickle in of tiles\n\t\t\tawait promise;\n\t\t\tthis._updateLayers( tile );\n\n\t\t};\n\n\t\ttiles.forEachLoadedModel( initTile );\n\t\tthis.pendingTiles.forEach( ( scene, tile ) => {\n\n\t\t\tinitTile( scene, tile );\n\n\t\t} );\n\n\t\tPromise.all( promises ).then( () => {\n\n\t\t\tthis._markNeedsUpdate();\n\n\t\t} );\n\n\t}\n\n\t// wrap all materials in the given scene wit the overlay material shader\n\t_wrapMaterials( scene ) {\n\n\t\tscene.traverse( c => {\n\n\t\t\tif ( c.material ) {\n\n\t\t\t\tconst params = wrapOverlaysMaterial( c.material, c.material.onBeforeCompile );\n\t\t\t\tthis.meshParams.set( c, params );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t// Initialize per-tile overlay information. This function triggers an async function but\n\t// does not need to be awaited for use since it's just locking textures which are awaited later.\n\t_initTileOverlayInfo( tile, overlay = this.overlays ) {\n\n\t\tif ( Array.isArray( overlay ) ) {\n\n\t\t\toverlay.forEach( o => this._initTileOverlayInfo( tile, o ) );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// This function is resilient to multiple calls in case an overlay is added after a tile starts loading\n\t\t// and before it is loaded, meaning this function needs to be called twice to ensure it's initialized.\n\t\tconst { overlayInfo, processQueue } = this;\n\t\tif ( overlayInfo.get( overlay ).tileInfo.has( tile ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst level = tile.__depthFromRenderedParent - 1;\n\t\tconst info = {\n\t\t\trange: null,\n\t\t\tmeshRange: null,\n\t\t\tlevel: null,\n\t\t\ttarget: null,\n\t\t\tmeshInfo: new Map(),\n\n\t\t\trangeMarked: false,\n\t\t\tmeshRangeMarked: false,\n\t\t};\n\n\t\toverlayInfo\n\t\t\t.get( overlay )\n\t\t\t.tileInfo\n\t\t\t.set( tile, info );\n\n\t\tif ( overlay.isPlanarProjection ) {\n\n\t\t\t// TODO: we could project the shape into the frame, compute 2d bounds, and then mark tiles\n\n\t\t} else {\n\n\t\t\t// If the tile has a region bounding volume then mark the tiles to preload\n\t\t\tif ( tile.boundingVolume.region ) {\n\n\t\t\t\tconst [ minLon, minLat, maxLon, maxLat ] = tile.boundingVolume.region;\n\t\t\t\tconst range = [ minLon, minLat, maxLon, maxLat ];\n\t\t\t\tinfo.range = range;\n\t\t\t\tinfo.level = this._calculateLevelFromOverlay( overlay, range, tile );\n\n\t\t\t\tprocessQueue\n\t\t\t\t\t.add( { tile, overlay }, () => {\n\n\t\t\t\t\t\tinfo.rangeMarked = true;\n\t\t\t\t\t\treturn markOverlayImages( range, level, overlay, false );\n\n\t\t\t\t\t} )\n\t\t\t\t\t.catch( () => {\n\n\t\t\t\t\t\t// the queue throws an error if a task is removed early\n\n\t\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// initialize the scene meshes\n\tasync _initTileSceneOverlayInfo( scene, tile, overlay = this.overlays ) {\n\n\t\tif ( Array.isArray( overlay ) ) {\n\n\t\t\treturn Promise.all( overlay.map( o => this._initTileSceneOverlayInfo( scene, tile, o ) ) );\n\n\t\t}\n\n\t\tconst { tiles, overlayInfo, resolution, tileComposer, tileControllers, usedTextures, processQueue } = this;\n\t\tconst { ellipsoid } = tiles;\n\t\tconst { controller, tileInfo } = overlayInfo.get( overlay );\n\t\tconst tileController = tileControllers.get( tile );\n\n\t\t// wait for the overlay to be completely loaded so projection and tiling are available\n\t\tif ( ! overlay.isReady ) {\n\n\t\t\tawait overlay.whenReady();\n\n\t\t}\n\n\t\t// check if the overlay or tile have been disposed since starting this function\n\t\t// if the tileController is not present then the tile has been disposed of already\n\t\tif ( controller.signal.aborted || tileController.signal.aborted ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// find all meshes to project on and ensure matrices are up to date\n\t\tconst meshes = [];\n\t\tscene.updateMatrixWorld();\n\t\tscene.traverse( c => {\n\n\t\t\tif ( c.isMesh ) {\n\n\t\t\t\tmeshes.push( c );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tconst { tiling, imageSource } = overlay;\n\t\tconst info = tileInfo.get( tile );\n\t\tlet range, uvs, heightInRange;\n\n\t\t// retrieve the uvs and range for all the meshes\n\t\tif ( overlay.isPlanarProjection ) {\n\n\t\t\t_matrix.copy( overlay.frame );\n\t\t\tif ( scene.parent !== null ) {\n\n\t\t\t\t_matrix.multiply( tiles.group.matrixWorldInverse );\n\n\t\t\t}\n\n\t\t\tlet heightRange;\n\t\t\t( { range, uvs, heightRange } = getMeshesPlanarRange( meshes, _matrix, tiling ) );\n\t\t\theightInRange = ! ( heightRange[ 0 ] > 1 || heightRange[ 1 ] < 0 );\n\n\t\t} else {\n\n\t\t\t_matrix.identity();\n\t\t\tif ( scene.parent !== null ) {\n\n\t\t\t\t_matrix.copy( tiles.group.matrixWorldInverse );\n\n\t\t\t}\n\n\t\t\t( { range, uvs } = getMeshesCartographicRange( meshes, ellipsoid, _matrix, tiling ) );\n\t\t\theightInRange = true;\n\n\t\t}\n\n\t\tlet normalizedRange;\n\t\tif ( ! overlay.isPlanarProjection ) {\n\n\t\t\tnormalizedRange = tiling.toNormalizedRange( range );\n\n\t\t} else {\n\n\t\t\tnormalizedRange = range;\n\n\t\t}\n\n\t\t// calculate the tiling level here if not already created\n\t\tif ( info.level === null ) {\n\n\t\t\tinfo.level = this._calculateLevelFromOverlay( overlay, normalizedRange, tile, true );\n\n\t\t}\n\n\t\t// if the image projection is outside the 0, 1 uvw range or there are no textures to draw in\n\t\t// the tiled image set the don't allocate a texture for it.\n\t\tlet target = null;\n\t\tif ( heightInRange && countTilesInRange( range, info.level, overlay ) !== 0 ) {\n\n\t\t\ttarget = new WebGLRenderTarget( resolution, resolution, {\n\t\t\t\tdepthBuffer: false,\n\t\t\t\tstencilBuffer: false,\n\t\t\t\tgenerateMipmaps: false,\n\t\t\t\tcolorSpace: SRGBColorSpace,\n\t\t\t} );\n\n\t\t}\n\n\t\tinfo.meshRange = range;\n\t\tinfo.target = target;\n\n\t\tmeshes.forEach( ( mesh, i ) => {\n\n\t\t\tconst array = new Float32Array( uvs[ i ] );\n\t\t\tconst attribute = new BufferAttribute( array, 3 );\n\t\t\tinfo.meshInfo.set( mesh, { attribute } );\n\n\t\t} );\n\n\t\tif ( target !== null ) {\n\n\t\t\tawait processQueue\n\t\t\t\t.add( { tile, overlay }, async () => {\n\n\t\t\t\t\tinfo.meshRangeMarked = true;\n\n\t\t\t\t\tconst promise = markOverlayImages( range, info.level, overlay, false );\n\t\t\t\t\tif ( promise ) {\n\n\t\t\t\t\t\t// if the previous layer is present then draw it as an overlay to fill in any gaps while we wait for\n\t\t\t\t\t\t// the next set of textures\n\t\t\t\t\t\ttileComposer.setRenderTarget( target, normalizedRange );\n\t\t\t\t\t\ttileComposer.clear( 0xffffff, 0 );\n\n\t\t\t\t\t\tforEachTileInBounds( range, info.level - 1, tiling, overlay.isPlanarProjection, ( tx, ty, tl ) => {\n\n\t\t\t\t\t\t\t// draw using normalized bounds since the mercator bounds are non-linear\n\t\t\t\t\t\t\tconst span = tiling.getTileBounds( tx, ty, tl, true, false );\n\t\t\t\t\t\t\tconst tex = imageSource.get( tx, ty, tl );\n\t\t\t\t\t\t\tif ( tex && ! ( tex instanceof Promise ) ) {\n\n\t\t\t\t\t\t\t\ttileComposer.draw( tex, span );\n\t\t\t\t\t\t\t\tusedTextures.add( tex );\n\t\t\t\t\t\t\t\tthis._scheduleCleanup();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\ttry {\n\n\t\t\t\t\t\t\tawait promise;\n\n\t\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t\t// skip errors since this will throw when aborted\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// check if the overlay has been disposed since starting this function\n\t\t\t\t\tif ( controller.signal.aborted || tileController.signal.aborted ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// draw the textures\n\t\t\t\t\ttileComposer.setRenderTarget( target, normalizedRange );\n\t\t\t\t\ttileComposer.clear( 0xffffff, 0 );\n\n\t\t\t\t\tforEachTileInBounds( range, info.level, tiling, overlay.isPlanarProjection, ( tx, ty, tl ) => {\n\n\t\t\t\t\t\t// draw using normalized bounds since the mercator bounds are non-linear\n\t\t\t\t\t\tconst span = tiling.getTileBounds( tx, ty, tl, true, false );\n\t\t\t\t\t\tconst tex = imageSource.get( tx, ty, tl );\n\t\t\t\t\t\ttileComposer.draw( tex, span );\n\t\t\t\t\t\tusedTextures.add( tex );\n\t\t\t\t\t\tthis._scheduleCleanup();\n\n\t\t\t\t\t} );\n\n\t\t\t\t} )\n\t\t\t\t.catch( () => {\n\n\t\t\t\t\t// the queue throws an error if a task is removed early\n\n\t\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t_updateLayers( tile ) {\n\n\t\tconst { overlayInfo, overlays, tileControllers } = this;\n\t\tconst tileController = tileControllers.get( tile );\n\n\t\t// by this point all targets should be present and we can force the memory to update\n\t\tthis.tiles.recalculateBytesUsed( tile );\n\n\t\t// if the tile has been disposed before this function is called then exit early\n\t\tif ( ! tileController || tileController.signal.aborted ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// update the uvs and texture overlays for each mesh\n\t\toverlays.forEach( ( overlay, i ) => {\n\n\t\t\tconst { tileInfo } = overlayInfo.get( overlay );\n\t\t\tconst { meshInfo, target } = tileInfo.get( tile );\n\t\t\tmeshInfo.forEach( ( { attribute }, mesh ) => {\n\n\t\t\t\tconst { geometry, material } = mesh;\n\t\t\t\tconst params = this.meshParams.get( mesh );\n\n\t\t\t\t// assign the new uvs\n\t\t\t\tconst key = `layer_uv_${ i }`;\n\t\t\t\tif ( geometry.getAttribute( key ) !== attribute ) {\n\n\t\t\t\t\tgeometry.setAttribute( key, attribute );\n\t\t\t\t\tgeometry.dispose();\n\n\t\t\t\t}\n\n\t\t\t\t// set the uniform array lengths\n\t\t\t\tparams.layerMaps.length = overlays.length;\n\t\t\t\tparams.layerColor.length = overlays.length;\n\n\t\t\t\t// assign the uniforms\n\t\t\t\tparams.layerMaps.value[ i ] = target !== null ? target.texture : null;\n\t\t\t\tparams.layerColor.value[ i ] = overlay;\n\n\t\t\t\tmaterial.defines.LAYER_COUNT = overlays.length;\n\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\t_scheduleCleanup() {\n\n\t\t// clean up textures used for drawing the tile overlays\n\t\tif ( ! this._cleanupScheduled ) {\n\n\t\t\tthis._cleanupScheduled = true;\n\t\t\trequestAnimationFrame( () => {\n\n\t\t\t\tconst { usedTextures } = this;\n\t\t\t\tusedTextures.forEach( tex => {\n\n\t\t\t\t\ttex.dispose();\n\n\t\t\t\t} );\n\n\t\t\t\tusedTextures.clear();\n\t\t\t\tthis._cleanupScheduled = false;\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t_markNeedsUpdate() {\n\n\t\tif ( this.needsUpdate === false ) {\n\n\t\t\tthis.needsUpdate = true;\n\t\t\tif ( this.tiles !== null ) {\n\n\t\t\t\tthis.tiles.dispatchEvent( { type: 'needs-update' } );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nclass ImageOverlay {\n\n\tget tiling() {\n\n\t\treturn this.imageSource.tiling;\n\n\t}\n\n\tget projection() {\n\n\t\treturn this.tiling.projection;\n\n\t}\n\n\tget isPlanarProjection() {\n\n\t\treturn Boolean( this.frame );\n\n\t}\n\n\tget aspectRatio() {\n\n\t\treturn this.tiling && this.isReady ? this.tiling.aspectRatio : 1;\n\n\t}\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\topacity = 1,\n\t\t\tcolor = 0xffffff,\n\t\t\tframe = null,\n\t\t} = options;\n\t\tthis.imageSource = null;\n\t\tthis.opacity = opacity;\n\t\tthis.color = new Color( color );\n\t\tthis.frame = frame !== null ? frame.clone() : null;\n\t\tthis.isReady = false;\n\t\tthis.isInitialized = false;\n\n\t}\n\n\tinit() {\n\n\t\tthis.isInitialized = true;\n\t\tthis.whenReady().then( () => {\n\n\t\t\tthis.isReady = true;\n\n\t\t} );\n\n\t}\n\n\tfetch( ...args ) {\n\n\t\treturn fetch( ...args );\n\n\t}\n\n\twhenReady() {\n\n\t}\n\n\tgetAttributions( target ) {\n\n\t}\n\n\tdispose() {\n\n\t\tthis.imageSource.dispose();\n\n\t}\n\n}\n\nexport class XYZTilesOverlay extends ImageOverlay {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( options );\n\t\tthis.imageSource = new XYZImageSource( options );\n\t\tthis.imageSource.fetchData = ( ...args ) => this.fetch( ...args );\n\n\t}\n\n\tinit() {\n\n\t\tthis._whenReady = this.imageSource.init();\n\n\t\tsuper.init();\n\n\t}\n\n\twhenReady() {\n\n\t\treturn this._whenReady;\n\n\t}\n\n}\n\nexport class GeoJSONOverlay extends ImageOverlay {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( options );\n\t\tthis.imageSource = new GeoJSONImageSource( options );\n\t\tthis.imageSource.fetchData = ( ...args ) => this.fetch( ...args );\n\n\t}\n\n\tinit() {\n\n\t\tthis._whenReady = this.imageSource.init();\n\t\tsuper.init();\n\n\t}\n\n\twhenReady() {\n\n\t\treturn this._whenReady;\n\n\t}\n\n}\n\nexport class WMSTilesOverlay extends ImageOverlay {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( options );\n\t\tthis.imageSource = new WMSImageSource( options );\n\t\tthis.imageSource.fetchData = ( ...args ) => this.fetch( ...args );\n\n\t}\n\n\tinit() {\n\n\t\tthis._whenReady = this.imageSource.init();\n\t\tsuper.init();\n\n\t}\n\n\twhenReady() {\n\n\t\treturn this._whenReady;\n\n\t}\n\n}\n\nexport class WMTSTilesOverlay extends ImageOverlay {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( options );\n\t\tthis.imageSource = new WMTSImageSource( options );\n\t\tthis.imageSource.fetchData = ( ...args ) => this.fetch( ...args );\n\n\t}\n\n\tinit() {\n\n\t\tthis._whenReady = this.imageSource.init();\n\n\t\tsuper.init();\n\n\t}\n\n\twhenReady() {\n\n\t\treturn this._whenReady;\n\n\t}\n\n}\n\nexport class TMSTilesOverlay extends ImageOverlay {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( options );\n\t\tthis.imageSource = new TMSImageSource( options );\n\t\tthis.imageSource.fetchData = ( ...args ) => this.fetch( ...args );\n\t\tthis.url = options.url;\n\n\t}\n\n\tinit() {\n\n\t\tthis._whenReady = this.imageSource.init();\n\n\t\tsuper.init();\n\n\t}\n\n\twhenReady() {\n\n\t\treturn this._whenReady;\n\n\t}\n\n}\n\nexport class CesiumIonOverlay extends ImageOverlay {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( options );\n\n\t\tconst { apiToken, autoRefreshToken, assetId } = options;\n\t\tthis.assetId = assetId;\n\t\tthis.auth = new CesiumIonAuth( { apiToken, autoRefreshToken } );\n\t\tthis.imageSource = new TMSImageSource( options );\n\n\t\tthis.auth.authURL = `https://api.cesium.com/v1/assets/${ assetId }/endpoint`;\n\t\tthis.imageSource.fetchData = ( ...args ) => this.fetch( ...args );\n\t\tthis._attributions = [];\n\n\t}\n\n\tinit() {\n\n\t\tthis._whenReady = this\n\t\t\t.auth\n\t\t\t.refreshToken()\n\t\t\t.then( json => {\n\n\t\t\t\tthis._attributions = json.attributions.map( att => ( {\n\t\t\t\t\tvalue: att.html,\n\t\t\t\t\ttype: 'html',\n\t\t\t\t\tcollapsible: att.collapsible,\n\t\t\t\t} ) );\n\n\t\t\t\tthis.imageSource.url = json.url;\n\t\t\t\treturn this.imageSource.init();\n\n\t\t\t} );\n\n\t\tsuper.init();\n\n\t}\n\n\tfetch( ...args ) {\n\n\t\treturn this.auth.fetch( ...args );\n\n\t}\n\n\twhenReady() {\n\n\t\treturn this._whenReady;\n\n\t}\n\n\tgetAttributions( target ) {\n\n\t\ttarget.push( ...this._attributions );\n\n\t}\n\n}\n\nexport class GoogleMapsOverlay extends ImageOverlay {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( options );\n\n\t\tconst { apiToken, sessionOptions, autoRefreshToken, logoUrl } = options;\n\t\tthis.logoUrl = logoUrl;\n\t\tthis.auth = new GoogleCloudAuth( { apiToken, sessionOptions, autoRefreshToken } );\n\t\tthis.imageSource = new XYZImageSource();\n\n\t\tthis.imageSource.fetchData = ( ...args ) => this.fetch( ...args );\n\t\tthis._logoAttribution = {\n\t\t\tvalue: '',\n\t\t\ttype: 'image',\n\t\t\tcollapsible: false,\n\t\t};\n\n\t}\n\n\tinit() {\n\n\t\tthis._whenReady = this\n\t\t\t.auth\n\t\t\t.refreshToken()\n\t\t\t.then( json => {\n\n\t\t\t\tthis.imageSource.tileDimension = json.tileWidth;\n\t\t\t\tthis.imageSource.url = 'https://tile.googleapis.com/v1/2dtiles/{z}/{x}/{y}';\n\t\t\t\treturn this.imageSource.init();\n\n\t\t\t} );\n\n\t\tsuper.init();\n\n\t}\n\n\tfetch( ...args ) {\n\n\t\treturn this.auth.fetch( ...args );\n\n\t}\n\n\twhenReady() {\n\n\t\treturn this._whenReady;\n\n\t}\n\n\tgetAttributions( target ) {\n\n\t\tif ( this.logoUrl ) {\n\n\t\t\tthis._logoAttribution.value = this.logoUrl;\n\t\t\ttarget.push( this._logoAttribution );\n\n\t\t}\n\n\t}\n\n}\n"],"names":["_camera","OrthographicCamera","_color","Color","TiledTextureComposer","renderer","Mesh","PlaneGeometry","ComposeTextureMaterial","renderTarget","range","texture","span","quad","material","MathUtils","currentRenderTarget","currentAutoClear","color","alpha","currentClearColor","currentClearAlpha","ShaderMaterial","v","DoubleSide","Vector2","forEachTileInBounds","level","tiling","normalized","callback","minLon","minLat","maxLon","maxLat","clampedLevel","minX","minY","maxX","maxY","x","y","getGeometryCartographicChannel","geometry","geomToEllipsoidMatrix","ellipsoid","_vec","Vector3","_cart","uv","posAttr","centerLat","centerLon","minHeight","maxHeight","i","region","getMeshesCartographicRange","meshes","meshToEllipsoidMatrix","uvs","_matrix","Matrix4","mesh","clampedRange","minU","minV","maxU","maxV","l","lon","lat","h","u","getGeometryPlanarChannel","meshToFrame","aspectRatio","minW","maxW","getMeshesPlanarRange","worldToFrame","heightRange","OVERLAY_PARAMS","wrapOverlaysMaterial","previousOnBeforeCompile","params","shader","value","_v0","_v1","calculateArcRatioAtPoint","latDelta","GeoJSONImageSource","TiledImageSource","geojson","url","tileDimension","levels","pointRadius","strokeStyle","strokeWidth","fillStyle","projection","ProjectionScheme","res","geoBounds","tokens","signal","tileBoundsDeg","canvas","ctx","features","feature","tex","CanvasTexture","boundsDeg","featureBoundsDeg","fminX","fminY","fmaxX","fmaxY","type","coordinates","expandBoundsByPoint","c","ring","polygon","root","geomTypes","g","width","height","properties","minLonDeg","minLatDeg","maxLonDeg","maxLatDeg","arr","projectPoint","target","calculateAspectRatio","latRad","lonRad","pxLat","WGS84_ELLIPSOID","px","py","drawRatio","line","rIndex","fMinLon","fMinLat","fMaxLon","fMaxLat","_center","_sphereCenter","_normal","_box","Box3","SPLIT_TILE_DATA","SPLIT_HASH","markOverlayImages","overlay","doRelease","promises","o","p","markImages","imageSource","tx","ty","tl","filteredPromises","countTilesInRange","total","ImageOverlayPlugin","options","overlays","resolution","enableTileSplitting","tiles","tileComposer","processQueue","PriorityQueue","a","b","tileA","tileB","visibleA","visibleB","scene","tile","overlayChanged","info","order","maxJobs","count","overlayInfo","tileControllers","pendingTiles","tileInfo","meshInfo","meshRange","meshRangeMarked","rangeMarked","item","bytesUsed","bytes","MemoryUtils.safeTextureGetByteLength","initialization","buffer","extension","uri","fullDispose","id","parents","parent","clone","hash","children","collectChildren","child","centerTarget","box","splitDirections","hashTokens","token","other","ortho0","ortho1","directions","average","dir","dotProduct","clipper","GeometryClipper","key","splitDirection","i0","i1","i2","barycoord","matrixWorld","Triangle","result","boundingVolume","maxSqRadius","position","sqRadius","controller","forceDispose","index","normalizedRange","w","maxLevel","wProj","hProj","pixelWidth","pixelHeight","args","initTile","promise","usedTextures","tileController","heightInRange","WebGLRenderTarget","SRGBColorSpace","array","attribute","BufferAttribute","ImageOverlay","opacity","frame","XYZTilesOverlay","XYZImageSource","GeoJSONOverlay","CesiumIonOverlay","apiToken","autoRefreshToken","assetId","CesiumIonAuth","TMSImageSource","json","att"],"mappings":"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"}