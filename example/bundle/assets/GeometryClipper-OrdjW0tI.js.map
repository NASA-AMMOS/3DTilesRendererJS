{"version":3,"file":"GeometryClipper-OrdjW0tI.js","sources":["../../../src/core/plugins/auth/CesiumIonAuth.js","../../../src/three/plugins/utilities/GeometryClipper.js"],"sourcesContent":["// Class for making fetches to Cesium Ion, refreshing the token if needed.\nexport class CesiumIonAuth {\n\n\tconstructor( options = {} ) {\n\n\t\tconst { apiToken, autoRefreshToken = false } = options;\n\t\tthis.apiToken = apiToken;\n\t\tthis.autoRefreshToken = autoRefreshToken;\n\t\tthis.authURL = null;\n\t\tthis._tokenRefreshPromise = null;\n\t\tthis._bearerToken = null;\n\n\t}\n\n\tasync fetch( url, options ) {\n\n\t\tawait this._tokenRefreshPromise;\n\n\t\t// insert the authorization token\n\t\tconst fetchOptions = { ...options };\n\t\tfetchOptions.headers = fetchOptions.headers || {};\n\t\tfetchOptions.headers = {\n\t\t\t...fetchOptions.headers,\n\t\t\tAuthorization: this._bearerToken,\n\t\t};\n\n\t\t// try to refresh the token if we failed to load the tile data\n\t\tconst res = await fetch( url, fetchOptions );\n\t\tif ( res.status >= 400 && res.status <= 499 && this.autoRefreshToken ) {\n\n\t\t\t// refresh the bearer token\n\t\t\tawait this.refreshToken( options );\n\t\t\tfetchOptions.headers.Authorization = this._bearerToken;\n\n\t\t\treturn fetch( url, fetchOptions );\n\n\t\t} else {\n\n\t\t\treturn res;\n\n\t\t}\n\n\t}\n\n\trefreshToken( options ) {\n\n\t\tif ( this._tokenRefreshPromise === null ) {\n\n\t\t\t// construct the url to fetch the endpoint\n\t\t\tconst url = new URL( this.authURL );\n\t\t\turl.searchParams.set( 'access_token', this.apiToken );\n\n\t\t\tthis._tokenRefreshPromise = fetch( url, options )\n\t\t\t\t.then( res => {\n\n\t\t\t\t\tif ( ! res.ok ) {\n\n\t\t\t\t\t\tthrow new Error( `CesiumIonAuthPlugin: Failed to load data with error code ${ res.status }` );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn res.json();\n\n\t\t\t\t} )\n\t\t\t\t.then( json => {\n\n\t\t\t\t\tthis._bearerToken = `Bearer ${ json.accessToken }`;\n\t\t\t\t\tthis._tokenRefreshPromise = null;\n\n\t\t\t\t\treturn json;\n\n\t\t\t\t} );\n\n\t\t}\n\n\t\treturn this._tokenRefreshPromise;\n\n\t}\n\n}\n","import { MathUtils, Triangle, BufferGeometry, BufferAttribute, Mesh, Vector4 } from 'three';\n\nconst SPLIT_VALUE = 0;\nconst vertNames = [ 'a', 'b', 'c' ];\nconst _vec = /* @__PURE__ */ new Vector4();\nconst _v0 = /* @__PURE__ */ new Vector4();\nconst _v1 = /* @__PURE__ */ new Vector4();\nconst _v2 = /* @__PURE__ */ new Vector4();\n\n// Class for clipping geometry using the results from a \"split operation\"\nexport class GeometryClipper {\n\n\tconstructor() {\n\n\t\t// the list of attributes to use in the geometry being clipped, such as\n\t\t// [ 'position', 'normal', 'uv' ]\n\t\tthis.attributeList = null;\n\n\t\t// internal\n\t\tthis.splitOperations = [];\n\t\tthis.trianglePool = new ClipTrianglePool();\n\n\t}\n\n\tforEachSplitPermutation( callback ) {\n\n\t\tconst { splitOperations } = this;\n\t\tconst runPermutations = ( index = 0 ) => {\n\n\t\t\tif ( index >= splitOperations.length ) {\n\n\t\t\t\tcallback();\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tsplitOperations[ index ].keepPositive = true;\n\t\t\trunPermutations( index + 1 );\n\n\t\t\tsplitOperations[ index ].keepPositive = false;\n\t\t\trunPermutations( index + 1 );\n\n\t\t};\n\n\t\trunPermutations();\n\n\t}\n\n\t// Takes an operation that returns a value for the given vertex passed to the callback. Triangles\n\t// are clipped along edges where the interpolated value is equal to 0. The polygons on the positive\n\t// side of the operation are kept if \"keepPositive\" is true.\n\t// callback( geometry, i0, i1, i2, barycoord );\n\taddSplitOperation( callback, keepPositive = true ) {\n\n\t\tthis.splitOperations.push( {\n\t\t\tcallback,\n\t\t\tkeepPositive,\n\t\t} );\n\n\t}\n\n\t// Removes all split operations\n\tclearSplitOperations() {\n\n\t\tthis.splitOperations.length = 0;\n\n\t}\n\n\t// clips an object hierarchy\n\tclipObject( object ) {\n\n\t\tconst result = object.clone();\n\t\tconst toRemove = [];\n\t\tresult.traverse( c => {\n\n\t\t\tif ( c.isMesh ) {\n\n\t\t\t\tc.geometry = this.clip( c ).geometry;\n\n\t\t\t\tconst triCount = c.geometry.index ? c.geometry.index.count / 3 : c.attributes.position.count / 3;\n\t\t\t\tif ( triCount === 0 ) {\n\n\t\t\t\t\ttoRemove.push( c );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\ttoRemove.forEach( m => {\n\n\t\t\tm.removeFromParent();\n\n\t\t} );\n\n\t\treturn result;\n\n\t}\n\n\t// Returns a new mesh that has been clipped by the split operations. Range indicates the range of\n\t// elements to include when clipping.\n\tclip( mesh, range = null ) {\n\n\t\t// TODO: support multimaterial\n\t\tconst result = this.getClippedData( mesh, range );\n\t\treturn this.constructMesh( result.attributes, result.index, mesh );\n\n\t}\n\n\t// Appends the clip operation data to the given \"target\" object so multiple ranges can be appended.\n\t// The \"target\" object is returned with an \"index\" field, \"vertexIsClipped\" field, and series of arrays\n\t// in \"attributes\".\n\t// attributes - set of attribute arrays\n\t// index - triangle indices referencing vertices in attributes\n\t// vertexIsClipped - array indicating whether a vertex is on a clipped edge\n\tgetClippedData( mesh, range = null, target = {} ) {\n\n\t\tconst { trianglePool, splitOperations, attributeList } = this;\n\n\t\t// source geometry\n\t\tconst sourceGeometry = mesh.geometry;\n\t\tconst position = sourceGeometry.attributes.position;\n\t\tconst index = sourceGeometry.index;\n\n\t\t// vertex hash data\n\t\tlet nextIndex = 0;\n\t\tconst vertToNewIndexMap = {};\n\n\t\t// initialize the result\n\t\ttarget.index = target.index || [];\n\t\ttarget.vertexIsClipped = target.vertexIsClipped || [];\n\t\ttarget.attributes = target.attributes || {};\n\n\t\t// initialize the attributes to the set in the attribute list or all if set to null\n\t\tfor ( const key in sourceGeometry.attributes ) {\n\n\t\t\tif ( attributeList !== null ) {\n\n\t\t\t\tif ( attributeList instanceof Function && ! attributeList( key ) ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t} else if ( Array.isArray( attributeList ) && ! attributeList.includes( key ) ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttarget.attributes[ key ] = [];\n\n\t\t}\n\n\t\t// iterate over each group separately to retain the group information\n\t\tlet start = 0;\n\t\tlet count = index ? index.count : position.count;\n\t\tif ( range !== null ) {\n\n\t\t\tstart = range.start;\n\t\t\tcount = range.count;\n\n\t\t}\n\n\t\t// run the clip operations\n\t\tfor ( let i = start, l = start + count; i < l; i += 3 ) {\n\n\t\t\t// get the indices\n\t\t\tlet i0 = i + 0;\n\t\t\tlet i1 = i + 1;\n\t\t\tlet i2 = i + 2;\n\t\t\tif ( index ) {\n\n\t\t\t\ti0 = index.getX( i0 );\n\t\t\t\ti1 = index.getX( i1 );\n\t\t\t\ti2 = index.getX( i2 );\n\n\t\t\t}\n\n\t\t\t// get the original triangle\n\t\t\tconst tri = trianglePool.get();\n\t\t\ttri.initFromIndices( i0, i1, i2 );\n\n\t\t\t// iterate over each triangle and clip it\n\t\t\tlet triangles = [ tri ];\n\t\t\tfor ( let s = 0; s < splitOperations.length; s ++ ) {\n\n\t\t\t\tconst { keepPositive, callback } = splitOperations[ s ];\n\t\t\t\tconst result = [];\n\t\t\t\tfor ( let t = 0; t < triangles.length; t ++ ) {\n\n\t\t\t\t\tconst tri = triangles[ t ];\n\t\t\t\t\tconst { indices, barycoord } = tri;\n\t\t\t\t\ttri.clipValues.a = callback( sourceGeometry, indices.a, indices.b, indices.c, barycoord.a, mesh.matrixWorld );\n\t\t\t\t\ttri.clipValues.b = callback( sourceGeometry, indices.a, indices.b, indices.c, barycoord.b, mesh.matrixWorld );\n\t\t\t\t\ttri.clipValues.c = callback( sourceGeometry, indices.a, indices.b, indices.c, barycoord.c, mesh.matrixWorld );\n\n\t\t\t\t\tthis.splitTriangle( tri, ! keepPositive, result );\n\n\t\t\t\t}\n\n\t\t\t\ttriangles = result;\n\n\t\t\t}\n\n\t\t\t// append the triangles to the result\n\t\t\tfor ( let t = 0, l = triangles.length; t < l; t ++ ) {\n\n\t\t\t\tconst tri = triangles[ t ];\n\t\t\t\tpushTriangle( tri, sourceGeometry );\n\n\t\t\t}\n\n\t\t\ttrianglePool.reset();\n\n\t\t}\n\n\t\treturn target;\n\n\t\tfunction pushTriangle( tri, geometry ) {\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst hash = tri.getVertexHash( i, geometry );\n\n\t\t\t\tif ( ! ( hash in vertToNewIndexMap ) ) {\n\n\t\t\t\t\tvertToNewIndexMap[ hash ] = nextIndex;\n\t\t\t\t\tnextIndex ++;\n\n\t\t\t\t\ttri.getVertexData( i, geometry, target.attributes );\n\t\t\t\t\ttarget.vertexIsClipped.push( tri.clipValues[ vertNames[ i ] ] === SPLIT_VALUE );\n\n\t\t\t\t}\n\n\t\t\t\tconst index = vertToNewIndexMap[ hash ];\n\t\t\t\ttarget.index.push( index );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Takes the set of resultant data and constructs a mesh\n\tconstructMesh( attributes, index, sourceMesh ) {\n\n\t\tconst sourceGeometry = sourceMesh.geometry;\n\n\t\t// new geometry\n\t\tconst geometry = new BufferGeometry();\n\t\tconst indexBuffer = attributes.position.length / 3 > 65535 ? new Uint32Array( index ) : new Uint16Array( index );\n\t\tgeometry.setIndex( new BufferAttribute( indexBuffer, 1, false ) );\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attr = sourceGeometry.getAttribute( key );\n\t\t\tconst cons = new attr.array.constructor( attributes[ key ] );\n\t\t\tconst newAttr = new BufferAttribute( cons, attr.itemSize, attr.normalized );\n\t\t\tnewAttr.gpuType = attr.gpuType;\n\n\t\t\tgeometry.setAttribute( key, newAttr );\n\n\t\t}\n\n\t\t// new mesh\n\t\tconst result = new Mesh( geometry, sourceMesh.material.clone() );\n\t\tresult.position.copy( sourceMesh.position );\n\t\tresult.quaternion.copy( sourceMesh.quaternion );\n\t\tresult.scale.copy( sourceMesh.scale );\n\n\t\treturn result;\n\n\n\t}\n\n\t// Splits the given triangle\n\tsplitTriangle( tri, keepNegative, target ) {\n\n\t\tconst { trianglePool } = this;\n\n\t\t// TODO: clean up, add scratch variables, optimize\n\t\tconst edgeIndices = [];\n\t\tconst edges = [];\n\t\tconst lerpValues = [];\n\n\t\t// Find all points to clip\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst v = vertNames[ i ];\n\t\t\tconst nv = vertNames[ ( i + 1 ) % 3 ];\n\n\t\t\tconst pValue = tri.clipValues[ v ];\n\t\t\tconst npValue = tri.clipValues[ nv ];\n\n\t\t\t// if the uv values span across the halfway divide\n\t\t\tif ( ( pValue < SPLIT_VALUE ) !== ( npValue < SPLIT_VALUE ) || pValue === SPLIT_VALUE ) {\n\n\t\t\t\tedgeIndices.push( i );\n\t\t\t\tedges.push( [ v, nv ] );\n\n\t\t\t\tif ( pValue === npValue ) {\n\n\t\t\t\t\t// avoid NaN here which can occur with mapLinear when pValue and npValue are the same value\n\t\t\t\t\tlerpValues.push( 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlerpValues.push( MathUtils.mapLinear( SPLIT_VALUE, pValue, npValue, 0, 1 ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( edgeIndices.length !== 2 ) {\n\n\t\t\t// if we don't have two intersection points then this triangle must fall on\n\t\t\t// one side of the bounds.\n\t\t\tconst minBound = Math.min(\n\t\t\t\ttri.clipValues.a,\n\t\t\t\ttri.clipValues.b,\n\t\t\t\ttri.clipValues.c,\n\t\t\t);\n\n\t\t\tif ( ( minBound < SPLIT_VALUE ) === keepNegative ) {\n\n\t\t\t\ttarget.push( tri );\n\n\t\t\t}\n\n\t\t} else if ( edgeIndices.length === 2 ) {\n\n\t\t\t// TODO: how can we determine which triangles actually need to be added here ahead of time\n\t\t\tconst tri0 = trianglePool.get().initFromTriangle( tri );\n\t\t\tconst tri1 = trianglePool.get().initFromTriangle( tri );\n\t\t\tconst tri2 = trianglePool.get().initFromTriangle( tri );\n\n\t\t\t// If the points lie on edges that are immediately after one another then we have to split the\n\t\t\t// triangle differently.\n\t\t\tconst sequential = ( ( edgeIndices[ 0 ] + 1 ) % 3 ) === edgeIndices[ 1 ];\n\t\t\tif ( sequential ) {\n\n\t\t\t\ttri0.lerpVertexFromEdge( tri, edges[ 0 ][ 0 ], edges[ 0 ][ 1 ], lerpValues[ 0 ], 'a' );\n\t\t\t\ttri0.copyVertex( tri, edges[ 0 ][ 1 ], 'b' );\n\t\t\t\ttri0.lerpVertexFromEdge( tri, edges[ 1 ][ 0 ], edges[ 1 ][ 1 ], lerpValues[ 1 ], 'c' );\n\t\t\t\ttri0.clipValues.a = SPLIT_VALUE;\n\t\t\t\ttri0.clipValues.c = SPLIT_VALUE;\n\n\t\t\t\ttri1.lerpVertexFromEdge( tri, edges[ 0 ][ 0 ], edges[ 0 ][ 1 ], lerpValues[ 0 ], 'a' );\n\t\t\t\ttri1.copyVertex( tri, edges[ 1 ][ 1 ], 'b' );\n\t\t\t\ttri1.copyVertex( tri, edges[ 0 ][ 0 ], 'c' );\n\t\t\t\ttri1.clipValues.a = SPLIT_VALUE;\n\n\t\t\t\ttri2.lerpVertexFromEdge( tri, edges[ 0 ][ 0 ], edges[ 0 ][ 1 ], lerpValues[ 0 ], 'a' );\n\t\t\t\ttri2.lerpVertexFromEdge( tri, edges[ 1 ][ 0 ], edges[ 1 ][ 1 ], lerpValues[ 1 ], 'b' );\n\t\t\t\ttri2.copyVertex( tri, edges[ 1 ][ 1 ], 'c' );\n\t\t\t\ttri2.clipValues.a = SPLIT_VALUE;\n\t\t\t\ttri2.clipValues.b = SPLIT_VALUE;\n\n\t\t\t} else {\n\n\t\t\t\ttri0.lerpVertexFromEdge( tri, edges[ 0 ][ 0 ], edges[ 0 ][ 1 ], lerpValues[ 0 ], 'a' );\n\t\t\t\ttri0.lerpVertexFromEdge( tri, edges[ 1 ][ 0 ], edges[ 1 ][ 1 ], lerpValues[ 1 ], 'b' );\n\t\t\t\ttri0.copyVertex( tri, edges[ 0 ][ 0 ], 'c' );\n\t\t\t\ttri0.clipValues.a = SPLIT_VALUE;\n\t\t\t\ttri0.clipValues.b = SPLIT_VALUE;\n\n\t\t\t\ttri1.lerpVertexFromEdge( tri, edges[ 0 ][ 0 ], edges[ 0 ][ 1 ], lerpValues[ 0 ], 'a' );\n\t\t\t\ttri1.copyVertex( tri, edges[ 0 ][ 1 ], 'b' );\n\t\t\t\ttri1.lerpVertexFromEdge( tri, edges[ 1 ][ 0 ], edges[ 1 ][ 1 ], lerpValues[ 1 ], 'c' );\n\t\t\t\ttri1.clipValues.a = SPLIT_VALUE;\n\t\t\t\ttri1.clipValues.c = SPLIT_VALUE;\n\n\t\t\t\ttri2.copyVertex( tri, edges[ 0 ][ 1 ], 'a' );\n\t\t\t\ttri2.copyVertex( tri, edges[ 1 ][ 0 ], 'b' );\n\t\t\t\ttri2.lerpVertexFromEdge( tri, edges[ 1 ][ 0 ], edges[ 1 ][ 1 ], lerpValues[ 1 ], 'c' );\n\t\t\t\ttri2.clipValues.c = SPLIT_VALUE;\n\n\t\t\t}\n\n\t\t\t// Save the triangles that sit on the right side of the split\n\t\t\tlet minBound, negativeSide;\n\t\t\tminBound = Math.min( tri0.clipValues.a, tri0.clipValues.b, tri0.clipValues.c );\n\t\t\tnegativeSide = minBound < SPLIT_VALUE;\n\t\t\tif ( negativeSide === keepNegative ) {\n\n\t\t\t\ttarget.push( tri0 );\n\n\t\t\t}\n\n\t\t\tminBound = Math.min( tri1.clipValues.a, tri1.clipValues.b, tri1.clipValues.c );\n\t\t\tnegativeSide = minBound < SPLIT_VALUE;\n\t\t\tif ( negativeSide === keepNegative ) {\n\n\t\t\t\ttarget.push( tri1 );\n\n\t\t\t}\n\n\t\t\tminBound = Math.min( tri2.clipValues.a, tri2.clipValues.b, tri2.clipValues.c );\n\t\t\tnegativeSide = minBound < SPLIT_VALUE;\n\t\t\tif ( negativeSide === keepNegative ) {\n\n\t\t\t\ttarget.push( tri2 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n// Pool of reusable triangles\nclass ClipTrianglePool {\n\n\tconstructor() {\n\n\t\tthis.pool = [];\n\t\tthis.index = 0;\n\n\t}\n\n\tget() {\n\n\t\tif ( this.index >= this.pool.length ) {\n\n\t\t\tconst tri = new ClipTriangle();\n\t\t\tthis.pool.push( tri );\n\n\t\t}\n\n\t\tconst res = this.pool[ this.index ];\n\t\tthis.index ++;\n\t\treturn res;\n\n\t}\n\n\treset() {\n\n\t\tthis.index = 0;\n\n\t}\n\n}\n\n// Triangle class that stores the values to clip along, barycoord values for clipping, and the\n// original indices that the barycoord are interpolated between.\nclass ClipTriangle {\n\n\tconstructor() {\n\n\t\tthis.indices = {\n\t\t\ta: - 1,\n\t\t\tb: - 1,\n\t\t\tc: - 1,\n\t\t};\n\n\t\tthis.clipValues = {\n\t\t\ta: - 1,\n\t\t\tb: - 1,\n\t\t\tc: - 1,\n\t\t};\n\n\t\tthis.barycoord = new Triangle();\n\n\t}\n\n\t// returns a hash for the given [0, 2] index based on attributes of the referenced geometry\n\tgetVertexHash( index, geometry ) {\n\n\t\tconst { barycoord, indices } = this;\n\t\tconst vn = vertNames[ index ];\n\t\tconst bc = barycoord[ vn ];\n\n\t\t// If the barycoord value is specifying a single vertex then return a quick hash\n\t\tif ( bc.x === 1 ) {\n\n\t\t\treturn indices[ vertNames[ 0 ] ];\n\n\t\t} else if ( bc.y === 1 ) {\n\n\t\t\treturn indices[ vertNames[ 1 ] ];\n\n\t\t} else if ( bc.z === 1 ) {\n\n\t\t\treturn indices[ vertNames[ 2 ] ];\n\n\t\t} else {\n\n\t\t\t// Construct a hash based on all the interpolated attributes\n\t\t\tconst { attributes } = geometry;\n\t\t\tlet result = '';\n\t\t\tfor ( const name in attributes ) {\n\n\t\t\t\tconst attr = attributes[ name ];\n\t\t\t\treadInterpolatedAttribute( attr, indices.a, indices.b, indices.c, bc, _vec );\n\n\t\t\t\t// normalize values if needed\n\t\t\t\tif ( name === 'normal' || name === 'tangent' || name === 'bitangent' ) {\n\n\t\t\t\t\t_vec.normalize();\n\n\t\t\t\t}\n\n\t\t\t\t// construct the hash\n\t\t\t\tswitch ( attr.itemSize ) {\n\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tresult += hashVertex( _vec.x, _vec.y, _vec.z, _vec.w );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tresult += hashVertex( _vec.x, _vec.y, _vec.z );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tresult += hashVertex( _vec.x, _vec.y );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tresult += hashVertex( _vec.x );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tresult += '|';\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t}\n\n\t// Accumulate the vertex data in the given attribute arrays\n\tgetVertexData( index, geometry, target ) {\n\n\t\tconst { barycoord, indices } = this;\n\t\tconst vn = vertNames[ index ];\n\t\tconst bc = barycoord[ vn ];\n\n\t\tconst { attributes } = geometry;\n\t\tfor ( const name in attributes ) {\n\n\t\t\t// skip saving the data if we have no fields for it\n\t\t\tif ( ! target[ name ] ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst attr = attributes[ name ];\n\t\t\tconst arr = target[ name ];\n\n\t\t\treadInterpolatedAttribute( attr, indices.a, indices.b, indices.c, bc, _vec );\n\n\t\t\t// normalize values if needed\n\t\t\tif ( name === 'normal' || name === 'tangent' || name === 'bitangent' ) {\n\n\t\t\t\t_vec.normalize();\n\n\t\t\t}\n\n\t\t\t// append the data\n\t\t\tswitch ( attr.itemSize ) {\n\n\t\t\t\tcase 4:\n\t\t\t\t\tarr.push( _vec.x, _vec.y, _vec.z, _vec.w );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tarr.push( _vec.x, _vec.y, _vec.z );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tarr.push( _vec.x, _vec.y );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tarr.push( _vec.x );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Copy the indices from a target triangle\n\tinitFromTriangle( other ) {\n\n\t\treturn this.initFromIndices(\n\t\t\tother.indices.a,\n\t\t\tother.indices.b,\n\t\t\tother.indices.c,\n\t\t);\n\n\t}\n\n\t// Set the indices for the given\n\tinitFromIndices( i0, i1, i2 ) {\n\n\t\tthis.indices.a = i0;\n\t\tthis.indices.b = i1;\n\t\tthis.indices.c = i2;\n\n\t\tthis.clipValues.a = - 1;\n\t\tthis.clipValues.b = - 1;\n\t\tthis.clipValues.c = - 1;\n\n\t\tthis.barycoord.a.set( 1, 0, 0 );\n\t\tthis.barycoord.b.set( 0, 1, 0 );\n\t\tthis.barycoord.c.set( 0, 0, 1 );\n\n\t\treturn this;\n\n\t}\n\n\t// Lerp the given vertex along to the provided edge of the provided triangle\n\tlerpVertexFromEdge( other, e0, e1, alpha, targetVertex ) {\n\n\t\tthis.clipValues[ targetVertex ] = MathUtils.lerp( other.clipValues[ e0 ], other.clipValues[ e1 ], alpha );\n\t\tthis.barycoord[ targetVertex ].lerpVectors( other.barycoord[ e0 ], other.barycoord[ e1 ], alpha );\n\n\t}\n\n\t// Copy a vertex from the provided triangle\n\tcopyVertex( other, fromVertex, targetVertex ) {\n\n\t\tthis.clipValues[ targetVertex ] = other.clipValues[ fromVertex ];\n\t\tthis.barycoord[ targetVertex ].copy( other.barycoord[ fromVertex ] );\n\n\t}\n\n}\n\n// Read a vertex from the given attribute interpolated between the indices\nfunction readInterpolatedAttribute( attribute, i0, i1, i2, barycoord, target ) {\n\n\t_v0.fromBufferAttribute( attribute, i0 );\n\t_v1.fromBufferAttribute( attribute, i1 );\n\t_v2.fromBufferAttribute( attribute, i2 );\n\n\ttarget\n\t\t.set( 0, 0, 0, 0 )\n\t\t.addScaledVector( _v0, barycoord.x )\n\t\t.addScaledVector( _v1, barycoord.y )\n\t\t.addScaledVector( _v2, barycoord.z );\n\n\tswitch ( attribute.itemSize ) {\n\n\t\tcase 3:\n\t\t\t_vec.w = 0;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t_vec.w = 0;\n\t\t\t_vec.z = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t_vec.w = 0;\n\t\t\t_vec.z = 0;\n\t\t\t_vec.y = 0;\n\t\t\tbreak;\n\n\t}\n\n\treturn target;\n\n}\n\n// Hash the provided numbers\nexport function hashVertex( ...args ) {\n\n\tconst scalar = 1e5;\n\tconst additive = 0.5;\n\tlet result = '';\n\tfor ( let i = 0, l = args.length; i < l; i ++ ) {\n\n\t\tresult += ~ ~ ( args[ i ] * scalar + additive );\n\t\tif ( i !== l - 1 ) {\n\n\t\t\tresult += '_';\n\n\t\t}\n\n\t}\n\treturn result;\n\n}\n"],"names":["CesiumIonAuth","options","apiToken","autoRefreshToken","url","fetchOptions","res","json","SPLIT_VALUE","vertNames","_vec","Vector4","_v0","_v1","_v2","GeometryClipper","ClipTrianglePool","callback","splitOperations","runPermutations","index","keepPositive","object","result","toRemove","c","m","mesh","range","target","trianglePool","attributeList","sourceGeometry","position","nextIndex","vertToNewIndexMap","key","start","count","i","l","i0","i1","i2","tri","triangles","s","t","indices","barycoord","pushTriangle","geometry","hash","attributes","sourceMesh","BufferGeometry","indexBuffer","BufferAttribute","attr","cons","newAttr","Mesh","keepNegative","edgeIndices","edges","lerpValues","v","nv","pValue","npValue","MathUtils","tri0","tri1","tri2","minBound","negativeSide","ClipTriangle","Triangle","vn","bc","name","readInterpolatedAttribute","hashVertex","arr","other","e0","e1","alpha","targetVertex","fromVertex","attribute","args"],"mappings":"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"}