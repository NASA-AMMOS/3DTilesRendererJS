import{aQ as b,a as D,O as P,m as l,s as O,M as h,Q as w}from"./three.module-DBfedTbk.js";const o=new l,p=new l,m=new P,T=new l,z=new l,E=new l,x=new w,Q=new w;class q extends b{get animating(){return this._alpha!==0&&this._alpha!==1}get alpha(){return this._target===0?1-this._alpha:this._alpha}get camera(){return this._alpha===0?this.perspectiveCamera:this._alpha===1?this.orthographicCamera:this.transitionCamera}get mode(){return this._target===0?"perspective":"orthographic"}set mode(e){if(e===this.mode)return;const a=this.camera;e==="perspective"?(this._target=0,this._alpha=0):(this._target=1,this._alpha=1),this.dispatchEvent({type:"camera-change",camera:this.camera,prevCamera:a})}constructor(e=new D,a=new P){super(),this.perspectiveCamera=e,this.orthographicCamera=a,this.transitionCamera=new D,this.orthographicPositionalZoom=!0,this.orthographicOffset=50,this.fixedPoint=new l,this.duration=200,this.autoSync=!0,this.easeFunction=t=>t,this._target=0,this._alpha=0,this._clock=new O}toggle(){this._target=this._target===1?0:1,this._clock.getDelta(),this.dispatchEvent({type:"toggle"})}update(e=Math.min(this._clock.getDelta(),64/1e3)){this.autoSync&&this.syncCameras();const{perspectiveCamera:a,orthographicCamera:t,transitionCamera:s,camera:r}=this,c=e*1e3;if(this._alpha!==this._target){const g=Math.sign(this._target-this._alpha)*c/this.duration;this._alpha=h.clamp(this._alpha+g,0,1),this.dispatchEvent({type:"change",alpha:this.alpha})}const n=r;let i=null;this._alpha===0?i=a:this._alpha===1?i=t:(i=s,this._updateTransitionCamera()),n!==i&&(i===s&&this.dispatchEvent({type:"transition-start"}),this.dispatchEvent({type:"camera-change",camera:i,prevCamera:n}),n===s&&this.dispatchEvent({type:"transition-end"}))}syncCameras(){const e=this._getFromCamera(),{perspectiveCamera:a,orthographicCamera:t,transitionCamera:s,fixedPoint:r}=this;if(o.set(0,0,-1).transformDirection(e.matrixWorld).normalize(),e.isPerspectiveCamera){if(this.orthographicPositionalZoom)t.position.copy(a.position).addScaledVector(o,-this.orthographicOffset),t.rotation.copy(a.rotation),t.updateMatrixWorld();else{const d=p.subVectors(r,t.position).dot(o),g=p.subVectors(r,a.position).dot(o);p.copy(a.position).addScaledVector(o,g),t.rotation.copy(a.rotation),t.position.copy(p).addScaledVector(o,-d),t.updateMatrixWorld()}const c=Math.abs(p.subVectors(a.position,r).dot(o)),n=2*Math.tan(h.DEG2RAD*a.fov*.5)*c,i=t.top-t.bottom;t.zoom=i/n,t.updateProjectionMatrix()}else{const c=Math.abs(p.subVectors(t.position,r).dot(o)),i=(t.top-t.bottom)/t.zoom*.5/Math.tan(h.DEG2RAD*a.fov*.5);a.rotation.copy(t.rotation),a.position.copy(t.position).addScaledVector(o,c).addScaledVector(o,-i),a.updateMatrixWorld(),this.orthographicPositionalZoom&&(t.position.copy(a.position).addScaledVector(o,-this.orthographicOffset),t.updateMatrixWorld())}s.position.copy(a.position),s.rotation.copy(a.rotation)}_getTransitionDirection(){return Math.sign(this._target-this._alpha)}_getToCamera(){const e=this._getTransitionDirection();return e===0?this._target===0?this.perspectiveCamera:this.orthographicCamera:e>0?this.orthographicCamera:this.perspectiveCamera}_getFromCamera(){const e=this._getTransitionDirection();return e===0?this._target===0?this.perspectiveCamera:this.orthographicCamera:e>0?this.perspectiveCamera:this.orthographicCamera}_updateTransitionCamera(){const{perspectiveCamera:e,orthographicCamera:a,transitionCamera:t,fixedPoint:s}=this,r=this.easeFunction(this._alpha);o.set(0,0,-1).transformDirection(a.matrixWorld).normalize(),m.copy(a),m.position.addScaledVector(o,a.near),a.far-=a.near,a.near=0,o.set(0,0,-1).transformDirection(e.matrixWorld).normalize();const c=Math.abs(p.subVectors(e.position,s).dot(o)),n=2*Math.tan(h.DEG2RAD*e.fov*.5)*c,i=Q.slerpQuaternions(e.quaternion,m.quaternion,r),d=h.lerp(e.fov,1,r),g=n*.5/Math.tan(h.DEG2RAD*d*.5),f=E.copy(m.position).sub(s).applyQuaternion(x.copy(m.quaternion).invert()),_=z.copy(e.position).sub(s).applyQuaternion(x.copy(e.quaternion).invert()),u=T.lerpVectors(_,f,r);u.z-=Math.abs(u.z)-g;const C=-(_.z-u.z),v=-(f.z-u.z),y=h.lerp(C+e.near,v+m.near,r),M=h.lerp(C+e.far,v+m.far,r),V=Math.max(M,0)-Math.max(y,0);t.aspect=e.aspect,t.fov=d,t.near=Math.max(y,V*1e-5),t.far=M,t.position.copy(u).applyQuaternion(i).add(s),t.quaternion.copy(i),t.updateProjectionMatrix(),t.updateMatrixWorld()}}export{q as C};
//# sourceMappingURL=CameraTransitionManager-WDxKQLbX.js.map
