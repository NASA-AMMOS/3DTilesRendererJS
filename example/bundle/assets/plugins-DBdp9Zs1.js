import{C as _t}from"./GoogleCloudAuth-vMnc9CC1.js";import{T as Et}from"./EPSGTilesPlugin-DX3n6hNw.js";import{aY as Tt,an as gt,f as St,h as Mt,o as $,ao as st,e as Ct,a0 as Nt,a2 as Ut,aZ as Rt,J as Vt,M as it,aq as kt,V as pt}from"./three.module-D-uF--xd.js";import{L as zt}from"./BatchTable-CRr3zuRk.js";import{E as It}from"./Ellipsoid-Dwquuq5w.js";import{a as Bt,P as Dt}from"./TiledImageSource-DmD64Gn9.js";import{G as Ht,h as Gt}from"./GeometryClipper-7b525s21.js";function ct(I){return I>>1^-(I&1)}class Ot extends zt{constructor(...t){super(...t),this.fetchOptions.header={Accept:"application/vnd.quantized-mesh,application/octet-stream;q=0.9"}}loadAsync(...t){const{fetchOptions:e}=this;return e.header=e.header||{},e.header.Accept="application/vnd.quantized-mesh,application/octet-stream;q=0.9",e.header.Accept+=";extensions=octvertexnormals-watermask-metadata",super.loadAsync(...t)}parse(t){let e=0;const s=new DataView(t),a=()=>{const n=s.getFloat64(e,!0);return e+=8,n},g=()=>{const n=s.getFloat32(e,!0);return e+=4,n},h=()=>{const n=s.getUint32(e,!0);return e+=4,n},C=()=>{const n=s.getUint8(e);return e+=1,n},l=(n,v)=>{const V=new v(t,e,n);return e+=n*v.BYTES_PER_ELEMENT,V},m={center:[a(),a(),a()],minHeight:g(),maxHeight:g(),sphereCenter:[a(),a(),a()],sphereRadius:a(),horizonOcclusionPoint:[a(),a(),a()]},y=h(),c=l(y,Uint16Array),b=l(y,Uint16Array),P=l(y,Uint16Array),L=new Float32Array(y),r=new Float32Array(y),x=new Float32Array(y);let S=0,f=0,k=0;const p=32767;for(let n=0;n<y;++n)S+=ct(c[n]),f+=ct(b[n]),k+=ct(P[n]),L[n]=S/p,r[n]=f/p,x[n]=k/p;const A=y>65536,u=A?Uint32Array:Uint16Array;A?e=Math.ceil(e/4)*4:e=Math.ceil(e/2)*2;const _=h(),R=l(_*3,u);let G=0;for(var B=0;B<R.length;++B){const n=R[B];R[B]=G-n,n===0&&++G}const X=(n,v)=>r[v]-r[n],Z=(n,v)=>-X(n,v),q=(n,v)=>L[n]-L[v],O=(n,v)=>-q(n,v),Q=h(),o=l(Q,u);o.sort(X);const i=h(),w=l(i,u);w.sort(q);const E=h(),d=l(E,u);d.sort(Z);const N=h(),D=l(N,u);D.sort(O);const U={westIndices:o,southIndices:w,eastIndices:d,northIndices:D},T={};for(;e<s.byteLength;){const n=C(),v=h();if(n===1){const V=l(y*2,Uint8Array),Y=new Float32Array(y*3);for(let F=0;F<y;F++){let j=V[2*F+0]/255*2-1,J=V[2*F+1]/255*2-1;const tt=1-(Math.abs(j)+Math.abs(J));if(tt<0){const dt=j;j=(1-Math.abs(J))*ft(dt),J=(1-Math.abs(dt))*ft(J)}const nt=Math.sqrt(j*j+J*J+tt*tt);Y[3*F+0]=j/nt,Y[3*F+1]=J/nt,Y[3*F+2]=tt/nt}T.octvertexnormals={extensionId:n,normals:Y}}else if(n===2){const V=v===1?1:256,Y=l(V*V,Uint8Array);T.watermask={extensionId:n,mask:Y,size:V}}else if(n===4){const V=h(),Y=l(V,Uint8Array),F=new TextDecoder().decode(Y);T.metadata={extensionId:n,json:JSON.parse(F)}}}return{header:m,indices:R,vertexData:{u:L,v:r,height:x},edgeIndices:U,extensions:T}}}function ft(I){return I<0?-1:1}const xt=new $,at=new kt,M=new $,K=new $;class Ft extends Ot{constructor(t=Tt){super(),this.manager=t,this.ellipsoid=new It,this.skirtLength=1e3,this.smoothSkirtNormals=!0,this.generateNormals=!0,this.solid=!1,this.minLat=-Math.PI/2,this.maxLat=Math.PI/2,this.minLon=-Math.PI,this.maxLon=Math.PI}parse(t){const{ellipsoid:e,solid:s,skirtLength:a,smoothSkirtNormals:g,generateNormals:h,minLat:C,maxLat:l,minLon:m,maxLon:y}=this,{header:c,indices:b,vertexData:P,edgeIndices:L,extensions:r}=super.parse(t),x=new gt,S=new St,f=new Mt(x,S);f.position.set(...c.center);const k="octvertexnormals"in r,p=k||h,A=P.u.length,u=[],_=[],R=[],G=[];let B=0,X=0;for(let o=0;o<A;o++)q(o,M),O(M.x,M.y,M.z,K),_.push(M.x,M.y),u.push(...K);for(let o=0,i=b.length;o<i;o++)R.push(b[o]);if(p)if(k){const o=r.octvertexnormals.normals;for(let i=0,w=o.length;i<w;i++)G.push(o[i])}else{const o=new gt,i=b.length>21845?new Uint32Array(b):new Uint16Array(b);o.setIndex(new st(i,1,!1)),o.setAttribute("position",new st(new Float32Array(u),3,!1)),o.computeVertexNormals();const E=o.getAttribute("normal").array;r.octvertexnormals={normals:E};for(let d=0,N=E.length;d<N;d++)G.push(E[d])}if(x.addGroup(B,b.length,X),B+=b.length,X++,s){const o=u.length/3;for(let i=0;i<A;i++)q(i,M),O(M.x,M.y,M.z,K,-a),_.push(M.x,M.y),u.push(...K);for(let i=b.length-1;i>=0;i--)R.push(b[i]+o);if(p){const i=r.octvertexnormals.normals;for(let w=0,E=i.length;w<E;w++)G.push(-i[w])}x.addGroup(B,b.length,X),B+=b.length,X++}if(a>0){const{westIndices:o,eastIndices:i,southIndices:w,northIndices:E}=L;let d;const N=Q(o);d=u.length/3,_.push(...N.uv),u.push(...N.positions);for(let n=0,v=N.indices.length;n<v;n++)R.push(N.indices[n]+d);const D=Q(i);d=u.length/3,_.push(...D.uv),u.push(...D.positions);for(let n=0,v=D.indices.length;n<v;n++)R.push(D.indices[n]+d);const U=Q(w);d=u.length/3,_.push(...U.uv),u.push(...U.positions);for(let n=0,v=U.indices.length;n<v;n++)R.push(U.indices[n]+d);const T=Q(E);d=u.length/3,_.push(...T.uv),u.push(...T.positions);for(let n=0,v=T.indices.length;n<v;n++)R.push(T.indices[n]+d);p&&(G.push(...N.normals),G.push(...D.normals),G.push(...U.normals),G.push(...T.normals)),x.addGroup(B,b.length,X),B+=b.length,X++}for(let o=0,i=u.length;o<i;o+=3)u[o+0]-=c.center[0],u[o+1]-=c.center[1],u[o+2]-=c.center[2];const Z=u.length/3>65535?new Uint32Array(R):new Uint16Array(R);if(x.setIndex(new st(Z,1,!1)),x.setAttribute("position",new st(new Float32Array(u),3,!1)),x.setAttribute("uv",new st(new Float32Array(_),2,!1)),p&&x.setAttribute("normal",new st(new Float32Array(G),3,!1)),"watermask"in r){const{mask:o,size:i}=r.watermask,w=new Uint8Array(2*i*i);for(let d=0,N=o.length;d<N;d++){const D=o[d]===255?0:255;w[2*d+0]=D,w[2*d+1]=D}const E=new Ct(w,i,i,Nt,Ut);E.flipY=!0,E.minFilter=Rt,E.magFilter=Vt,E.needsUpdate=!0,S.roughnessMap=E}return f.userData.minHeight=c.minHeight,f.userData.maxHeight=c.maxHeight,"metadata"in r&&(f.userData.metadata=r.metadata.json),f;function q(o,i){return i.x=P.u[o],i.y=P.v[o],i.z=P.height[o],i}function O(o,i,w,E,d=0){const N=it.lerp(c.minHeight,c.maxHeight,w),D=it.lerp(m,y,o),U=it.lerp(C,l,i);return e.getCartographicToPosition(U,D,N+d,E),E}function Q(o){const i=[],w=[],E=[],d=[],N=[];for(let T=0,n=o.length;T<n;T++)q(o[T],M),i.push(M.x,M.y),E.push(M.x,M.y),O(M.x,M.y,M.z,K),w.push(...K),O(M.x,M.y,M.z,K,-a),d.push(...K);const D=o.length-1;for(let T=0;T<D;T++){const n=T,v=T+1,V=T+o.length,Y=T+o.length+1;N.push(n,V,v),N.push(v,V,Y)}let U=null;if(p){const T=(w.length+d.length)/3;if(g){U=new Array(T*3);const n=r.octvertexnormals.normals,v=U.length/2;for(let V=0,Y=T/2;V<Y;V++){const F=o[V],j=3*V,J=n[3*F+0],tt=n[3*F+1],nt=n[3*F+2];U[j+0]=J,U[j+1]=tt,U[j+2]=nt,U[v+j+0]=J,U[v+j+1]=tt,U[v+j+2]=nt}}else{U=[],at.a.fromArray(w,0),at.b.fromArray(d,0),at.c.fromArray(w,3),at.getNormal(xt);for(let n=0;n<T;n++)U.push(...xt)}}return{uv:[...i,...E],positions:[...w,...d],indices:N,normals:U}}}}const yt={},jt=new $,ut=new $,ht=new $,qt=new $,Qt=new $,H=new $,ot=new $,z=new pt,W=new pt,At=new pt;class Yt extends Ht{constructor(){super(),this.ellipsoid=new It,this.skirtLength=1e3,this.smoothSkirtNormals=!0,this.solid=!1,this.minLat=-Math.PI/2,this.maxLat=Math.PI/2,this.minLon=-Math.PI,this.maxLon=Math.PI,this.attributeList=["position","normal","uv"]}clipToQuadrant(t,e,s){const{solid:a,skirtLength:g,ellipsoid:h,smoothSkirtNormals:C}=this;this.clearSplitOperations(),this.addSplitOperation(bt("x"),!e),this.addSplitOperation(bt("y"),!s);let l,m;const y=t.geometry.groups[0],c=this.getClippedData(t,y);if(this.adjustVertices(c,t.position,0),a){l={index:c.index.slice().reverse(),attributes:{}};for(const A in c.attributes)l.attributes[A]=c.attributes[A].slice();const p=l.attributes.normal;if(p)for(let A=0;A<p.length;A+=3)p[A+0]*=-1,p[A+1]*=-1,p[A+2]*=-1;this.adjustVertices(l,t.position,-g)}if(g>0){m={index:[],attributes:{position:[],normal:[],uv:[]}};let p=0;const A={},u=(Z,q,O)=>{const Q=Gt(...Z,...O,...q);Q in A||(A[Q]=p,p++,m.attributes.position.push(...Z),m.attributes.normal.push(...O),m.attributes.uv.push(...q)),m.index.push(A[Q])},_=c.index,R=c.attributes.uv,G=c.attributes.position,B=c.attributes.normal,X=c.index.length/3;for(let Z=0;Z<X;Z++){const q=3*Z;for(let O=0;O<3;O++){const Q=(O+1)%3,o=_[q+O],i=_[q+Q];if(z.fromArray(R,o*2),W.fromArray(R,i*2),z.x===W.x&&(z.x===0||z.x===.5||z.x===1)||z.y===W.y&&(z.y===0||z.y===.5||z.y===1)){ut.fromArray(G,o*3),ht.fromArray(G,i*3);const w=ut,E=ht,d=qt.copy(ut),N=Qt.copy(ht);H.copy(d).add(t.position),h.getPositionToNormal(H,H),d.addScaledVector(H,-g),H.copy(N).add(t.position),h.getPositionToNormal(H,H),N.addScaledVector(H,-g),C&&B?(H.fromArray(B,o*3),ot.fromArray(B,i*3)):(H.subVectors(w,E),ot.subVectors(w,d).cross(H).normalize(),H.copy(ot)),u(E,W,ot),u(w,z,H),u(d,z,H),u(E,W,ot),u(d,z,H),u(N,W,ot)}}}}const b=c.index.length,P=c;if(l){const{index:p,attributes:A}=l,u=P.attributes.position.length/3;for(let _=0,R=p.length;_<R;_++)P.index.push(p[_]+u);for(const _ in c.attributes)P.attributes[_].push(...A[_])}if(m){const{index:p,attributes:A}=m,u=P.attributes.position.length/3;for(let _=0,R=p.length;_<R;_++)P.index.push(p[_]+u);for(const _ in c.attributes)P.attributes[_].push(...A[_])}const L=e?0:-.5,r=s?0:-.5,x=P.attributes.uv;for(let p=0,A=x.length;p<A;p+=2)x[p]=(x[p]+L)*2,x[p+1]=(x[p+1]+r)*2;const S=this.constructMesh(P.attributes,P.index,t);S.userData.minHeight=t.userData.minHeight,S.userData.maxHeight=t.userData.maxHeight;let f=0,k=0;return S.geometry.addGroup(k,b,f),k+=b,f++,l&&(S.geometry.addGroup(k,l.index.length,f),k+=l.index.length,f++),m&&(S.geometry.addGroup(k,m.index.length,f),k+=m.index.length,f++),S}adjustVertices(t,e,s){const{ellipsoid:a,minLat:g,maxLat:h,minLon:C,maxLon:l}=this,{attributes:m,vertexIsClipped:y}=t,c=m.position,b=m.uv,P=c.length/3;for(let L=0;L<P;L++){const r=z.fromArray(b,L*2);y&&y[L]&&(Math.abs(r.x-.5)<1e-10&&(r.x=.5),Math.abs(r.y-.5)<1e-10&&(r.y=.5),z.toArray(b,L*2));const x=it.lerp(g,h,r.y),S=it.lerp(C,l,r.x),f=jt.fromArray(c,L*3).add(e);a.getPositionToCartographic(f,yt),a.getCartographicToPosition(x,S,yt.height+s,f),f.sub(e),f.toArray(c,L*3)}}}function bt(I){return(t,e,s,a,g)=>{const h=t.attributes.uv;return z.fromBufferAttribute(h,e),W.fromBufferAttribute(h,s),At.fromBufferAttribute(h,a),z[I]*g.x+W[I]*g.y+At[I]*g.z-.5}}const Lt=Symbol("TILE_X"),wt=Symbol("TILE_Y"),rt=Symbol("TILE_LEVEL"),et=Symbol("TILE_AVAILABLE"),lt=1e4,vt=new $;function Xt(I,t,e,s){if(I&&t<I.length){const a=I[t];for(let g=0,h=a.length;g<h;g++){const{startX:C,startY:l,endX:m,endY:y}=a[g];if(e>=C&&e<=m&&s>=l&&s<=y)return!0}}return!1}function Pt(I){const{available:t=null,maxzoom:e=null}=I;return e===null?t.length-1:e}function $t(I){const{metadataAvailability:t=-1}=I;return t}function mt(I,t){const e=I[rt],s=$t(t),a=Pt(t);return e<a&&s!==-1&&e%s===0}function Zt(I,t,e,s,a){return a.tiles[0].replace(/{\s*z\s*}/g,e).replace(/{\s*x\s*}/g,I).replace(/{\s*y\s*}/g,t).replace(/{\s*version\s*}/g,s)}class Jt{constructor(t={}){const{useRecommendedSettings:e=!0,skirtLength:s=null,smoothSkirtNormals:a=!0,generateNormals:g=!0,solid:h=!1}=t;this.name="QUANTIZED_MESH_PLUGIN",this.priority=-1e3,this.tiles=null,this.layer=null,this.useRecommendedSettings=e,this.skirtLength=s,this.smoothSkirtNormals=a,this.solid=h,this.generateNormals=g,this.attribution=null,this.tiling=new Bt,this.projection=new Dt}init(t){t.fetchOptions.headers=t.fetchOptions.headers||{},t.fetchOptions.headers.Accept="application/vnd.quantized-mesh,application/octet-stream;q=0.9",this.useRecommendedSettings&&(t.errorTarget=2),this.tiles=t}loadRootTileset(){const{tiles:t}=this;let e=new URL("layer.json",new URL(t.rootURL,location.href));return t.invokeAllPlugins(s=>e=s.preprocessURL?s.preprocessURL(e,null):e),t.invokeOnePlugin(s=>s.fetchData&&s.fetchData(e,this.tiles.fetchOptions)).then(s=>s.json()).then(s=>{this.layer=s;const{projection:a="EPSG:4326",extensions:g=[],attribution:h="",available:C=null}=s,{tiling:l,tiles:m,projection:y}=this;h&&(this.attribution={value:h,type:"string",collapsible:!0}),g.length>0&&(m.fetchOptions.headers.Accept+=`;extensions=${g.join("-")}`),y.setScheme(a);const{tileCountX:c,tileCountY:b}=y;l.setProjection(y),l.generateLevels(Pt(s)+1,c,b);const P=[];for(let x=0;x<c;x++){const S=this.createChild(0,x,0,C);S&&P.push(S)}const L={asset:{version:"1.1"},geometricError:1/0,root:{refine:"REPLACE",geometricError:1/0,boundingVolume:{region:[...this.tiling.getContentBounds(),-lt,lt]},children:P,[et]:C,[rt]:-1}};let r=m.rootURL;return m.invokeAllPlugins(x=>r=x.preprocessURL?x.preprocessURL(r,null):r),m.preprocessTileset(L,r),L})}parseToMesh(t,e,s,a){const{skirtLength:g,solid:h,smoothSkirtNormals:C,generateNormals:l,tiles:m}=this,y=m.ellipsoid;let c;if(s==="quantized_tile_split"){const r=new URL(a).searchParams,x=r.get("left")==="true",S=r.get("bottom")==="true",f=new Yt;f.ellipsoid.copy(y),f.solid=h,f.smoothSkirtNormals=C,f.skirtLength=g===null?e.geometricError:g;const[k,p,A,u]=e.parent.boundingVolume.region;f.minLat=p,f.maxLat=u,f.minLon=k,f.maxLon=A,c=f.clipToQuadrant(e.parent.engineData.scene,x,S)}else if(s==="terrain"){const r=new Ft(m.manager);r.ellipsoid.copy(y),r.solid=h,r.smoothSkirtNormals=C,r.generateNormals=l,r.skirtLength=g===null?e.geometricError:g;const[x,S,f,k]=e.boundingVolume.region;r.minLat=S,r.maxLat=k,r.minLon=x,r.maxLon=f,c=r.parse(t)}else return;const{minHeight:b,maxHeight:P,metadata:L}=c.userData;return e.boundingVolume.region[4]=b,e.boundingVolume.region[5]=P,e.engineData.boundingVolume.setRegionData(y,...e.boundingVolume.region),L&&("geometricerror"in L&&(e.geometricError=L.geometricerror),mt(e,this.layer)&&"available"in L&&e.children.length===0&&(e[et]=[...new Array(e[rt]+1).fill(null),...L.available])),this.expandChildren(e),c}getAttributions(t){this.attribution&&t.push(this.attribution)}createChild(t,e,s,a){const{tiles:g,layer:h,tiling:C,projection:l}=this,m=g.ellipsoid,y=a===null&&t===0||Xt(a,t,e,s),c=Zt(e,s,t,1,h),b=[...C.getTileBounds(e,s,t),-lt,lt],[,P,,L,,r]=b,x=P>0!=L>0?0:Math.min(Math.abs(P),Math.abs(L));m.getCartographicToPosition(x,0,r,vt),vt.z=0;const S=l.tileCountX,p=Math.max(...m.radius)*2*Math.PI*.25/(65*S)/2**t,A={[et]:null,[rt]:t,[Lt]:e,[wt]:s,refine:"REPLACE",geometricError:p,boundingVolume:{region:b},content:y?{uri:c}:null,children:[]};return mt(A,h)||(A[et]=a),A}expandChildren(t){const e=t[rt],s=t[Lt],a=t[wt],g=t[et];if(e>=this.tiling.maxLevel)return;let h=!1;for(let C=0;C<2;C++)for(let l=0;l<2;l++){const m=this.createChild(e+1,2*s+C,2*a+l,g);m.content!==null?(t.children.push(m),h=!0):(t.children.push(m),m.content={uri:`tile.quantized_tile_split?bottom=${l===0}&left=${C===0}`})}h||(t.children.length=0)}fetchData(t,e){if(/quantized_tile_split/.test(t))return new ArrayBuffer}disposeTile(t){mt(t,this.layer)&&(t[et]=null),et in t&&(t.children.forEach(e=>{this.tiles.processNodeQueue.remove(e)}),t.children.length=0)}}let Kt=class extends _t{constructor(t={}){super({assetTypeHandler:(e,s,a)=>{e==="TERRAIN"&&s.getPluginByName("QUANTIZED_MESH_PLUGIN")===null?(console.warn('CesiumIonAuthPlugin: CesiumIonAuthPlugin plugin auto-registration has been deprecated. Please implement a custom "assetTypeHandler" for "TERRAIN" using "QuantizedMeshPlugin", instead.'),s.registerPlugin(new Jt({useRecommendedSettings:this.useRecommendedSettings}))):e==="IMAGERY"&&s.getPluginByName("TMS_TILES_PLUGIN")===null?(console.warn('CesiumIonAuthPlugin: CesiumIonAuthPlugin plugin auto-registration has been deprecated. Please implement a custom "assetTypeHandler" for "IMAGERY" using "TMSTilesPlugin", instead.'),s.registerPlugin(new Et({useRecommendedSettings:this.useRecommendedSettings,shape:"ellipsoid"}))):console.warn(`CesiumIonAuthPlugin: Cesium Ion asset type "${e}" unhandled.`)},...t}),t.__suppress_warning__&&console.warn('CesiumIonAuthPlugin: Plugin has been moved to "3d-tiles-renderer/core/plugins".')}};class ae extends Kt{constructor(t){super({...t,__suppress_warning__:!0})}}export{ae as C};
//# sourceMappingURL=plugins-DBdp9Zs1.js.map
