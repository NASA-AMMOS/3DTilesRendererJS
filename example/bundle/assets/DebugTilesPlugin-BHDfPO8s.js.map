{"version":3,"file":"DebugTilesPlugin-BHDfPO8s.js","sources":["../../../src/three/plugins/DebugTilesPlugin.js"],"sourcesContent":["import { Box3Helper, Group, MeshStandardMaterial, PointsMaterial, Sphere, Color, MeshBasicMaterial } from 'three';\nimport { SphereHelper } from './objects/SphereHelper.js';\nimport { EllipsoidRegionLineHelper } from './objects/EllipsoidRegionHelper.js';\nimport { TraversalUtils } from '3d-tiles-renderer/core';\n\nconst ORIGINAL_MATERIAL = Symbol( 'ORIGINAL_MATERIAL' );\nconst HAS_RANDOM_COLOR = Symbol( 'HAS_RANDOM_COLOR' );\nconst HAS_RANDOM_NODE_COLOR = Symbol( 'HAS_RANDOM_NODE_COLOR' );\nconst LOAD_TIME = Symbol( 'LOAD_TIME' );\nconst PARENT_BOUND_REF_COUNT = Symbol( 'PARENT_BOUND_REF_COUNT' );\n\nconst _sphere = /* @__PURE__ */ new Sphere();\nconst emptyRaycast = () => {};\nconst colors = {};\n\n// Return a consistent random color for an index\nfunction getIndexedRandomColor( index ) {\n\n\tif ( ! colors[ index ] ) {\n\n\t\tconst h = Math.random();\n\t\tconst s = 0.5 + Math.random() * 0.5;\n\t\tconst l = 0.375 + Math.random() * 0.25;\n\n\t\tcolors[ index ] = new Color().setHSL( h, s, l );\n\n\t}\n\treturn colors[ index ];\n\n}\n\n// color modes\nconst NONE = 0;\nconst SCREEN_ERROR = 1;\nconst GEOMETRIC_ERROR = 2;\nconst DISTANCE = 3;\nconst DEPTH = 4;\nconst RELATIVE_DEPTH = 5;\nconst IS_LEAF = 6;\nconst RANDOM_COLOR = 7;\nconst RANDOM_NODE_COLOR = 8;\nconst CUSTOM_COLOR = 9;\nconst LOAD_ORDER = 10;\n\nconst ColorModes = Object.freeze( {\n\tNONE,\n\tSCREEN_ERROR,\n\tGEOMETRIC_ERROR,\n\tDISTANCE,\n\tDEPTH,\n\tRELATIVE_DEPTH,\n\tIS_LEAF,\n\tRANDOM_COLOR,\n\tRANDOM_NODE_COLOR,\n\tCUSTOM_COLOR,\n\tLOAD_ORDER,\n} );\n\nexport class DebugTilesPlugin {\n\n\tstatic get ColorModes() {\n\n\t\treturn ColorModes;\n\n\t}\n\n\tget unlit() {\n\n\t\treturn this._unlit;\n\n\t}\n\n\tset unlit( v ) {\n\n\t\tif ( v !== this._unlit ) {\n\n\t\t\tthis._unlit = v;\n\t\t\tthis.materialsNeedUpdate = true;\n\n\t\t}\n\n\t}\n\n\tget colorMode() {\n\n\t\treturn this._colorMode;\n\n\t}\n\n\tset colorMode( v ) {\n\n\t\tif ( v !== this._colorMode ) {\n\n\t\t\tthis._colorMode = v;\n\t\t\tthis.materialsNeedUpdate = true;\n\n\t\t}\n\n\t}\n\n\tget enabled() {\n\n\t\treturn this._enabled;\n\n\t}\n\n\tset enabled( v ) {\n\n\t\tif ( v !== this._enabled && this.tiles !== null ) {\n\n\t\t\tif ( v ) {\n\n\t\t\t\tthis.init( this.tiles );\n\n\t\t\t} else {\n\n\t\t\t\tthis.dispose();\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._enabled = v;\n\n\t}\n\n\tget displayParentBounds() {\n\n\t\treturn this._displayParentBounds;\n\n\t}\n\n\tset displayParentBounds( v ) {\n\n\t\tif ( this._displayParentBounds !== v ) {\n\n\t\t\tthis._displayParentBounds = v;\n\n\t\t\tif ( ! v ) {\n\n\t\t\t\t// Reset all ref counts\n\t\t\t\tthis.tiles.traverse( tile => {\n\n\t\t\t\t\ttile[ PARENT_BOUND_REF_COUNT ] = null;\n\t\t\t\t\tthis._onTileVisibilityChange( tile, tile.__visible );\n\n\t\t\t\t} );\n\n\t\t\t} else {\n\n\t\t\t\t// Initialize ref count for existing tiles\n\t\t\t\tthis.tiles.traverse( tile => {\n\n\t\t\t\t\tif ( tile.__visible ) {\n\n\t\t\t\t\t\tthis._onTileVisibilityChange( tile, true );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconstructor( options ) {\n\n\t\toptions = {\n\t\t\tdisplayParentBounds: false,\n\t\t\tdisplayBoxBounds: false,\n\t\t\tdisplaySphereBounds: false,\n\t\t\tdisplayRegionBounds: false,\n\t\t\tcolorMode: NONE,\n\t\t\tmaxDebugDepth: - 1,\n\t\t\tmaxDebugDistance: - 1,\n\t\t\tmaxDebugError: - 1,\n\t\t\tcustomColorCallback: null,\n\t\t\tunlit: false,\n\t\t\tenabled: true,\n\t\t\t...options,\n\t\t};\n\n\t\tthis.name = 'DEBUG_TILES_PLUGIN';\n\t\tthis.tiles = null;\n\n\t\tthis._colorMode = null;\n\t\tthis._unlit = null;\n\t\tthis.materialsNeedUpdate = false;\n\n\t\tthis.extremeDebugDepth = - 1;\n\t\tthis.extremeDebugError = - 1;\n\t\tthis.boxGroup = null;\n\t\tthis.sphereGroup = null;\n\t\tthis.regionGroup = null;\n\n\t\t// options\n\t\tthis._enabled = options.enabled;\n\t\tthis._displayParentBounds = options.displayParentBounds;\n\t\tthis.displayBoxBounds = options.displayBoxBounds;\n\t\tthis.displaySphereBounds = options.displaySphereBounds;\n\t\tthis.displayRegionBounds = options.displayRegionBounds;\n\t\tthis.colorMode = options.colorMode;\n\t\tthis.maxDebugDepth = options.maxDebugDepth;\n\t\tthis.maxDebugDistance = options.maxDebugDistance;\n\t\tthis.maxDebugError = options.maxDebugError;\n\t\tthis.customColorCallback = options.customColorCallback;\n\t\tthis.unlit = options.unlit;\n\n\t\tthis.getDebugColor = ( value, target ) => {\n\n\t\t\ttarget.setRGB( value, value, value );\n\n\t\t};\n\n\t}\n\n\t// initialize the groups for displaying helpers, register events, and initialize existing tiles\n\tinit( tiles ) {\n\n\t\tthis.tiles = tiles;\n\n\t\t// initialize groups\n\t\tconst tilesGroup = tiles.group;\n\t\tthis.boxGroup = new Group();\n\t\tthis.boxGroup.name = 'DebugTilesRenderer.boxGroup';\n\t\ttilesGroup.add( this.boxGroup );\n\t\tthis.boxGroup.updateMatrixWorld();\n\n\t\tthis.sphereGroup = new Group();\n\t\tthis.sphereGroup.name = 'DebugTilesRenderer.sphereGroup';\n\t\ttilesGroup.add( this.sphereGroup );\n\t\tthis.sphereGroup.updateMatrixWorld();\n\n\t\tthis.regionGroup = new Group();\n\t\tthis.regionGroup.name = 'DebugTilesRenderer.regionGroup';\n\t\ttilesGroup.add( this.regionGroup );\n\t\tthis.regionGroup.updateMatrixWorld();\n\n\t\t// register events\n\t\tthis._onLoadTileSetCB = () => {\n\n\t\t\tthis._initExtremes();\n\n\t\t};\n\n\t\tthis._onLoadModelCB = ( { scene, tile } ) => {\n\n\t\t\tthis._onLoadModel( scene, tile );\n\n\t\t};\n\n\t\tthis._onDisposeModelCB = ( { tile } ) => {\n\n\t\t\tthis._onDisposeModel( tile );\n\n\t\t};\n\n\t\tthis._onUpdateAfterCB = () => {\n\n\t\t\tthis._onUpdateAfter();\n\n\t\t};\n\n\t\tthis._onTileVisibilityChangeCB = ( { scene, tile, visible } ) => {\n\n\t\t\tthis._onTileVisibilityChange( tile, visible );\n\n\t\t};\n\n\t\ttiles.addEventListener( 'load-tile-set', this._onLoadTileSetCB );\n\t\ttiles.addEventListener( 'load-model', this._onLoadModelCB );\n\t\ttiles.addEventListener( 'dispose-model', this._onDisposeModelCB );\n\t\ttiles.addEventListener( 'update-after', this._onUpdateAfterCB );\n\t\ttiles.addEventListener( 'tile-visibility-change', this._onTileVisibilityChangeCB );\n\n\t\tthis._initExtremes();\n\n\t\t// initialize an already-loaded tiles\n\t\ttiles.traverse( tile => {\n\n\t\t\tif ( tile.cached.scene ) {\n\n\t\t\t\tthis._onLoadModel( tile.cached.scene, tile );\n\n\t\t\t}\n\n\t\t} );\n\n\t\ttiles.visibleTiles.forEach( tile => {\n\n\t\t\tthis._onTileVisibilityChange( tile, true );\n\n\t\t} );\n\n\t}\n\n\tgetTileInformationFromActiveObject( object ) {\n\n\t\t// Find which tile this scene is associated with. This is slow and\n\t\t// intended for debug purposes only.\n\t\tlet targetTile = null;\n\t\tconst activeTiles = this.tiles.activeTiles;\n\t\tactiveTiles.forEach( tile => {\n\n\t\t\tif ( targetTile ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tconst scene = tile.cached.scene;\n\t\t\tif ( scene ) {\n\n\t\t\t\tscene.traverse( c => {\n\n\t\t\t\t\tif ( c === object ) {\n\n\t\t\t\t\t\ttargetTile = tile;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( targetTile ) {\n\n\t\t\treturn {\n\n\t\t\t\tdistanceToCamera: targetTile.__distanceFromCamera,\n\t\t\t\tgeometricError: targetTile.geometricError,\n\t\t\t\tscreenSpaceError: targetTile.__error,\n\t\t\t\tdepth: targetTile.__depth,\n\t\t\t\tisLeaf: targetTile.__isLeaf\n\n\t\t\t};\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\t_initExtremes() {\n\n\t\tif ( ! ( this.tiles && this.tiles.root ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// initialize the extreme values of the hierarchy\n\t\tlet maxDepth = - 1;\n\t\tlet maxError = - 1;\n\n\t\t// Note that we are not using this.tiles.traverse()\n\t\t// as we don't want to pay the cost of preprocessing tiles.\n\t\tthis.tiles.traverse( null, ( tile, _, depth ) => {\n\n\t\t\tmaxDepth = Math.max( maxDepth, depth );\n\t\t\tmaxError = Math.max( maxError, tile.geometricError );\n\n\t\t}, false );\n\n\t\tthis.extremeDebugDepth = maxDepth;\n\t\tthis.extremeDebugError = maxError;\n\n\t}\n\n\t_onUpdateAfter() {\n\n\t\tconst { tiles, colorMode } = this;\n\n\t\tif ( ! tiles.root ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.materialsNeedUpdate ) {\n\n\t\t\ttiles.forEachLoadedModel( scene => {\n\n\t\t\t\tthis._updateMaterial( scene );\n\n\t\t\t} );\n\t\t\tthis.materialsNeedUpdate = false;\n\n\t\t}\n\n\t\t// set box or sphere visibility\n\t\tthis.boxGroup.visible = this.displayBoxBounds;\n\t\tthis.sphereGroup.visible = this.displaySphereBounds;\n\t\tthis.regionGroup.visible = this.displayRegionBounds;\n\n\t\t// get max values to use for materials\n\t\tlet maxDepth = - 1;\n\t\tif ( this.maxDebugDepth === - 1 ) {\n\n\t\t\tmaxDepth = this.extremeDebugDepth;\n\n\t\t} else {\n\n\t\t\tmaxDepth = this.maxDebugDepth;\n\n\t\t}\n\n\t\tlet maxError = - 1;\n\t\tif ( this.maxDebugError === - 1 ) {\n\n\t\t\tmaxError = this.extremeDebugError;\n\n\t\t} else {\n\n\t\t\tmaxError = this.maxDebugError;\n\n\t\t}\n\n\t\tlet maxDistance = - 1;\n\t\tif ( this.maxDebugDistance === - 1 ) {\n\n\t\t\ttiles.getBoundingSphere( _sphere );\n\t\t\tmaxDistance = _sphere.radius;\n\n\t\t} else {\n\n\t\t\tmaxDistance = this.maxDebugDistance;\n\n\t\t}\n\n\t\tconst { errorTarget, visibleTiles } = tiles;\n\t\tlet sortedTiles;\n\t\tif ( colorMode === LOAD_ORDER ) {\n\n\t\t\tsortedTiles = Array.from( visibleTiles ).sort( ( a, b ) => {\n\n\t\t\t\treturn a[ LOAD_TIME ] - b[ LOAD_TIME ];\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// update plugins\n\t\tvisibleTiles.forEach( tile => {\n\n\t\t\tconst scene = tile.cached.scene;\n\n\t\t\t// create a random color per-tile\n\t\t\tlet h, s, l;\n\t\t\tif ( colorMode === RANDOM_COLOR ) {\n\n\t\t\t\th = Math.random();\n\t\t\t\ts = 0.5 + Math.random() * 0.5;\n\t\t\t\tl = 0.375 + Math.random() * 0.25;\n\n\t\t\t}\n\n\t\t\tscene.traverse( c => {\n\n\t\t\t\tif ( colorMode === RANDOM_NODE_COLOR ) {\n\n\t\t\t\t\th = Math.random();\n\t\t\t\t\ts = 0.5 + Math.random() * 0.5;\n\t\t\t\t\tl = 0.375 + Math.random() * 0.25;\n\n\t\t\t\t}\n\n\t\t\t\tif ( c.material ) {\n\n\t\t\t\t\tif ( colorMode !== RANDOM_COLOR ) {\n\n\t\t\t\t\t\tdelete c.material[ HAS_RANDOM_COLOR ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( colorMode !== RANDOM_NODE_COLOR ) {\n\n\t\t\t\t\t\tdelete c.material[ HAS_RANDOM_NODE_COLOR ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set the color on the basic material\n\t\t\t\t\tswitch ( colorMode ) {\n\n\t\t\t\t\t\tcase DEPTH: {\n\n\t\t\t\t\t\t\tconst val = tile.__depth / maxDepth;\n\t\t\t\t\t\t\tthis.getDebugColor( val, c.material.color );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase RELATIVE_DEPTH: {\n\n\t\t\t\t\t\t\tconst val = tile.__depthFromRenderedParent / maxDepth;\n\t\t\t\t\t\t\tthis.getDebugColor( val, c.material.color );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase SCREEN_ERROR: {\n\n\t\t\t\t\t\t\tconst val = tile.__error / errorTarget;\n\t\t\t\t\t\t\tif ( val > 1.0 ) {\n\n\t\t\t\t\t\t\t\tc.material.color.setRGB( 1.0, 0.0, 0.0 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tthis.getDebugColor( val, c.material.color );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase GEOMETRIC_ERROR: {\n\n\t\t\t\t\t\t\tconst val = Math.min( tile.geometricError / maxError, 1 );\n\t\t\t\t\t\t\tthis.getDebugColor( val, c.material.color );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase DISTANCE: {\n\n\t\t\t\t\t\t\t// We don't update the distance if the geometric error is 0.0 so\n\t\t\t\t\t\t\t// it will always be black.\n\t\t\t\t\t\t\tconst val = Math.min( tile.__distanceFromCamera / maxDistance, 1 );\n\t\t\t\t\t\t\tthis.getDebugColor( val, c.material.color );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase IS_LEAF: {\n\n\t\t\t\t\t\t\tif ( ! tile.children || tile.children.length === 0 ) {\n\n\t\t\t\t\t\t\t\tthis.getDebugColor( 1.0, c.material.color );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tthis.getDebugColor( 0.0, c.material.color );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase RANDOM_NODE_COLOR: {\n\n\t\t\t\t\t\t\tif ( ! c.material[ HAS_RANDOM_NODE_COLOR ] ) {\n\n\t\t\t\t\t\t\t\tc.material.color.setHSL( h, s, l );\n\t\t\t\t\t\t\t\tc.material[ HAS_RANDOM_NODE_COLOR ] = true;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase RANDOM_COLOR: {\n\n\t\t\t\t\t\t\tif ( ! c.material[ HAS_RANDOM_COLOR ] ) {\n\n\t\t\t\t\t\t\t\tc.material.color.setHSL( h, s, l );\n\t\t\t\t\t\t\t\tc.material[ HAS_RANDOM_COLOR ] = true;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase CUSTOM_COLOR: {\n\n\t\t\t\t\t\t\tif ( this.customColorCallback ) {\n\n\t\t\t\t\t\t\t\tthis.customColorCallback( tile, c );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'DebugTilesRenderer: customColorCallback not defined' );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase LOAD_ORDER: {\n\n\t\t\t\t\t\t\tconst value = sortedTiles.indexOf( tile );\n\t\t\t\t\t\t\tthis.getDebugColor( value / ( sortedTiles.length - 1 ), c.material.color );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\t_onTileVisibilityChange( tile, visible ) {\n\n\t\tif ( this.displayParentBounds ) {\n\n\t\t\tTraversalUtils.traverseAncestors( tile, current => {\n\n\t\t\t\tif ( current[ PARENT_BOUND_REF_COUNT ] == null ) {\n\n\t\t\t\t\tcurrent[ PARENT_BOUND_REF_COUNT ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tif ( visible ) {\n\n\t\t\t\t\tcurrent[ PARENT_BOUND_REF_COUNT ] ++;\n\n\t\t\t\t} else if ( current[ PARENT_BOUND_REF_COUNT ] > 0 ) {\n\n\t\t\t\t\tcurrent[ PARENT_BOUND_REF_COUNT ] --;\n\n\t\t\t\t}\n\n\t\t\t\tconst tileVisible = ( current === tile && visible ) || ( this.displayParentBounds && current[ PARENT_BOUND_REF_COUNT ] > 0 );\n\n\t\t\t\tthis._updateBoundHelper( current, tileVisible );\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\tthis._updateBoundHelper( tile, visible );\n\n\t\t}\n\n\t}\n\n\t_createBoundHelper( tile ) {\n\n\t\tconst tiles = this.tiles;\n\t\tconst cached = tile.cached;\n\t\tconst { sphere, obb, region } = cached.boundingVolume;\n\t\tif ( obb ) {\n\n\t\t\t// Create debug bounding box\n\t\t\t// In some cases the bounding box may have a scale of 0 in one dimension resulting\n\t\t\t// in the NaNs in an extracted rotation so we disable matrix updates instead.\n\t\t\tconst boxHelperGroup = new Group();\n\t\t\tboxHelperGroup.name = 'DebugTilesRenderer.boxHelperGroup';\n\t\t\tboxHelperGroup.matrix.copy( obb.transform );\n\t\t\tboxHelperGroup.matrixAutoUpdate = false;\n\n\t\t\tconst boxHelper = new Box3Helper( obb.box, getIndexedRandomColor( tile.__depth ) );\n\t\t\tboxHelper.raycast = emptyRaycast;\n\t\t\tboxHelperGroup.add( boxHelper );\n\n\t\t\tcached.boxHelperGroup = boxHelperGroup;\n\n\t\t\tif ( tiles.visibleTiles.has( tile ) && this.displayBoxBounds ) {\n\n\t\t\t\tthis.boxGroup.add( boxHelperGroup );\n\t\t\t\tboxHelperGroup.updateMatrixWorld( true );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( sphere ) {\n\n\t\t\t// Create debug bounding sphere\n\t\t\tconst sphereHelper = new SphereHelper( sphere, getIndexedRandomColor( tile.__depth ) );\n\t\t\tsphereHelper.raycast = emptyRaycast;\n\t\t\tcached.sphereHelper = sphereHelper;\n\n\t\t\tif ( tiles.visibleTiles.has( tile ) && this.displaySphereBounds ) {\n\n\t\t\t\tthis.sphereGroup.add( sphereHelper );\n\t\t\t\tsphereHelper.updateMatrixWorld( true );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( region ) {\n\n\t\t\t// Create debug bounding region\n\t\t\tconst regionHelper = new EllipsoidRegionLineHelper( region, getIndexedRandomColor( tile.__depth ) );\n\t\t\tregionHelper.raycast = emptyRaycast;\n\n\t\t\t// recenter the geometry to avoid rendering artifacts\n\t\t\tconst sphere = new Sphere();\n\t\t\tregion.getBoundingSphere( sphere );\n\t\t\tregionHelper.position.copy( sphere.center );\n\n\t\t\tsphere.center.multiplyScalar( - 1 );\n\t\t\tregionHelper.geometry.translate( ...sphere.center );\n\n\t\t\tcached.regionHelper = regionHelper;\n\n\t\t\tif ( tiles.visibleTiles.has( tile ) && this.displayRegionBounds ) {\n\n\t\t\t\tthis.regionGroup.add( regionHelper );\n\t\t\t\tregionHelper.updateMatrixWorld( true );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_updateHelperMaterial( tile, material ) {\n\n\t\tif ( tile.__visible || ! this.displayParentBounds ) {\n\n\t\t\tmaterial.opacity = 1;\n\n\t\t} else {\n\n\t\t\tmaterial.opacity = 0.2;\n\n\t\t}\n\n\t\tconst transparent = material.transparent;\n\t\tmaterial.transparent = material.opacity < 1;\n\t\tif ( material.transparent !== transparent ) {\n\n\t\t\tmaterial.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\t_updateBoundHelper( tile, visible ) {\n\n\t\tconst cached = tile.cached;\n\n\t\tif ( ! cached ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst sphereGroup = this.sphereGroup;\n\t\tconst boxGroup = this.boxGroup;\n\t\tconst regionGroup = this.regionGroup;\n\n\t\tif ( visible && ( cached.boxHelperGroup == null && cached.sphereHelper == null && cached.regionHelper == null ) ) {\n\n\t\t\tthis._createBoundHelper( tile );\n\n\t\t}\n\n\t\tconst boxHelperGroup = cached.boxHelperGroup;\n\t\tconst sphereHelper = cached.sphereHelper;\n\t\tconst regionHelper = cached.regionHelper;\n\n\t\tif ( ! visible ) {\n\n\t\t\tif ( boxHelperGroup ) {\n\n\t\t\t\tboxGroup.remove( boxHelperGroup );\n\n\t\t\t}\n\n\t\t\tif ( sphereHelper ) {\n\n\t\t\t\tsphereGroup.remove( sphereHelper );\n\n\t\t\t}\n\n\t\t\tif ( regionHelper ) {\n\n\t\t\t\tregionGroup.remove( regionHelper );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// TODO: consider updating the volumes based on the bounding regions here in case they've been changed\n\t\t\tif ( boxHelperGroup ) {\n\n\t\t\t\tboxGroup.add( boxHelperGroup );\n\t\t\t\tboxHelperGroup.updateMatrixWorld( true );\n\n\t\t\t\tthis._updateHelperMaterial( tile, boxHelperGroup.children[ 0 ].material );\n\n\t\t\t}\n\n\t\t\tif ( sphereHelper ) {\n\n\t\t\t\tsphereGroup.add( sphereHelper );\n\t\t\t\tsphereHelper.updateMatrixWorld( true );\n\n\t\t\t\tthis._updateHelperMaterial( tile, sphereHelper.material );\n\n\t\t\t}\n\n\t\t\tif ( regionHelper ) {\n\n\t\t\t\tregionGroup.add( regionHelper );\n\t\t\t\tregionHelper.updateMatrixWorld( true );\n\n\t\t\t\tthis._updateHelperMaterial( tile, regionHelper.material );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_updateMaterial( scene ) {\n\n\t\t// update the materials for debug rendering\n\t\tconst { colorMode, unlit } = this;\n\t\tscene.traverse( c => {\n\n\t\t\tif ( ! c.material ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst currMaterial = c.material;\n\t\t\tconst originalMaterial = c[ ORIGINAL_MATERIAL ];\n\n\t\t\t// dispose the previous material\n\t\t\tif ( currMaterial !== originalMaterial ) {\n\n\t\t\t\tcurrMaterial.dispose();\n\n\t\t\t}\n\n\t\t\t// assign the new material\n\t\t\tif ( colorMode !== NONE || unlit ) {\n\n\t\t\t\tif ( c.isPoints ) {\n\n\t\t\t\t\tconst pointsMaterial = new PointsMaterial();\n\t\t\t\t\tpointsMaterial.size = originalMaterial.size;\n\t\t\t\t\tpointsMaterial.sizeAttenuation = originalMaterial.sizeAttenuation;\n\t\t\t\t\tc.material = pointsMaterial;\n\n\t\t\t\t} else if ( unlit ) {\n\n\t\t\t\t\tc.material = new MeshBasicMaterial();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tc.material = new MeshStandardMaterial();\n\t\t\t\t\tc.material.flatShading = true;\n\n\t\t\t\t}\n\n\t\t\t\t// if no debug rendering is happening then assign the material properties\n\t\t\t\tif ( colorMode === NONE ) {\n\n\t\t\t\t\tc.material.map = originalMaterial.map;\n\t\t\t\t\tc.material.color.set( originalMaterial.color );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tc.material = originalMaterial;\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t_onLoadModel( scene, tile ) {\n\n\t\ttile[ LOAD_TIME ] = performance.now();\n\n\t\t// Cache the original materials\n\t\tscene.traverse( c => {\n\n\t\t\tconst material = c.material;\n\t\t\tif ( material ) {\n\n\t\t\t\tc[ ORIGINAL_MATERIAL ] = material;\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// Update the materials to align with the settings\n\t\tthis._updateMaterial( scene );\n\n\t}\n\n\t_onDisposeModel( tile ) {\n\n\t\tconst cached = tile.cached;\n\t\tif ( cached.boxHelperGroup ) {\n\n\t\t\tcached.boxHelperGroup.children[ 0 ].geometry.dispose();\n\t\t\tdelete cached.boxHelperGroup;\n\n\t\t}\n\n\t\tif ( cached.sphereHelper ) {\n\n\t\t\tcached.sphereHelper.geometry.dispose();\n\t\t\tdelete cached.sphereHelper;\n\n\t\t}\n\n\t\tif ( cached.regionHelper ) {\n\n\t\t\tcached.regionHelper.geometry.dispose();\n\t\t\tdelete cached.regionHelper;\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tconst tiles = this.tiles;\n\n\t\ttiles.removeEventListener( 'load-tile-set', this._onLoadTileSetCB );\n\t\ttiles.removeEventListener( 'load-model', this._onLoadModelCB );\n\t\ttiles.removeEventListener( 'dispose-model', this._onDisposeModelCB );\n\t\ttiles.removeEventListener( 'update-after', this._onUpdateAfterCB );\n\t\ttiles.removeEventListener( 'tile-visibility-change', this._onTileVisibilityChangeCB );\n\n\t\t// reset all materials\n\t\tthis.colorMode = NONE;\n\t\tthis.unlit = false;\n\t\ttiles.forEachLoadedModel( scene => {\n\n\t\t\tthis._updateMaterial( scene );\n\n\t\t} );\n\n\t\t// dispose of all helper objects\n\t\ttiles.traverse( tile => {\n\n\t\t\tthis._onDisposeModel( tile );\n\n\t\t} );\n\n\t\tthis.boxGroup?.removeFromParent();\n\t\tthis.sphereGroup?.removeFromParent();\n\t\tthis.regionGroup?.removeFromParent();\n\n\t}\n\n}\n"],"names":["ORIGINAL_MATERIAL","HAS_RANDOM_COLOR","HAS_RANDOM_NODE_COLOR","LOAD_TIME","PARENT_BOUND_REF_COUNT","_sphere","Sphere","emptyRaycast","colors","getIndexedRandomColor","index","h","s","l","Color","NONE","SCREEN_ERROR","GEOMETRIC_ERROR","DISTANCE","DEPTH","RELATIVE_DEPTH","IS_LEAF","RANDOM_COLOR","RANDOM_NODE_COLOR","CUSTOM_COLOR","LOAD_ORDER","ColorModes","DebugTilesPlugin","v","tile","options","value","target","tiles","tilesGroup","Group","scene","visible","object","targetTile","c","maxDepth","maxError","_","depth","colorMode","maxDistance","errorTarget","visibleTiles","sortedTiles","b","val","TraversalUtils.traverseAncestors","current","tileVisible","cached","sphere","obb","region","boxHelperGroup","boxHelper","Box3Helper","sphereHelper","SphereHelper","regionHelper","EllipsoidRegionLineHelper","material","transparent","sphereGroup","boxGroup","regionGroup","unlit","currMaterial","originalMaterial","pointsMaterial","PointsMaterial","MeshBasicMaterial","MeshStandardMaterial","_a","_b","_c"],"mappings":"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"}