import{an as U,ao as O,h as W,M as L,aq as X,t as A}from"./three.module-D-uF--xd.js";const p=0,y=["a","b","c"],r=new A,M=new A,_=new A,q=new A;class J{constructor(){this.attributeList=null,this.splitOperations=[],this.trianglePool=new H}forEachSplitPermutation(e){const{splitOperations:o}=this,t=(s=0)=>{if(s>=o.length){e();return}o[s].keepPositive=!0,t(s+1),o[s].keepPositive=!1,t(s+1)};t()}addSplitOperation(e,o=!0){this.splitOperations.push({callback:e,keepPositive:o})}clearSplitOperations(){this.splitOperations.length=0}clipObject(e){const o=e.clone(),t=[];return o.traverse(s=>{s.isMesh&&(s.geometry=this.clip(s).geometry,(s.geometry.index?s.geometry.index.count/3:s.attributes.position.count/3)===0&&t.push(s))}),t.forEach(s=>{s.removeFromParent()}),o}clip(e,o=null){const t=this.getClippedData(e,o);return this.constructMesh(t.attributes,t.index,e)}getClippedData(e,o=null,t={}){const{trianglePool:s,splitOperations:a,attributeList:i}=this,l=e.geometry,c=l.attributes.position,n=l.index;let u=0;const d={};t.index=t.index||[],t.vertexIsClipped=t.vertexIsClipped||[],t.attributes=t.attributes||{};for(const V in l.attributes){if(i!==null){if(i instanceof Function&&!i(V))continue;if(Array.isArray(i)&&!i.includes(V))continue}t.attributes[V]=[]}let h=0,f=n?n.count:c.count;o!==null&&(h=o.start,f=o.count);for(let V=h,E=h+f;V<E;V+=3){let m=V+0,g=V+1,F=V+2;n&&(m=n.getX(m),g=n.getX(g),F=n.getX(F));const C=s.get();C.initFromIndices(m,g,F);let v=[C];for(let w=0;w<a.length;w++){const{keepPositive:I,callback:z}=a[w],B=[];for(let S=0;S<v.length;S++){const k=v[S],{indices:x,barycoord:P}=k;k.clipValues.a=z(l,x.a,x.b,x.c,P.a,e.matrixWorld),k.clipValues.b=z(l,x.a,x.b,x.c,P.b,e.matrixWorld),k.clipValues.c=z(l,x.a,x.b,x.c,P.c,e.matrixWorld),this.splitTriangle(k,!I,B)}v=B}for(let w=0,I=v.length;w<I;w++){const z=v[w];D(z,l)}s.reset()}return t;function D(V,E){for(let m=0;m<3;m++){const g=V.getVertexHash(m,E);g in d||(d[g]=u,u++,V.getVertexData(m,E,t.attributes),t.vertexIsClipped.push(V.clipValues[y[m]]===p));const F=d[g];t.index.push(F)}}}constructMesh(e,o,t){const s=t.geometry,a=new U,i=e.position.length/3>65535?new Uint32Array(o):new Uint16Array(o);a.setIndex(new O(i,1,!1));for(const c in e){const n=s.getAttribute(c),u=new n.array.constructor(e[c]),d=new O(u,n.itemSize,n.normalized);d.gpuType=n.gpuType,a.setAttribute(c,d)}const l=new W(a,t.material.clone());return l.position.copy(t.position),l.quaternion.copy(t.quaternion),l.scale.copy(t.scale),l}splitTriangle(e,o,t){const{trianglePool:s}=this,a=[],i=[],l=[];for(let c=0;c<3;c++){const n=y[c],u=y[(c+1)%3],d=e.clipValues[n],h=e.clipValues[u];(d<p!=h<p||d===p)&&(a.push(c),i.push([n,u]),d===h?l.push(0):l.push(L.mapLinear(p,d,h,0,1)))}if(a.length!==2)Math.min(e.clipValues.a,e.clipValues.b,e.clipValues.c)<p===o&&t.push(e);else if(a.length===2){const c=s.get().initFromTriangle(e),n=s.get().initFromTriangle(e),u=s.get().initFromTriangle(e);(a[0]+1)%3===a[1]?(c.lerpVertexFromEdge(e,i[0][0],i[0][1],l[0],"a"),c.copyVertex(e,i[0][1],"b"),c.lerpVertexFromEdge(e,i[1][0],i[1][1],l[1],"c"),c.clipValues.a=p,c.clipValues.c=p,n.lerpVertexFromEdge(e,i[0][0],i[0][1],l[0],"a"),n.copyVertex(e,i[1][1],"b"),n.copyVertex(e,i[0][0],"c"),n.clipValues.a=p,u.lerpVertexFromEdge(e,i[0][0],i[0][1],l[0],"a"),u.lerpVertexFromEdge(e,i[1][0],i[1][1],l[1],"b"),u.copyVertex(e,i[1][1],"c"),u.clipValues.a=p,u.clipValues.b=p):(c.lerpVertexFromEdge(e,i[0][0],i[0][1],l[0],"a"),c.lerpVertexFromEdge(e,i[1][0],i[1][1],l[1],"b"),c.copyVertex(e,i[0][0],"c"),c.clipValues.a=p,c.clipValues.b=p,n.lerpVertexFromEdge(e,i[0][0],i[0][1],l[0],"a"),n.copyVertex(e,i[0][1],"b"),n.lerpVertexFromEdge(e,i[1][0],i[1][1],l[1],"c"),n.clipValues.a=p,n.clipValues.c=p,u.copyVertex(e,i[0][1],"a"),u.copyVertex(e,i[1][0],"b"),u.lerpVertexFromEdge(e,i[1][0],i[1][1],l[1],"c"),u.clipValues.c=p);let h,f;h=Math.min(c.clipValues.a,c.clipValues.b,c.clipValues.c),f=h<p,f===o&&t.push(c),h=Math.min(n.clipValues.a,n.clipValues.b,n.clipValues.c),f=h<p,f===o&&t.push(n),h=Math.min(u.clipValues.a,u.clipValues.b,u.clipValues.c),f=h<p,f===o&&t.push(u)}}}class H{constructor(){this.pool=[],this.index=0}get(){if(this.index>=this.pool.length){const o=new j;this.pool.push(o)}const e=this.pool[this.index];return this.index++,e}reset(){this.index=0}}class j{constructor(){this.indices={a:-1,b:-1,c:-1},this.clipValues={a:-1,b:-1,c:-1},this.barycoord=new X}getVertexHash(e,o){const{barycoord:t,indices:s}=this,a=y[e],i=t[a];if(i.x===1)return s[y[0]];if(i.y===1)return s[y[1]];if(i.z===1)return s[y[2]];{const{attributes:l}=o;let c="";for(const n in l){const u=l[n];switch(G(u,s.a,s.b,s.c,i,r),(n==="normal"||n==="tangent"||n==="bitangent")&&r.normalize(),u.itemSize){case 4:c+=T(r.x,r.y,r.z,r.w);break;case 3:c+=T(r.x,r.y,r.z);break;case 2:c+=T(r.x,r.y);break;case 1:c+=T(r.x);break}c+="|"}return c}}getVertexData(e,o,t){const{barycoord:s,indices:a}=this,i=y[e],l=s[i],{attributes:c}=o;for(const n in c){if(!t[n])continue;const u=c[n],d=t[n];switch(G(u,a.a,a.b,a.c,l,r),(n==="normal"||n==="tangent"||n==="bitangent")&&r.normalize(),u.itemSize){case 4:d.push(r.x,r.y,r.z,r.w);break;case 3:d.push(r.x,r.y,r.z);break;case 2:d.push(r.x,r.y);break;case 1:d.push(r.x);break}}}initFromTriangle(e){return this.initFromIndices(e.indices.a,e.indices.b,e.indices.c)}initFromIndices(e,o,t){return this.indices.a=e,this.indices.b=o,this.indices.c=t,this.clipValues.a=-1,this.clipValues.b=-1,this.clipValues.c=-1,this.barycoord.a.set(1,0,0),this.barycoord.b.set(0,1,0),this.barycoord.c.set(0,0,1),this}lerpVertexFromEdge(e,o,t,s,a){this.clipValues[a]=L.lerp(e.clipValues[o],e.clipValues[t],s),this.barycoord[a].lerpVectors(e.barycoord[o],e.barycoord[t],s)}copyVertex(e,o,t){this.clipValues[t]=e.clipValues[o],this.barycoord[t].copy(e.barycoord[o])}}function G(b,e,o,t,s,a){switch(M.fromBufferAttribute(b,e),_.fromBufferAttribute(b,o),q.fromBufferAttribute(b,t),a.set(0,0,0,0).addScaledVector(M,s.x).addScaledVector(_,s.y).addScaledVector(q,s.z),b.itemSize){case 3:r.w=0;break;case 2:r.w=0,r.z=0;break;case 1:r.w=0,r.z=0,r.y=0;break}return a}function T(...b){let t="";for(let s=0,a=b.length;s<a;s++)t+=~~(b[s]*1e5+.5),s!==a-1&&(t+="_");return t}export{J as G,T as h};
//# sourceMappingURL=GeometryClipper-7b525s21.js.map
