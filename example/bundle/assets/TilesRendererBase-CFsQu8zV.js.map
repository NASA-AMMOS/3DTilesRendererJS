{"version":3,"file":"TilesRendererBase-CFsQu8zV.js","sources":["../../../src/core/renderer/utilities/urlExtension.js","../../../src/core/renderer/utilities/LRUCache.js","../../../src/core/renderer/utilities/PriorityQueue.js","../../../src/core/renderer/tiles/optimizedTraverseFunctions.js","../../../src/core/renderer/tiles/traverseFunctions.js","../../../src/core/renderer/utilities/throttle.js","../../../src/core/renderer/utilities/TraversalUtils.js","../../../src/core/renderer/tiles/TilesRendererBase.js"],"sourcesContent":["/**\n * Returns the file extension of the path component of a URL\n * @param {string} url\n * @returns {string} null if no extension found\n */\nexport function getUrlExtension( url ) {\n\n\tif ( ! url ) {\n\n\t\treturn null;\n\n\t}\n\n\t// Find the last occurrence of '?' and '#' to handle query params and fragments\n\tlet endIndex = url.length;\n\tconst queryIndex = url.indexOf( '?' );\n\tconst fragmentIndex = url.indexOf( '#' );\n\tif ( queryIndex !== - 1 ) {\n\n\t\tendIndex = Math.min( endIndex, queryIndex );\n\n\t}\n\n\tif ( fragmentIndex !== - 1 ) {\n\n\t\tendIndex = Math.min( endIndex, fragmentIndex );\n\n\t}\n\n\t// Check if the string is just a hostname or whether the path does not end in an extension\n\tconst lastPeriodIndex = url.lastIndexOf( '.', endIndex );\n\tconst lastSlashIndex = url.lastIndexOf( '/', endIndex );\n\tconst protocolIndex = url.indexOf( '://' );\n\tconst isHostOnly = protocolIndex !== - 1 && protocolIndex + 2 === lastSlashIndex;\n\tif ( isHostOnly || lastPeriodIndex === - 1 || lastPeriodIndex < lastSlashIndex ) {\n\n\t\treturn null;\n\n\t}\n\n\treturn url.substring( lastPeriodIndex + 1, endIndex ) || null;\n\n}\n","const GIGABYTE_BYTES = 2 ** 30;\n\nclass LRUCache {\n\n\tget unloadPriorityCallback() {\n\n\t\treturn this._unloadPriorityCallback;\n\n\t}\n\n\tset unloadPriorityCallback( cb ) {\n\n\t\tif ( cb.length === 1 ) {\n\n\t\t\tconsole.warn( 'LRUCache: \"unloadPriorityCallback\" function has been changed to take two arguments.' );\n\t\t\tthis._unloadPriorityCallback = ( a, b ) => {\n\n\t\t\t\tconst valA = cb( a );\n\t\t\t\tconst valB = cb( b );\n\n\t\t\t\tif ( valA < valB ) return - 1;\n\t\t\t\tif ( valA > valB ) return 1;\n\t\t\t\treturn 0;\n\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tthis._unloadPriorityCallback = cb;\n\n\t\t}\n\n\t}\n\n\tconstructor() {\n\n\t\t// options\n\t\tthis.minSize = 6000;\n\t\tthis.maxSize = 8000;\n\t\tthis.minBytesSize = 0.3 * GIGABYTE_BYTES;\n\t\tthis.maxBytesSize = 0.4 * GIGABYTE_BYTES;\n\t\tthis.unloadPercent = 0.05;\n\t\tthis.autoMarkUnused = true;\n\n\t\t// \"itemSet\" doubles as both the list of the full set of items currently\n\t\t// stored in the cache (keys) as well as a map to the time the item was last\n\t\t// used so it can be sorted appropriately.\n\t\tthis.itemSet = new Map();\n\t\tthis.itemList = [];\n\t\tthis.usedSet = new Set();\n\t\tthis.callbacks = new Map();\n\t\tthis.unloadingHandle = - 1;\n\t\tthis.cachedBytes = 0;\n\t\tthis.bytesMap = new Map();\n\t\tthis.loadedSet = new Set();\n\n\t\tthis._unloadPriorityCallback = null;\n\n\t\tconst itemSet = this.itemSet;\n\t\tthis.defaultPriorityCallback = item => itemSet.get( item );\n\n\t}\n\n\t// Returns whether or not the cache has reached the maximum size\n\tisFull() {\n\n\t\treturn this.itemSet.size >= this.maxSize || this.cachedBytes >= this.maxBytesSize;\n\n\t}\n\n\tgetMemoryUsage( item ) {\n\n\t\treturn this.bytesMap.get( item ) || 0;\n\n\t}\n\n\tsetMemoryUsage( item, bytes ) {\n\n\t\tconst { bytesMap, itemSet } = this;\n\t\tif ( ! itemSet.has( item ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.cachedBytes -= bytesMap.get( item ) || 0;\n\t\tbytesMap.set( item, bytes );\n\t\tthis.cachedBytes += bytes;\n\n\t}\n\n\tadd( item, removeCb ) {\n\n\t\tconst itemSet = this.itemSet;\n\t\tif ( itemSet.has( item ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( this.isFull() ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst usedSet = this.usedSet;\n\t\tconst itemList = this.itemList;\n\t\tconst callbacks = this.callbacks;\n\t\titemList.push( item );\n\t\tusedSet.add( item );\n\t\titemSet.set( item, Date.now() );\n\t\tcallbacks.set( item, removeCb );\n\n\t\treturn true;\n\n\t}\n\n\thas( item ) {\n\n\t\treturn this.itemSet.has( item );\n\n\t}\n\n\tremove( item ) {\n\n\t\tconst usedSet = this.usedSet;\n\t\tconst itemSet = this.itemSet;\n\t\tconst itemList = this.itemList;\n\t\tconst bytesMap = this.bytesMap;\n\t\tconst callbacks = this.callbacks;\n\t\tconst loadedSet = this.loadedSet;\n\n\t\tif ( itemSet.has( item ) ) {\n\n\t\t\tthis.cachedBytes -= bytesMap.get( item ) || 0;\n\t\t\tbytesMap.delete( item );\n\n\t\t\tcallbacks.get( item )( item );\n\n\t\t\tconst index = itemList.indexOf( item );\n\t\t\titemList.splice( index, 1 );\n\t\t\tusedSet.delete( item );\n\t\t\titemSet.delete( item );\n\t\t\tcallbacks.delete( item );\n\t\t\tloadedSet.delete( item );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t// Marks whether tiles in the cache have been completely loaded or not. Tiles that have not been completely\n\t// loaded are subject to being disposed early if the cache is full above its max size limits, even if they\n\t// are marked as used.\n\tsetLoaded( item, value ) {\n\n\t\tconst { itemSet, loadedSet } = this;\n\t\tif ( itemSet.has( item ) ) {\n\n\t\t\tif ( value === true ) {\n\n\t\t\t\tloadedSet.add( item );\n\n\t\t\t} else {\n\n\t\t\t\tloadedSet.delete( item );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tmarkUsed( item ) {\n\n\t\tconst itemSet = this.itemSet;\n\t\tconst usedSet = this.usedSet;\n\t\tif ( itemSet.has( item ) && ! usedSet.has( item ) ) {\n\n\t\t\titemSet.set( item, Date.now() );\n\t\t\tusedSet.add( item );\n\n\t\t}\n\n\t}\n\n\tmarkUnused( item ) {\n\n\t\tthis.usedSet.delete( item );\n\n\t}\n\n\tmarkAllUnused() {\n\n\t\tthis.usedSet.clear();\n\n\t}\n\n\tisUsed( item ) {\n\n\t\treturn this.usedSet.has( item );\n\n\t}\n\n\t// TODO: this should be renamed because it's not necessarily unloading all unused content\n\t// Maybe call it \"cleanup\" or \"unloadToMinSize\"\n\tunloadUnusedContent() {\n\n\t\tconst {\n\t\t\tunloadPercent,\n\t\t\tminSize,\n\t\t\tmaxSize,\n\t\t\titemList,\n\t\t\titemSet,\n\t\t\tusedSet,\n\t\t\tloadedSet,\n\t\t\tcallbacks,\n\t\t\tbytesMap,\n\t\t\tminBytesSize,\n\t\t\tmaxBytesSize,\n\t\t} = this;\n\n\t\tconst unused = itemList.length - usedSet.size;\n\t\tconst unloaded = itemList.length - loadedSet.size;\n\t\tconst excessNodes = Math.max( Math.min( itemList.length - minSize, unused ), 0 );\n\t\tconst excessBytes = this.cachedBytes - minBytesSize;\n\t\tconst unloadPriorityCallback = this.unloadPriorityCallback || this.defaultPriorityCallback;\n\t\tlet needsRerun = false;\n\n\t\tconst hasNodesToUnload = excessNodes > 0 && unused > 0 || unloaded && itemList.length > maxSize;\n\t\tconst hasBytesToUnload = unused && this.cachedBytes > minBytesSize || unloaded && this.cachedBytes > maxBytesSize;\n\t\tif ( hasBytesToUnload || hasNodesToUnload ) {\n\n\t\t\t// used items should be at the end of the array, \"unloaded\" items in the middle of the array\n\t\t\titemList.sort( ( a, b ) => {\n\n\t\t\t\tconst usedA = usedSet.has( a );\n\t\t\t\tconst usedB = usedSet.has( b );\n\t\t\t\tif ( usedA === usedB ) {\n\n\t\t\t\t\tconst loadedA = loadedSet.has( a );\n\t\t\t\t\tconst loadedB = loadedSet.has( b );\n\t\t\t\t\tif ( loadedA === loadedB ) {\n\n\t\t\t\t\t\t// Use the sort function otherwise\n\t\t\t\t\t\t// higher priority should be further to the left\n\t\t\t\t\t\treturn - unloadPriorityCallback( a, b );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn loadedA ? 1 : - 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If one is used and the other is not move the used one towards the end of the array\n\t\t\t\t\treturn usedA ? 1 : - 1;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\t// address corner cases where the minSize might be zero or smaller than maxSize - minSize,\n\t\t\t// which would result in a very small or no items being unloaded.\n\t\t\tconst maxUnload = Math.max( minSize * unloadPercent, excessNodes * unloadPercent );\n\t\t\tconst nodesToUnload = Math.ceil( Math.min( maxUnload, unused, excessNodes ) );\n\t\t\tconst maxBytesUnload = Math.max( unloadPercent * excessBytes, unloadPercent * minBytesSize );\n\t\t\tconst bytesToUnload = Math.min( maxBytesUnload, excessBytes );\n\n\t\t\tlet removedNodes = 0;\n\t\t\tlet removedBytes = 0;\n\n\t\t\t// evict up to the max node or bytes size, keeping one more item over the max bytes limit\n\t\t\t// so the \"full\" function behaves correctly.\n\t\t\twhile (\n\t\t\t\tthis.cachedBytes - removedBytes > maxBytesSize ||\n\t\t\t\titemList.length - removedNodes > maxSize\n\t\t\t) {\n\n\t\t\t\tconst item = itemList[ removedNodes ];\n\t\t\t\tconst bytes = bytesMap.get( item ) || 0;\n\t\t\t\tif (\n\t\t\t\t\tusedSet.has( item ) && loadedSet.has( item ) ||\n\t\t\t\t\tthis.cachedBytes - removedBytes - bytes < maxBytesSize &&\n\t\t\t\t\titemList.length - removedNodes <= maxSize\n\t\t\t\t) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tremovedBytes += bytes;\n\t\t\t\tremovedNodes ++;\n\n\t\t\t}\n\n\t\t\t// evict up to the min node or bytes size, keeping one more item over the min bytes limit\n\t\t\t// so we're meeting it\n\t\t\twhile (\n\t\t\t\tremovedBytes < bytesToUnload ||\n\t\t\t\tremovedNodes < nodesToUnload\n\t\t\t) {\n\n\t\t\t\tconst item = itemList[ removedNodes ];\n\t\t\t\tconst bytes = bytesMap.get( item ) || 0;\n\t\t\t\tif (\n\t\t\t\t\tusedSet.has( item ) ||\n\t\t\t\t\tthis.cachedBytes - removedBytes - bytes < minBytesSize &&\n\t\t\t\t\tremovedNodes >= nodesToUnload\n\t\t\t\t) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tremovedBytes += bytes;\n\t\t\t\tremovedNodes ++;\n\n\t\t\t}\n\n\t\t\t// remove the nodes\n\t\t\titemList.splice( 0, removedNodes ).forEach( item => {\n\n\t\t\t\tthis.cachedBytes -= bytesMap.get( item ) || 0;\n\n\t\t\t\tcallbacks.get( item )( item );\n\t\t\t\tbytesMap.delete( item );\n\t\t\t\titemSet.delete( item );\n\t\t\t\tcallbacks.delete( item );\n\t\t\t\tloadedSet.delete( item );\n\t\t\t\tusedSet.delete( item );\n\n\t\t\t} );\n\n\t\t\t// if we didn't remove enough nodes or we still have excess bytes and there are nodes to removed\n\t\t\t// then we want to fire another round of unloading\n\t\t\tneedsRerun = removedNodes < excessNodes || removedBytes < excessBytes && removedNodes < unused;\n\t\t\tneedsRerun = needsRerun && removedNodes > 0;\n\n\t\t}\n\n\t\tif ( needsRerun ) {\n\n\t\t\tthis.unloadingHandle = requestAnimationFrame( () => this.scheduleUnload() );\n\n\t\t}\n\n\t}\n\n\tscheduleUnload() {\n\n\t\tcancelAnimationFrame( this.unloadingHandle );\n\n\t\tif ( ! this.scheduled ) {\n\n\t\t\tthis.scheduled = true;\n\t\t\tqueueMicrotask( () => {\n\n\t\t\t\tthis.scheduled = false;\n\t\t\t\tthis.unloadUnusedContent();\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\nexport { LRUCache };\n","export class PriorityQueueItemRemovedError extends Error {\n\n\tconstructor() {\n\n\t\tsuper( 'PriorityQueue: Item removed' );\n\t\tthis.name = 'PriorityQueueItemRemovedError';\n\n\t}\n\n}\n\nexport class PriorityQueue {\n\n\t// returns whether tasks are queued or actively running\n\tget running() {\n\n\t\treturn this.items.length !== 0 || this.currJobs !== 0;\n\n\t}\n\n\tconstructor() {\n\n\t\t// options\n\t\tthis.maxJobs = 6;\n\n\t\tthis.items = [];\n\t\tthis.callbacks = new Map();\n\t\tthis.currJobs = 0;\n\t\tthis.scheduled = false;\n\t\tthis.autoUpdate = true;\n\n\t\tthis.priorityCallback = null;\n\n\t\t// Customizable scheduling callback. Default using requestAnimationFrame()\n\t\tthis.schedulingCallback = func => {\n\n\t\t\trequestAnimationFrame( func );\n\n\t\t};\n\n\t\tthis._runjobs = () => {\n\n\t\t\tthis.scheduled = false;\n\t\t\tthis.tryRunJobs();\n\n\t\t};\n\n\t}\n\n\tsort() {\n\n\t\tconst priorityCallback = this.priorityCallback;\n\t\tconst items = this.items;\n\t\tif ( priorityCallback !== null ) {\n\n\t\t\titems.sort( priorityCallback );\n\n\t\t}\n\n\t}\n\n\thas( item ) {\n\n\t\treturn this.callbacks.has( item );\n\n\t}\n\n\tadd( item, callback ) {\n\n\t\tconst data = {\n\t\t\tcallback,\n\t\t\treject: null,\n\t\t\tresolve: null,\n\t\t\tpromise: null,\n\t\t};\n\n\t\tdata.promise = new Promise( ( resolve, reject ) => {\n\n\t\t\tconst items = this.items;\n\t\t\tconst callbacks = this.callbacks;\n\n\t\t\tdata.resolve = resolve;\n\t\t\tdata.reject = reject;\n\n\t\t\titems.unshift( item );\n\t\t\tcallbacks.set( item, data );\n\n\t\t\tif ( this.autoUpdate ) {\n\n\t\t\t\tthis.scheduleJobRun();\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn data.promise;\n\n\t}\n\n\tremove( item ) {\n\n\t\tconst items = this.items;\n\t\tconst callbacks = this.callbacks;\n\n\t\tconst index = items.indexOf( item );\n\t\tif ( index !== - 1 ) {\n\n\t\t\t// reject the promise to ensure there are no dangling promises - add a\n\t\t\t// catch here to handle the case where the promise was never used anywhere\n\t\t\t// else.\n\t\t\tconst info = callbacks.get( item );\n\t\t\tinfo.promise.catch( err => {\n\n\t\t\t\tif ( ! ( err instanceof PriorityQueueItemRemovedError ) ) {\n\n\t\t\t\t\tthrow err;\n\n\t\t\t\t}\n\n\t\t\t} );\n\t\t\tinfo.reject( new PriorityQueueItemRemovedError() );\n\n\t\t\titems.splice( index, 1 );\n\t\t\tcallbacks.delete( item );\n\n\t\t}\n\n\t}\n\n\tremoveByFilter( filter ) {\n\n\t\tconst { items } = this;\n\t\tfor ( let i = 0; i < items.length; i ++ ) {\n\n\t\t\tconst item = items[ i ];\n\t\t\tif ( filter( item ) ) {\n\n\t\t\t\tthis.remove( item );\n\t\t\t\ti --;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttryRunJobs() {\n\n\t\tthis.sort();\n\n\t\tconst items = this.items;\n\t\tconst callbacks = this.callbacks;\n\t\tconst maxJobs = this.maxJobs;\n\t\tlet iterated = 0;\n\n\t\tconst completedCallback = () => {\n\n\t\t\tthis.currJobs --;\n\n\t\t\tif ( this.autoUpdate ) {\n\n\t\t\t\tthis.scheduleJobRun();\n\n\t\t\t}\n\n\t\t};\n\n\t\twhile ( maxJobs > this.currJobs && items.length > 0 && iterated < maxJobs ) {\n\n\t\t\tthis.currJobs ++;\n\t\t\titerated ++;\n\t\t\tconst item = items.pop();\n\t\t\tconst { callback, resolve, reject } = callbacks.get( item );\n\t\t\tcallbacks.delete( item );\n\n\t\t\tlet result;\n\t\t\ttry {\n\n\t\t\t\tresult = callback( item );\n\n\t\t\t} catch ( err ) {\n\n\t\t\t\treject( err );\n\t\t\t\tcompletedCallback();\n\n\t\t\t}\n\n\t\t\tif ( result instanceof Promise ) {\n\n\t\t\t\tresult\n\t\t\t\t\t.then( resolve )\n\t\t\t\t\t.catch( reject )\n\t\t\t\t\t.finally( completedCallback );\n\n\t\t\t} else {\n\n\t\t\t\tresolve( result );\n\t\t\t\tcompletedCallback();\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tscheduleJobRun() {\n\n\t\tif ( ! this.scheduled ) {\n\n\t\t\tthis.schedulingCallback( this._runjobs );\n\n\t\t\tthis.scheduled = true;\n\n\t\t}\n\n\t}\n\n}\n","import { LOADED, FAILED } from '../constants.js';\n\nconst viewErrorTarget = {\n\tinView: false,\n\terror: Infinity,\n\tdistanceFromCamera: Infinity,\n};\n\nfunction isDownloadFinished( value ) {\n\n\treturn value === LOADED || value === FAILED;\n\n}\n\n// Checks whether this tile was last used on the given frame.\nfunction isUsedThisFrame( tile, frameCount ) {\n\n\treturn isProcessed( tile ) && tile.traversal.lastFrameVisited === frameCount && tile.traversal.used;\n\n}\n\nfunction isProcessed( tile ) {\n\n\treturn Boolean( tile.traversal );\n\n}\n\n// Checks whether all children have been processed and are ready to traverse\nfunction areChildrenProcessed( tile ) {\n\n\t// all children are processed at once\n\tconst childrenReady = tile.children.length === 0 || Boolean( tile.children[ 0 ].internal );\n\tconst contentReady = ! tile.internal.hasUnrenderableContent || isDownloadFinished( tile.internal.loadingState );\n\treturn childrenReady && contentReady;\n\n}\n\n// Checks whether we can stop at this tile for rendering or not\nfunction canUnconditionallyRefine( tile ) {\n\n\treturn tile.internal.hasUnrenderableContent || ( tile.parent && tile.parent.geometricError < tile.geometricError );\n\n}\n\n// Resets the frame information for the given tile\nfunction resetFrameState( tile, renderer ) {\n\n\trenderer.ensureChildrenArePreprocessed( tile );\n\n\tif ( tile.traversal.lastFrameVisited !== renderer.frameCount ) {\n\n\t\ttile.traversal.lastFrameVisited = renderer.frameCount;\n\t\ttile.traversal.used = false;\n\t\ttile.traversal.inFrustum = false;\n\t\ttile.traversal.isLeaf = false;\n\t\ttile.traversal.visible = false;\n\t\ttile.traversal.active = false;\n\t\ttile.traversal.error = Infinity;\n\t\ttile.traversal.distanceFromCamera = Infinity;\n\t\ttile.traversal.allChildrenReady = false;\n\t\ttile.traversal.kicked = false;\n\t\ttile.traversal.allUsedChildrenProcessed = false;\n\n\t\t// update tile frustum and error state\n\t\trenderer.calculateTileViewErrorWithPlugin( tile, viewErrorTarget );\n\t\ttile.traversal.inFrustum = viewErrorTarget.inView;\n\t\ttile.traversal.error = viewErrorTarget.error;\n\t\ttile.traversal.distanceFromCamera = viewErrorTarget.distanceFromCamera;\n\n\t}\n\n}\n\n// Recursively mark tiles used down to the next layer, skipping external tilesets\nfunction recursivelyMarkUsed( tile, renderer, cacheOnly = false ) {\n\n\tresetFrameState( tile, renderer );\n\tif ( cacheOnly ) {\n\n\t\trenderer.markTileUsed( tile );\n\n\t} else {\n\n\t\tmarkUsed( tile );\n\n\t}\n\n\t// don't traverse if the children have not been processed, yet but tileset content\n\t// should be considered to be \"replaced\" by the loaded children so await that here.\n\tif ( canUnconditionallyRefine( tile ) && areChildrenProcessed( tile ) ) {\n\n\t\tconst children = tile.children;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\trecursivelyMarkUsed( children[ i ], renderer, cacheOnly );\n\n\t\t}\n\n\t}\n\n}\n\n// Recursively mark tiles used down to the next layer, skipping external tilesets\nfunction recursivelyMarkPreviouslyUsed( tile, renderer ) {\n\n\tresetFrameState( tile, renderer );\n\n\tif ( tile.traversal.usedLastFrame ) {\n\n\t\tmarkUsed( tile, renderer );\n\n\t\tif ( tile.traversal.wasSetActive ) {\n\n\t\t\ttile.traversal.active = true;\n\n\t\t}\n\n\t\tif ( ! tile.traversal.active || canUnconditionallyRefine( tile ) ) {\n\n\t\t\t// don't traverse if the children have not been processed, yet but tileset content\n\t\t\t// should be considered to be \"replaced\" by the loaded children so await that here.\n\t\t\tif ( areChildrenProcessed( tile ) ) {\n\n\t\t\t\tconst children = tile.children;\n\t\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\t\trecursivelyMarkPreviouslyUsed( children[ i ], renderer );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n// Mark a tile as being used by current view\nfunction markUsed( tile ) {\n\n\ttile.traversal.used = true;\n\n}\n\n// Returns whether the tile can be traversed to the next layer of children by checking the tile metrics\nfunction canTraverse( tile, renderer ) {\n\n\t// If we've met the error requirements then don't load further - if an external tileset is encountered,\n\t// though, then continue to refine.\n\tif ( tile.traversal.error <= renderer.errorTarget && ! canUnconditionallyRefine( tile ) ) {\n\n\t\treturn false;\n\n\t}\n\n\t// Early out if we've reached the maximum allowed depth.\n\tif ( renderer.maxDepth > 0 && tile.internal.depth + 1 >= renderer.maxDepth ) {\n\n\t\treturn false;\n\n\t}\n\n\t// Early out if the children haven't been processed, yet\n\tif ( ! areChildrenProcessed( tile ) ) {\n\n\t\treturn false;\n\n\t}\n\n\treturn true;\n\n}\n\n// Marks \"active\" children as \"kicked\" so they are still loaded but not rendered yet\nfunction kickActiveChildren( tile, renderer ) {\n\n\tconst { frameCount } = renderer;\n\tconst { children } = tile;\n\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\tconst c = children[ i ];\n\t\tif ( isUsedThisFrame( c, frameCount ) ) {\n\n\t\t\tif ( c.traversal.active ) {\n\n\t\t\t\tc.traversal.kicked = true;\n\t\t\t\tc.traversal.active = false;\n\n\t\t\t}\n\n\t\t\tkickActiveChildren( c, renderer );\n\n\t\t}\n\n\t}\n\n}\n\n// Checks whether this tile is ready to be stopped at for rendering\nfunction isChildReady( tile ) {\n\n\treturn ! canUnconditionallyRefine( tile ) && ( ! tile.internal.hasContent || isDownloadFinished( tile.internal.loadingState ) );\n\n}\n\n// Determine which tiles are used by the renderer given the current camera configuration\nfunction markUsedTiles( tile, renderer ) {\n\n\t// determine frustum set is run first so we can ensure the preprocessing of all the necessary\n\t// child tiles has happened here.\n\tresetFrameState( tile, renderer );\n\n\tif ( ! tile.traversal.inFrustum ) {\n\n\t\treturn;\n\n\t}\n\n\tif ( ! canTraverse( tile, renderer ) ) {\n\n\t\tmarkUsed( tile );\n\t\treturn;\n\n\t}\n\n\t// Traverse children and see if any children are in view.\n\tlet anyChildrenUsed = false;\n\tlet anyChildrenInFrustum = false;\n\tconst children = tile.children;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\tconst c = children[ i ];\n\t\tmarkUsedTiles( c, renderer );\n\t\tanyChildrenUsed = anyChildrenUsed || isUsedThisFrame( c, renderer.frameCount );\n\t\tanyChildrenInFrustum = anyChildrenInFrustum || c.traversal.inFrustum;\n\n\t}\n\n\t// If none of the children are visible in the frustum then there should be no reason to display this tile. We still mark\n\t// this tile and all children as \"used\" only in the cache (but not loaded) so they are not disposed, causing an oscillation\n\t// / flicker in the content.\n\tif ( tile.refine === 'REPLACE' && ! anyChildrenInFrustum && children.length !== 0 ) {\n\n\t\ttile.traversal.inFrustum = false;\n\n\t\trenderer.markTileUsed( tile );\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\trecursivelyMarkUsed( children[ i ], renderer, true );\n\n\t\t}\n\n\t\treturn;\n\n\t}\n\n\t// wait until after the above condition to mark the traversed tile as used or not\n\t// and then mark any of the sibling child tiles as used\n\tmarkUsed( tile );\n\n\tif ( tile.refine === 'REPLACE' && anyChildrenUsed && renderer.loadSiblings ) {\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\trecursivelyMarkUsed( children[ i ], renderer );\n\n\t\t}\n\n\t}\n\n}\n\n// Traverse and mark the tiles that are at the leaf nodes of the \"used\" tree.\nfunction markUsedSetLeaves( tile, renderer ) {\n\n\tconst frameCount = renderer.frameCount;\n\tif ( ! isUsedThisFrame( tile, frameCount ) ) {\n\n\t\treturn;\n\n\t}\n\n\t// This tile is a leaf if none of the children had been used.\n\tconst children = tile.children;\n\tlet anyChildrenUsed = false;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\tconst c = children[ i ];\n\t\tanyChildrenUsed = anyChildrenUsed || isUsedThisFrame( c, frameCount );\n\n\t}\n\n\t// Traversal\n\tif ( ! anyChildrenUsed ) {\n\n\t\ttile.traversal.isLeaf = true;\n\n\t} else {\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tmarkUsedSetLeaves( children[ i ], renderer );\n\n\t\t}\n\n\t}\n\n\t// save whether any children are processed\n\tlet allUsedChildrenProcessed = true;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\tconst c = children[ i ];\n\t\tif ( isUsedThisFrame( c, renderer.frameCount ) && ! c.traversal.allUsedChildrenProcessed ) {\n\n\t\t\tallUsedChildrenProcessed = false;\n\n\t\t}\n\n\t}\n\n\ttile.traversal.allUsedChildrenProcessed = allUsedChildrenProcessed && areChildrenProcessed( tile );\n\n}\n\n// TODO: revisit implementation\n// Skip past tiles we consider unrenderable because they are outside the error threshold.\nfunction markVisibleTiles( tile, renderer ) {\n\n\tif ( ! isUsedThisFrame( tile, renderer.frameCount ) ) {\n\n\t\treturn;\n\n\t}\n\n\tconst hasContent = tile.internal.hasContent;\n\tconst loadedContent = isDownloadFinished( tile.internal.loadingState ) && hasContent;\n\tconst children = tile.children;\n\tif ( tile.traversal.isLeaf ) {\n\n\t\t// if we're allowed to stop at this tile then mark it as active and allow any previously active tiles to\n\t\t// continue to be displayed\n\t\tif ( ! canUnconditionallyRefine( tile ) ) {\n\n\t\t\ttile.traversal.active = true;\n\n\t\t\tif ( areChildrenProcessed( tile ) && ( ! tile.internal.hasContent || ! isDownloadFinished( tile.internal.loadingState ) ) ) {\n\n\t\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\t\trecursivelyMarkPreviouslyUsed( children[ i ], renderer );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn;\n\n\t}\n\n\t// Don't wait for all children tiles to load if this tileset has empty tiles at the root in order\n\t// to match Cesium's behavior\n\tlet allChildrenReady = children.length > 0;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\tconst c = children[ i ];\n\t\tmarkVisibleTiles( c, renderer );\n\n\t\tif ( isUsedThisFrame( c, renderer.frameCount ) ) {\n\n\t\t\tconst childIsReady = c.traversal.active && isChildReady( c );\n\t\t\tif ( ! childIsReady && ! c.traversal.allChildrenReady ) {\n\n\t\t\t\tallChildrenReady = false;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttile.traversal.allChildrenReady = allChildrenReady;\n\n\t// If we find that the subsequent children are not ready such that this tile gap can be filled then\n\t// mark all lower tiles as non active and prepare this one to be displayed if possible\n\tconst thisTileIsVisible = tile.traversal.active && isChildReady( tile );\n\tif ( ! canUnconditionallyRefine( tile ) && ! allChildrenReady && ! thisTileIsVisible ) {\n\n\t\tif ( tile.traversal.wasSetActive && ( loadedContent || ! tile.internal.hasContent ) ) {\n\n\t\t\ttile.traversal.active = true;\n\t\t\tkickActiveChildren( tile, renderer );\n\n\t\t}\n\n\t}\n\n}\n\n// Final traverse to toggle tile visibility.\nfunction toggleTiles( tile, renderer ) {\n\n\tconst isUsed = isUsedThisFrame( tile, renderer.frameCount );\n\tif ( isUsed ) {\n\n\t\t// any internal tileset and additive tile must be marked as active and loaded\n\t\tif ( tile.internal.hasUnrenderableContent || tile.internal.hasRenderableContent && tile.refine === 'ADD' ) {\n\n\t\t\ttile.traversal.active = true;\n\n\t\t}\n\n\t\t// queue any tiles to load that we need to, and unmark any unloaded or non visible tiles as \"active\"\n\t\t// TODO: it may be more simple to track a separate variable than \"active\" here\n\t\tif ( ( tile.traversal.active || tile.traversal.kicked ) && tile.internal.hasContent ) {\n\n\t\t\trenderer.markTileUsed( tile );\n\n\t\t\tif ( tile.internal.hasUnrenderableContent || tile.traversal.allUsedChildrenProcessed ) {\n\n\t\t\t\trenderer.queueTileForDownload( tile );\n\n\t\t\t}\n\n\t\t\tif ( tile.internal.loadingState !== LOADED ) {\n\n\t\t\t\ttile.traversal.active = false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\ttile.traversal.active = false;\n\n\t\t}\n\n\t\t// if the tile is loaded and in frustum we can mark it as visible\n\t\ttile.traversal.visible = tile.internal.hasRenderableContent && tile.traversal.active && tile.traversal.inFrustum && tile.internal.loadingState === LOADED;\n\t\trenderer.stats.used ++;\n\n\t\tif ( tile.traversal.inFrustum ) {\n\n\t\t\trenderer.stats.inFrustum ++;\n\n\t\t}\n\n\t}\n\n\tif ( isUsed || isProcessed( tile ) && tile.traversal?.usedLastFrame ) {\n\n\t\tlet setActive = false;\n\t\tlet setVisible = false;\n\t\tif ( isUsed ) {\n\n\t\t\t// enable visibility if active due to shadows\n\t\t\tsetActive = tile.traversal.active;\n\t\t\tif ( renderer.displayActiveTiles ) {\n\n\t\t\t\tsetVisible = tile.traversal.active || tile.traversal.visible;\n\n\t\t\t} else {\n\n\t\t\t\tsetVisible = tile.traversal.visible;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// if the tile was used last frame but not this one then there's potential for the tile\n\t\t\t// to not have been visited during the traversal, meaning it hasn't been reset and has\n\t\t\t// stale values. This ensures the values are not stale.\n\t\t\tresetFrameState( tile, renderer );\n\n\t\t}\n\n\t\t// If the active or visible state changed then call the functions.\n\t\tif ( tile.internal.hasRenderableContent && tile.internal.loadingState === LOADED ) {\n\n\t\t\tif ( tile.traversal.wasSetActive !== setActive ) {\n\n\t\t\t\trenderer.stats.active += setActive ? 1 : - 1;\n\t\t\t\trenderer.invokeOnePlugin( plugin => plugin.setTileActive && plugin.setTileActive( tile, setActive ) );\n\n\t\t\t}\n\n\t\t\tif ( tile.traversal.wasSetVisible !== setVisible ) {\n\n\t\t\t\trenderer.stats.visible += setVisible ? 1 : - 1;\n\t\t\t\trenderer.invokeOnePlugin( plugin => plugin.setTileVisible && plugin.setTileVisible( tile, setVisible ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\ttile.traversal.wasSetActive = setActive;\n\t\ttile.traversal.wasSetVisible = setVisible;\n\t\ttile.traversal.usedLastFrame = isUsed;\n\n\t\tconst children = tile.children;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tconst c = children[ i ];\n\t\t\ttoggleTiles( c, renderer );\n\n\t\t}\n\n\t}\n\n}\n\nexport function runTraversal( tile, renderer ) {\n\n\tmarkUsedTiles( tile, renderer );\n\tmarkUsedSetLeaves( tile, renderer );\n\tmarkVisibleTiles( tile, renderer );\n\ttoggleTiles( tile, renderer );\n\n}\n","import { LOADED, FAILED } from '../constants.js';\n\nconst viewErrorTarget = {\n\tinView: false,\n\terror: Infinity,\n\tdistanceFromCamera: Infinity,\n};\n\n// flag guiding the behavior of the traversal to load the siblings at the root of the\n// tileset or not. The spec seems to indicate \"true\" when using REPLACE define but\n// Cesium's behavior is \"false\".\n// See CesiumGS/3d-tiles#776\nconst LOAD_ROOT_SIBLINGS = true;\n\nfunction isDownloadFinished( value ) {\n\n\treturn value === LOADED || value === FAILED;\n\n}\n\n// Checks whether this tile was last used on the given frame.\nfunction isUsedThisFrame( tile, frameCount ) {\n\n\treturn isProcessed( tile ) && tile.traversal.lastFrameVisited === frameCount && tile.traversal.used;\n\n}\n\nfunction isProcessed( tile ) {\n\n\treturn Boolean( tile.traversal );\n\n}\n\nfunction areChildrenProcessed( tile ) {\n\n\t// all children are processed at once\n\treturn tile.children.length === 0 || Boolean( tile.children[ 0 ].internal );\n\n}\n\nfunction canUnconditionallyRefine( tile ) {\n\n\treturn tile.internal.hasUnrenderableContent || ( tile.parent && tile.parent.geometricError < tile.geometricError );\n\n}\n\n// Resets the frame information for the given tile\nfunction resetFrameState( tile, renderer ) {\n\n\tif ( tile.traversal.lastFrameVisited !== renderer.frameCount ) {\n\n\t\ttile.traversal.lastFrameVisited = renderer.frameCount;\n\t\ttile.traversal.used = false;\n\t\ttile.traversal.inFrustum = false;\n\t\ttile.traversal.isLeaf = false;\n\t\ttile.traversal.visible = false;\n\t\ttile.traversal.active = false;\n\t\ttile.traversal.error = Infinity;\n\t\ttile.traversal.distanceFromCamera = Infinity;\n\t\ttile.traversal.allChildrenReady = false;\n\n\t\t// update tile frustum and error state\n\t\trenderer.calculateTileViewErrorWithPlugin( tile, viewErrorTarget );\n\t\ttile.traversal.inFrustum = viewErrorTarget.inView;\n\t\ttile.traversal.error = viewErrorTarget.error;\n\t\ttile.traversal.distanceFromCamera = viewErrorTarget.distanceFromCamera;\n\n\t}\n\n}\n\n// Recursively mark tiles used down to the next layer, skipping external tilesets\nfunction recursivelyMarkUsed( tile, renderer, cacheOnly = false ) {\n\n\trenderer.ensureChildrenArePreprocessed( tile );\n\n\tresetFrameState( tile, renderer );\n\tmarkUsed( tile, renderer, cacheOnly );\n\n\t// don't traverse if the children have not been processed, yet but tileset content\n\t// should be considered to be \"replaced\" by the loaded children so await that here.\n\tif ( canUnconditionallyRefine( tile ) && areChildrenProcessed( tile ) ) {\n\n\t\tconst children = tile.children;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\trecursivelyMarkUsed( children[ i ], renderer, cacheOnly );\n\n\t\t}\n\n\t}\n\n}\n\n// Recursively traverses to the next tiles with unloaded renderable content to load them\nfunction recursivelyLoadNextRenderableTiles( tile, renderer ) {\n\n\trenderer.ensureChildrenArePreprocessed( tile );\n\n\t// exit the recursion if the tile hasn't been used this frame\n\tif ( isUsedThisFrame( tile, renderer.frameCount ) ) {\n\n\t\t// queue this tile to download content\n\t\tif ( tile.internal.hasContent ) {\n\n\t\t\trenderer.queueTileForDownload( tile );\n\n\t\t}\n\n\t\tif ( areChildrenProcessed( tile ) ) {\n\n\t\t\t// queue any used child tiles\n\t\t\tconst children = tile.children;\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\trecursivelyLoadNextRenderableTiles( children[ i ], renderer );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n// Mark a tile as being used by current view\nfunction markUsed( tile, renderer, cacheOnly = false ) {\n\n\tif ( tile.traversal.used ) {\n\n\t\treturn;\n\n\t}\n\n\tif ( ! cacheOnly ) {\n\n\t\ttile.traversal.used = true;\n\t\trenderer.stats.used ++;\n\n\t}\n\n\trenderer.markTileUsed( tile );\n\n\tif ( tile.traversal.inFrustum === true ) {\n\n\t\trenderer.stats.inFrustum ++;\n\n\t}\n\n}\n\n// Returns whether the tile can be traversed to the next layer of children by checking the tile metrics\nfunction canTraverse( tile, renderer ) {\n\n\t// If we've met the error requirements then don't load further - if an external tileset is encountered,\n\t// though, then continue to refine.\n\tif ( tile.traversal.error <= renderer.errorTarget && ! canUnconditionallyRefine( tile ) ) {\n\n\t\treturn false;\n\n\t}\n\n\t// Early out if we've reached the maximum allowed depth.\n\tif ( renderer.maxDepth > 0 && tile.internal.depth + 1 >= renderer.maxDepth ) {\n\n\t\treturn false;\n\n\t}\n\n\t// Early out if the children haven't been processed, yet\n\tif ( ! areChildrenProcessed( tile ) ) {\n\n\t\treturn false;\n\n\t}\n\n\treturn true;\n\n}\n\n// Determine which tiles are used by the renderer given the current camera configuration\nfunction markUsedTiles( tile, renderer ) {\n\n\t// determine frustum set is run first so we can ensure the preprocessing of all the necessary\n\t// child tiles has happened here.\n\trenderer.ensureChildrenArePreprocessed( tile );\n\n\tresetFrameState( tile, renderer );\n\n\tif ( ! tile.traversal.inFrustum ) {\n\n\t\treturn;\n\n\t}\n\n\tif ( ! canTraverse( tile, renderer ) ) {\n\n\t\tmarkUsed( tile, renderer );\n\t\treturn;\n\n\t}\n\n\t// Traverse children and see if any children are in view.\n\tlet anyChildrenUsed = false;\n\tlet anyChildrenInFrustum = false;\n\tconst children = tile.children;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\tconst c = children[ i ];\n\t\tmarkUsedTiles( c, renderer );\n\t\tanyChildrenUsed = anyChildrenUsed || isUsedThisFrame( c, renderer.frameCount );\n\t\tanyChildrenInFrustum = anyChildrenInFrustum || c.traversal.inFrustum;\n\n\t}\n\n\t// If none of the children are visible in the frustum then there should be no reason to display this tile. We still mark\n\t// this tile and all children as \"used\" only in the cache (but not loaded) so they are not disposed, causing an oscillation\n\t// / flicker in the content.\n\tif ( tile.refine === 'REPLACE' && ! anyChildrenInFrustum && children.length !== 0 ) {\n\n\t\ttile.traversal.inFrustum = false;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\trecursivelyMarkUsed( children[ i ], renderer, true );\n\n\t\t}\n\n\t\treturn;\n\n\t}\n\n\t// wait until after the above condition to mark the traversed tile as used or not\n\tmarkUsed( tile, renderer );\n\n\t// If this is a tile that needs children loaded to refine then recursively load child\n\t// tiles until error is met\n\tif ( tile.refine === 'REPLACE' && ( anyChildrenUsed && tile.internal.depth !== 0 || LOAD_ROOT_SIBLINGS ) ) {\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\trecursivelyMarkUsed( children[ i ], renderer );\n\n\t\t}\n\n\t}\n\n}\n\n// Traverse and mark the tiles that are at the leaf nodes of the \"used\" tree.\nfunction markUsedSetLeaves( tile, renderer ) {\n\n\tconst frameCount = renderer.frameCount;\n\tif ( ! isUsedThisFrame( tile, frameCount ) ) {\n\n\t\treturn;\n\n\t}\n\n\t// This tile is a leaf if none of the children had been used.\n\tconst children = tile.children;\n\tlet anyChildrenUsed = false;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\tconst c = children[ i ];\n\t\tanyChildrenUsed = anyChildrenUsed || isUsedThisFrame( c, frameCount );\n\n\t}\n\n\tif ( ! anyChildrenUsed ) {\n\n\t\ttile.traversal.isLeaf = true;\n\n\t} else {\n\n\t\tlet allChildrenReady = true;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tconst c = children[ i ];\n\t\t\tmarkUsedSetLeaves( c, renderer );\n\n\t\t\tif ( isUsedThisFrame( c, frameCount ) ) {\n\n\t\t\t\t// Compute whether this child is _allowed_ to display by checking the geometric error relative to the parent tile to avoid holes.\n\t\t\t\t// If the child's geometric error is less than or equal to the parent's (or it has unrenderable content), we should NOT display the child to avoid holes.\n\t\t\t\t// Only display the child if its geometric error is greater than the parent's and it has renderable content.\n\t\t\t\t// Note that this behavior is undocumented in the 3d tiles specification and tilesets designed to take advantage of it may not work as expected\n\t\t\t\t// in other rendering systems.\n\t\t\t\t// See issue NASA-AMMOS/3DTilesRendererJS#1304\n\t\t\t\tconst childCanDisplay = ! canUnconditionallyRefine( c );\n\n\t\t\t\t// Consider a child to be ready to be displayed if\n\t\t\t\t// - the children's children have been loaded\n\t\t\t\t// - the tile content has loaded\n\t\t\t\t// - the tile is completely empty - ie has no children and no content\n\t\t\t\t// - the child tileset has tried to load but failed\n\t\t\t\tlet isChildReady =\n\t\t\t\t\t! c.internal.hasContent ||\n\t\t\t\t\t( c.internal.hasRenderableContent && isDownloadFinished( c.internal.loadingState ) ) ||\n\t\t\t\t\t( c.internal.hasUnrenderableContent && c.internal.loadingState === FAILED );\n\n\t\t\t\t// Consider this child ready if it can be displayed and is ready for display or all of it's children ready to be displayed\n\t\t\t\tisChildReady = ( childCanDisplay && isChildReady ) || c.traversal.allChildrenReady;\n\n\t\t\t\tallChildrenReady = allChildrenReady && isChildReady;\n\n\t\t\t}\n\n\t\t}\n\n\t\ttile.traversal.allChildrenReady = allChildrenReady;\n\n\t}\n\n}\n\n// TODO: revisit implementation\n// Skip past tiles we consider unrenderable because they are outside the error threshold.\nfunction markVisibleTiles( tile, renderer ) {\n\n\tconst stats = renderer.stats;\n\tif ( ! isUsedThisFrame( tile, renderer.frameCount ) ) {\n\n\t\treturn;\n\n\t}\n\n\t// Request the tile contents or mark it as visible if we've found a leaf.\n\tif ( tile.traversal.isLeaf ) {\n\n\t\tif ( tile.internal.loadingState === LOADED ) {\n\n\t\t\tif ( tile.traversal.inFrustum ) {\n\n\t\t\t\ttile.traversal.visible = true;\n\t\t\t\tstats.visible ++;\n\n\t\t\t}\n\n\t\t\ttile.traversal.active = true;\n\t\t\tstats.active ++;\n\n\t\t} else if ( tile.internal.hasContent ) {\n\n\t\t\trenderer.queueTileForDownload( tile );\n\n\t\t}\n\n\t\treturn;\n\n\t}\n\n\tconst children = tile.children;\n\tconst hasContent = tile.internal.hasContent;\n\tconst loadedContent = isDownloadFinished( tile.internal.loadingState ) && hasContent;\n\tconst errorRequirement = ( renderer.errorTarget + 1 ) * renderer.errorThreshold;\n\tconst meetsSSE = tile.traversal.error <= errorRequirement;\n\tconst isAdditiveRefine = tile.refine === 'ADD';\n\n\t// TODO: the \"meetsSSE\" field can be removed when the \"errorThreshold\" field has been removed\n\n\t// Don't wait for all children tiles to load if this tileset has empty tiles at the root in order\n\t// to match Cesium's behavior\n\tconst allChildrenReady = tile.traversal.allChildrenReady || ( tile.internal.depth === 0 && ! LOAD_ROOT_SIBLINGS );\n\n\t// If we've met the SSE requirements and we can load content then fire a fetch.\n\tif ( hasContent && ( meetsSSE || isAdditiveRefine ) ) {\n\n\t\trenderer.queueTileForDownload( tile );\n\n\t}\n\n\t// By this time only tiles that meet the screen space error requirements will be traversed. Only mark this\n\t// as visible if it's been loaded and not all children have loaded yet or it's an additive tile, meaning it needs\n\t// to display in addition to the children.\n\n\t// Skip the tile entirely if there's no content to load\n\tif ( meetsSSE && loadedContent && ! allChildrenReady || loadedContent && isAdditiveRefine ) {\n\n\t\tif ( tile.traversal.inFrustum ) {\n\n\t\t\ttile.traversal.visible = true;\n\t\t\tstats.visible ++;\n\n\t\t}\n\n\t\ttile.traversal.active = true;\n\t\tstats.active ++;\n\n\t}\n\n\t// If we're additive then don't stop the traversal here because it doesn't matter whether the children load in\n\t// at the same rate.\n\tif ( ! isAdditiveRefine && meetsSSE && ! allChildrenReady ) {\n\n\t\t// load the child content if we've found that we've been loaded so we can move down to the next tile\n\t\t// layer when the data has loaded.\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tconst c = children[ i ];\n\t\t\tif ( isUsedThisFrame( c, renderer.frameCount ) ) {\n\n\t\t\t\trecursivelyLoadNextRenderableTiles( c, renderer );\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tmarkVisibleTiles( children[ i ], renderer );\n\n\t\t}\n\n\t}\n\n}\n\n// Final traverse to toggle tile visibility.\nfunction toggleTiles( tile, renderer ) {\n\n\tconst isUsed = isUsedThisFrame( tile, renderer.frameCount );\n\tif ( isUsed || isProcessed( tile ) && tile.traversal.usedLastFrame ) {\n\n\t\tlet setActive = false;\n\t\tlet setVisible = false;\n\t\tif ( isUsed ) {\n\n\t\t\t// enable visibility if active due to shadows\n\t\t\tsetActive = tile.traversal.active;\n\t\t\tif ( renderer.displayActiveTiles ) {\n\n\t\t\t\tsetVisible = tile.traversal.active || tile.traversal.visible;\n\n\t\t\t} else {\n\n\t\t\t\tsetVisible = tile.traversal.visible;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// if the tile was used last frame but not this one then there's potential for the tile\n\t\t\t// to not have been visited during the traversal, meaning it hasn't been reset and has\n\t\t\t// stale values. This ensures the values are not stale.\n\t\t\tresetFrameState( tile, renderer );\n\n\t\t}\n\n\t\t// If the active or visible state changed then call the functions.\n\t\tif ( tile.internal.hasRenderableContent && tile.internal.loadingState === LOADED ) {\n\n\t\t\tif ( tile.traversal.wasSetActive !== setActive ) {\n\n\t\t\t\trenderer.invokeOnePlugin( plugin => plugin.setTileActive && plugin.setTileActive( tile, setActive ) );\n\n\t\t\t}\n\n\t\t\tif ( tile.traversal.wasSetVisible !== setVisible ) {\n\n\t\t\t\trenderer.invokeOnePlugin( plugin => plugin.setTileVisible && plugin.setTileVisible( tile, setVisible ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\ttile.traversal.wasSetActive = setActive;\n\t\ttile.traversal.wasSetVisible = setVisible;\n\t\ttile.traversal.usedLastFrame = isUsed;\n\n\t\tconst children = tile.children;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tconst c = children[ i ];\n\t\t\ttoggleTiles( c, renderer );\n\n\t\t}\n\n\t}\n\n}\n\nexport function runTraversal( tile, renderer ) {\n\n\tmarkUsedTiles( tile, renderer );\n\tmarkUsedSetLeaves( tile, renderer );\n\tmarkVisibleTiles( tile, renderer );\n\ttoggleTiles( tile, renderer );\n\n}\n\n","// function that rate limits the amount of time a function can be called to once\n// per frame, initially queuing a new call for the next frame.\nexport function throttle( callback ) {\n\n\tlet handle = null;\n\treturn () => {\n\n\t\tif ( handle === null ) {\n\n\t\t\thandle = requestAnimationFrame( () => {\n\n\t\t\t\thandle = null;\n\t\t\t\tcallback();\n\n\t\t\t} );\n\n\t\t}\n\n\t};\n\n}\n","// Helper function for traversing a tileset. If `beforeCb` returns `true` then the\n// traversal will end early.\nexport function traverseSet( tile, beforeCb = null, afterCb = null ) {\n\n\tconst stack = [];\n\n\t// A stack-based, depth-first traversal, storing\n\t// triplets (tile, parent, depth) in the stack array.\n\n\tstack.push( tile );\n\tstack.push( null );\n\tstack.push( 0 );\n\n\twhile ( stack.length > 0 ) {\n\n\t\tconst depth = stack.pop();\n\t\tconst parent = stack.pop();\n\t\tconst tile = stack.pop();\n\n\t\tif ( beforeCb && beforeCb( tile, parent, depth ) ) {\n\n\t\t\tif ( afterCb ) {\n\n\t\t\t\tafterCb( tile, parent, depth );\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst children = tile.children;\n\n\t\t// Children might be undefined if the tile has not been preprocessed yet\n\t\tif ( children ) {\n\n\t\t\tfor ( let i = children.length - 1; i >= 0; i -- ) {\n\n\t\t\t\tstack.push( children[ i ] );\n\t\t\t\tstack.push( tile );\n\t\t\t\tstack.push( depth + 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( afterCb ) {\n\n\t\t\tafterCb( tile, parent, depth );\n\n\t\t}\n\n\t}\n\n}\n\n// Traverses the ancestry of the tile up to the root tile.\nexport function traverseAncestors( tile, callback = null ) {\n\n\tlet current = tile;\n\n\twhile ( current ) {\n\n\t\tconst depth = current.internal.depth;\n\t\tconst parent = current.parent;\n\n\t\tif ( callback ) {\n\n\t\t\tcallback( current, parent, depth );\n\n\t\t}\n\n\t\tcurrent = parent;\n\n\t}\n\n\n}\n","import { getUrlExtension } from '../utilities/urlExtension.js';\nimport { LRUCache } from '../utilities/LRUCache.js';\nimport { PriorityQueue } from '../utilities/PriorityQueue.js';\nimport { runTraversal as optimizedRunTraversal } from './optimizedTraverseFunctions.js';\nimport { runTraversal } from './traverseFunctions.js';\nimport { UNLOADED, QUEUED, LOADING, PARSING, LOADED, FAILED } from '../constants.js';\nimport { throttle } from '../utilities/throttle.js';\nimport { traverseSet } from '../utilities/TraversalUtils.js';\n\nconst PLUGIN_REGISTERED = Symbol( 'PLUGIN_REGISTERED' );\nconst regionErrorTarget = {\n\tinView: true,\n\terror: 0,\n\tdistance: Infinity,\n};\n\n// priority queue sort function that takes two tiles to compare. Returning 1 means\n// \"tile a\" is loaded first.\nconst defaultPriorityCallback = ( a, b ) => {\n\n\tconst aPriority = a.priority || 0;\n\tconst bPriority = b.priority || 0;\n\n\tif ( aPriority !== bPriority ) {\n\n\t\t// lower priority value sorts first\n\t\treturn aPriority > bPriority ? 1 : - 1;\n\n\t} else if ( ! a.traversal || ! b.traversal ) {\n\n\t\treturn 0;\n\n\t} else if ( a.traversal.used !== b.traversal.used ) {\n\n\t\t// load tiles that have been used\n\t\treturn a.traversal.used ? 1 : - 1;\n\n\t} else if ( a.traversal.error !== b.traversal.error ) {\n\n\t\t// load the tile with the higher error\n\t\treturn a.traversal.error > b.traversal.error ? 1 : - 1;\n\n\t} else if ( a.traversal.distanceFromCamera !== b.traversal.distanceFromCamera ) {\n\n\t\t// and finally visible tiles which have equal error (ex: if geometricError === 0)\n\t\t// should prioritize based on distance.\n\t\treturn a.traversal.distanceFromCamera > b.traversal.distanceFromCamera ? - 1 : 1;\n\n\t} else if ( a.internal.depthFromRenderedParent !== b.internal.depthFromRenderedParent ) {\n\n\t\treturn a.internal.depthFromRenderedParent > b.internal.depthFromRenderedParent ? - 1 : 1;\n\n\t}\n\n\treturn 0;\n\n};\n\n// Optimized priority callback - prioritizes distance over error for better user experience\nconst optimizedPriorityCallback = ( a, b ) => {\n\n\tconst aPriority = a.priority || 0;\n\tconst bPriority = b.priority || 0;\n\n\tif ( aPriority !== bPriority ) {\n\n\t\t// lower priority value sorts first\n\t\treturn aPriority > bPriority ? 1 : - 1;\n\n\t} else if ( ! a.traversal || ! b.traversal ) {\n\n\t\treturn 0;\n\n\t} else if ( a.traversal.used !== b.traversal.used ) {\n\n\t\t// load tiles that have been used\n\t\treturn a.traversal.used ? 1 : - 1;\n\n\t} else if ( a.traversal.inFrustum !== b.traversal.inFrustum ) {\n\n\t\t// load tiles that have are in the frustum\n\t\treturn a.traversal.inFrustum ? 1 : - 1;\n\n\t} else if ( a.internal.hasUnrenderableContent !== b.internal.hasUnrenderableContent ) {\n\n\t\t// load internal tile sets first\n\t\treturn a.internal.hasUnrenderableContent ? 1 : - 1;\n\n\t} else if ( a.traversal.distanceFromCamera !== b.traversal.distanceFromCamera ) {\n\n\t\t// load closer tiles first\n\t\treturn a.traversal.distanceFromCamera > b.traversal.distanceFromCamera ? - 1 : 1;\n\n\t}\n\n\treturn 0;\n\n};\n\n// lru cache unload callback that takes two tiles to compare. Returning 1 means \"tile a\"\n// is unloaded first.\nconst lruPriorityCallback = ( a, b ) => {\n\n\tconst aPriority = a.priority || 0;\n\tconst bPriority = b.priority || 0;\n\n\tif ( aPriority !== bPriority ) {\n\n\t\t// lower priority value sorts first\n\t\treturn aPriority > bPriority ? 1 : - 1;\n\n\t} else if ( ! a.traversal || ! b.traversal ) {\n\n\t\treturn 0;\n\n\t} else if ( a.traversal.lastFrameVisited !== b.traversal.lastFrameVisited ) {\n\n\t\t// dispose of least recent tiles first\n\t\treturn a.traversal.lastFrameVisited > b.traversal.lastFrameVisited ? - 1 : 1;\n\n\t} else if ( a.internal.depthFromRenderedParent !== b.internal.depthFromRenderedParent ) {\n\n\t\t// dispose of deeper tiles first so parents are not disposed before children\n\t\treturn a.internal.depthFromRenderedParent > b.internal.depthFromRenderedParent ? 1 : - 1;\n\n\t} else if ( a.internal.loadingState !== b.internal.loadingState ) {\n\n\t\t// dispose of tiles that are earlier along in the loading process first\n\t\treturn a.internal.loadingState > b.internal.loadingState ? - 1 : 1;\n\n\t} else if ( a.internal.hasUnrenderableContent !== b.internal.hasUnrenderableContent ) {\n\n\t\t// dispose of external tilesets last\n\t\treturn a.internal.hasUnrenderableContent ? - 1 : 1;\n\n\t} else if ( a.traversal.error !== b.traversal.error ) {\n\n\t\t// unload the tile with lower error\n\t\treturn a.traversal.error > b.traversal.error ? - 1 : 1;\n\n\t}\n\n\treturn 0;\n\n};\n\nexport class TilesRendererBase {\n\n\tget root() {\n\n\t\tconst tileset = this.rootTileset;\n\t\treturn tileset ? tileset.root : null;\n\n\t}\n\n\tget rootTileSet() {\n\n\t\tconsole.warn( 'TilesRenderer: \"rootTileSet\" has been deprecated. Use \"rootTileset\" instead.' );\n\t\treturn this.rootTileset;\n\n\t}\n\n\tget loadProgress() {\n\n\t\tconst { stats, isLoading } = this;\n\t\tconst loading = stats.queued + stats.downloading + stats.parsing;\n\t\tconst total = stats.inCacheSinceLoad + ( isLoading ? 1 : 0 );\n\t\treturn total === 0 ? 1.0 : 1.0 - loading / total;\n\n\t}\n\n\tget errorThreshold() {\n\n\t\treturn this._errorThreshold;\n\n\t}\n\n\tset errorThreshold( v ) {\n\n\t\tconsole.warn( 'TilesRenderer: The \"errorThreshold\" option has been deprecated.' );\n\t\tthis._errorThreshold = v;\n\n\t}\n\n\tconstructor( url = null ) {\n\n\t\t// state\n\t\tthis.rootLoadingState = UNLOADED;\n\t\tthis.rootTileset = null;\n\t\tthis.rootURL = url;\n\t\tthis.fetchOptions = {};\n\t\tthis.plugins = [];\n\t\tthis.queuedTiles = [];\n\t\tthis.cachedSinceLoadComplete = new Set();\n\t\tthis.isLoading = false;\n\n\t\tconst lruCache = new LRUCache();\n\t\tlruCache.unloadPriorityCallback = lruPriorityCallback;\n\n\t\tconst downloadQueue = new PriorityQueue();\n\t\tdownloadQueue.maxJobs = 25;\n\t\tdownloadQueue.priorityCallback = defaultPriorityCallback;\n\n\t\tconst parseQueue = new PriorityQueue();\n\t\tparseQueue.maxJobs = 5;\n\t\tparseQueue.priorityCallback = defaultPriorityCallback;\n\n\t\tconst processNodeQueue = new PriorityQueue();\n\t\tprocessNodeQueue.maxJobs = 25;\n\t\tprocessNodeQueue.priorityCallback = ( a, b ) => {\n\n\t\t\tconst aParent = a.parent;\n\t\t\tconst bParent = b.parent;\n\t\t\tif ( aParent === bParent ) {\n\n\t\t\t\treturn 0;\n\n\t\t\t} else if ( ! aParent ) {\n\n\t\t\t\treturn 1;\n\n\t\t\t} else if ( ! bParent ) {\n\n\t\t\t\treturn - 1;\n\n\t\t\t} else {\n\n\t\t\t\t// fall back to the priority used for tile loads and parsing\n\t\t\t\treturn downloadQueue.priorityCallback( aParent, bParent );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.processedTiles = new WeakSet();\n\t\tthis.visibleTiles = new Set();\n\t\tthis.activeTiles = new Set();\n\t\tthis.usedSet = new Set();\n\t\tthis.loadingTiles = new Set();\n\t\tthis.lruCache = lruCache;\n\t\tthis.downloadQueue = downloadQueue;\n\t\tthis.parseQueue = parseQueue;\n\t\tthis.processNodeQueue = processNodeQueue;\n\t\tthis.stats = {\n\t\t\tinCacheSinceLoad: 0,\n\t\t\tinCache: 0,\n\n\t\t\tqueued: 0,\n\t\t\tdownloading: 0,\n\t\t\tparsing: 0,\n\t\t\tloaded: 0,\n\t\t\tfailed: 0,\n\n\t\t\tinFrustum: 0,\n\t\t\tused: 0,\n\t\t\tactive: 0,\n\t\t\tvisible: 0,\n\n\t\t\ttilesProcessed: 0,\n\t\t};\n\t\tthis.frameCount = 0;\n\n\t\t// callbacks\n\t\tthis._dispatchNeedsUpdateEvent = throttle( () => {\n\n\t\t\tthis.dispatchEvent( { type: 'needs-update' } );\n\n\t\t} );\n\n\t\t// options\n\t\tthis.errorTarget = 16.0;\n\t\tthis._errorThreshold = Infinity;\n\t\tthis.displayActiveTiles = false;\n\t\tthis.maxDepth = Infinity;\n\t\tthis.optimizedLoadStrategy = false;\n\t\tthis.loadSiblings = true;\n\t\tthis.maxTilesProcessed = 250;\n\n\t}\n\n\t// Plugins\n\tregisterPlugin( plugin ) {\n\n\t\tif ( plugin[ PLUGIN_REGISTERED ] === true ) {\n\n\t\t\tthrow new Error( 'TilesRendererBase: A plugin can only be registered to a single tileset' );\n\n\t\t}\n\n\t\t// warn if plugin implements deprecated loadRootTileSet method\n\t\tif ( plugin.loadRootTileSet && ! plugin.loadRootTileset ) {\n\n\t\t\tconsole.warn( 'TilesRendererBase: Plugin implements deprecated \"loadRootTileSet\" method. Please rename to \"loadRootTileset\".' );\n\t\t\tplugin.loadRootTileset = plugin.loadRootTileSet;\n\n\t\t}\n\n\t\tif ( plugin.preprocessTileSet && ! plugin.preprocessTileset ) {\n\n\t\t\tconsole.warn( 'TilesRendererBase: Plugin implements deprecated \"preprocessTileSet\" method. Please rename to \"preprocessTileset\".' );\n\t\t\tplugin.preprocessTileset = plugin.preprocessTileSet;\n\n\t\t}\n\n\t\t// insert the plugin based on the priority registered on the plugin\n\t\tconst plugins = this.plugins;\n\t\tconst priority = plugin.priority || 0;\n\t\tlet insertionPoint = plugins.length;\n\t\tfor ( let i = 0; i < plugins.length; i ++ ) {\n\n\t\t\tconst otherPriority = plugins[ i ].priority || 0;\n\t\t\tif ( otherPriority > priority ) {\n\n\t\t\t\tinsertionPoint = i;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tplugins.splice( insertionPoint, 0, plugin );\n\t\tplugin[ PLUGIN_REGISTERED ] = true;\n\t\tif ( plugin.init ) {\n\n\t\t\tplugin.init( this );\n\n\t\t}\n\n\t}\n\n\tunregisterPlugin( plugin ) {\n\n\t\tconst plugins = this.plugins;\n\t\tif ( typeof plugin === 'string' ) {\n\n\t\t\tplugin = this.getPluginByName( plugin );\n\n\t\t}\n\n\t\tif ( plugins.includes( plugin ) ) {\n\n\t\t\tconst index = plugins.indexOf( plugin );\n\t\t\tplugins.splice( index, 1 );\n\t\t\tif ( plugin.dispose ) {\n\n\t\t\t\tplugin.dispose();\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tgetPluginByName( name ) {\n\n\t\treturn this.plugins.find( p => p.name === name ) || null;\n\n\t}\n\n\tinvokeOnePlugin( func ) {\n\n\t\tconst plugins = [ ...this.plugins, this ];\n\t\tfor ( let i = 0; i < plugins.length; i ++ ) {\n\n\t\t\tconst result = func( plugins[ i ] );\n\t\t\tif ( result ) {\n\n\t\t\t\treturn result;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tinvokeAllPlugins( func ) {\n\n\t\tconst plugins = [ ...this.plugins, this ];\n\t\tconst pending = [];\n\t\tfor ( let i = 0; i < plugins.length; i ++ ) {\n\n\t\t\tconst result = func( plugins[ i ] );\n\t\t\tif ( result ) {\n\n\t\t\t\tpending.push( result );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn pending.length === 0 ? null : Promise.all( pending );\n\n\t}\n\n\t// Public API\n\ttraverse( beforecb, aftercb, ensureFullyProcessed = true ) {\n\n\t\tif ( ! this.root ) return;\n\n\t\ttraverseSet( this.root, ( tile, ...args ) => {\n\n\t\t\tif ( ensureFullyProcessed ) {\n\n\t\t\t\tthis.ensureChildrenArePreprocessed( tile, true );\n\n\t\t\t}\n\n\t\t\treturn beforecb ? beforecb( tile, ...args ) : false;\n\n\t\t}, aftercb );\n\n\t}\n\n\tgetAttributions( target = [] ) {\n\n\t\tthis.invokeAllPlugins( plugin => plugin !== this && plugin.getAttributions && plugin.getAttributions( target ) );\n\t\treturn target;\n\n\t}\n\n\tupdate() {\n\n\t\t// load root\n\t\tconst { lruCache, usedSet, stats, root, downloadQueue, parseQueue, processNodeQueue, optimizedLoadStrategy } = this;\n\t\tif ( this.rootLoadingState === UNLOADED ) {\n\n\t\t\tthis.rootLoadingState = LOADING;\n\t\t\tthis.invokeOnePlugin( plugin => plugin.loadRootTileset && plugin.loadRootTileset() )\n\t\t\t\t.then( root => {\n\n\t\t\t\t\tlet processedUrl = this.rootURL;\n\t\t\t\t\tif ( processedUrl !== null ) {\n\n\t\t\t\t\t\tthis.invokeAllPlugins( plugin => processedUrl = plugin.preprocessURL ? plugin.preprocessURL( processedUrl, null ) : processedUrl );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.rootLoadingState = LOADED;\n\t\t\t\t\tthis.rootTileset = root;\n\t\t\t\t\tthis.dispatchEvent( { type: 'needs-update' } );\n\t\t\t\t\tthis.dispatchEvent( { type: 'load-content' } );\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'load-tileset',\n\t\t\t\t\t\ttileset: root,\n\t\t\t\t\t\turl: processedUrl,\n\t\t\t\t\t} );\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'load-root-tileset',\n\t\t\t\t\t\ttileset: root,\n\t\t\t\t\t\turl: processedUrl,\n\t\t\t\t\t} );\n\n\t\t\t\t} )\n\t\t\t\t.catch( error => {\n\n\t\t\t\t\tthis.rootLoadingState = FAILED;\n\t\t\t\t\tconsole.error( error );\n\n\t\t\t\t\tthis.rootTileset = null;\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'load-error',\n\t\t\t\t\t\ttile: null,\n\t\t\t\t\t\terror,\n\t\t\t\t\t\turl: this.rootURL,\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t}\n\n\t\tif ( ! root ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// check if the plugins that can block the tile updates require it\n\t\tlet needsUpdate = null;\n\t\tthis.invokeAllPlugins( plugin => {\n\n\t\t\tif ( plugin.doTilesNeedUpdate ) {\n\n\t\t\t\tconst res = plugin.doTilesNeedUpdate();\n\t\t\t\tif ( needsUpdate === null ) {\n\n\t\t\t\t\tneedsUpdate = res;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tneedsUpdate = Boolean( needsUpdate || res );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( needsUpdate === false ) {\n\n\t\t\tthis.dispatchEvent( { type: 'update-before' } );\n\t\t\tthis.dispatchEvent( { type: 'update-after' } );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// follow through with the update\n\t\tthis.dispatchEvent( { type: 'update-before' } );\n\n\t\t//\n\n\t\tstats.inFrustum = 0;\n\t\tstats.used = 0;\n\t\tstats.active = 0;\n\t\tstats.visible = 0;\n\t\tstats.tilesProcessed = 0;\n\t\tthis.frameCount ++;\n\n\t\tusedSet.forEach( tile => lruCache.markUnused( tile ) );\n\t\tusedSet.clear();\n\n\t\t// assign the correct callbacks\n\t\tconst priorityCallback = optimizedLoadStrategy ? optimizedPriorityCallback : defaultPriorityCallback;\n\t\tdownloadQueue.priorityCallback = priorityCallback;\n\t\tparseQueue.priorityCallback = priorityCallback;\n\n\t\t// prepare for traversal\n\t\tthis.prepareForTraversal();\n\n\t\t// run traversal\n\t\tif ( optimizedLoadStrategy ) {\n\n\t\t\toptimizedRunTraversal( root, this );\n\n\t\t} else {\n\n\t\t\trunTraversal( root, this );\n\n\t\t}\n\n\t\t// remove any tiles that are loading but no longer used\n\t\tthis.removeUnusedPendingTiles();\n\n\t\t// TODO: This will only sort for one tileset. We may want to store this queue on the\n\t\t// LRUCache so multiple tilesets can use it at once\n\t\t// start the downloads of the tiles as needed\n\t\tconst queuedTiles = this.queuedTiles;\n\t\tqueuedTiles.sort( lruCache.unloadPriorityCallback );\n\t\tfor ( let i = 0, l = queuedTiles.length; i < l && ! lruCache.isFull(); i ++ ) {\n\n\t\t\tthis.requestTileContents( queuedTiles[ i ] );\n\n\t\t}\n\n\t\tqueuedTiles.length = 0;\n\n\t\t// start the downloads\n\t\tlruCache.scheduleUnload();\n\n\t\t// if all tasks have finished and we've been marked as actively loading then fire the completion event\n\t\tconst runningTasks = downloadQueue.running || parseQueue.running || processNodeQueue.running;\n\t\tif ( runningTasks === false && this.isLoading === true ) {\n\n\t\t\tthis.cachedSinceLoadComplete.clear();\n\t\t\tstats.inCacheSinceLoad = 0;\n\n\t\t\tthis.dispatchEvent( { type: 'tiles-load-end' } );\n\t\t\tthis.isLoading = false;\n\n\t\t}\n\n\t\tthis.dispatchEvent( { type: 'update-after' } );\n\n\t}\n\n\tresetFailedTiles() {\n\n\t\t// reset the root tile if it's finished but never loaded\n\t\tif ( this.rootLoadingState === FAILED ) {\n\n\t\t\tthis.rootLoadingState = UNLOADED;\n\n\t\t}\n\n\t\tconst stats = this.stats;\n\t\tif ( stats.failed === 0 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.traverse( tile => {\n\n\t\t\tif ( tile.internal.loadingState === FAILED ) {\n\n\t\t\t\ttile.internal.loadingState = UNLOADED;\n\n\t\t\t}\n\n\t\t}, null, false );\n\n\t\tstats.failed = 0;\n\n\t}\n\n\tcalculateTileViewErrorWithPlugin( tile, target ) {\n\n\t\t// calculate camera view error\n\t\tthis.calculateTileViewError( tile, target );\n\n\t\t// TODO: this logic is extremely complex. It may be more simple to have the plugin\n\t\t// return a \"should mask\" field that indicates its \"false\" values should be respected\n\t\t// rather than the function returning a \"no-op\" boolean.\n\t\t// check the plugin visibility - each plugin will mask between themselves\n\t\tlet inRegion = null;\n\t\tlet inRegionError = 0;\n\t\tlet inRegionDistance = Infinity;\n\t\tthis.invokeAllPlugins( plugin => {\n\n\t\t\tif ( plugin !== this && plugin.calculateTileViewError ) {\n\n\t\t\t\t// if function returns false it means \"no operation\"\n\t\t\t\tregionErrorTarget.inView = true;\n\t\t\t\tregionErrorTarget.error = 0;\n\t\t\t\tregionErrorTarget.distance = Infinity;\n\t\t\t\tif ( plugin.calculateTileViewError( tile, regionErrorTarget ) ) {\n\n\t\t\t\t\tif ( inRegion === null ) {\n\n\t\t\t\t\t\tinRegion = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Plugins can set \"inView\" to false in order to mask the visible tiles\n\t\t\t\t\tinRegion = inRegion && regionErrorTarget.inView;\n\t\t\t\t\tif ( regionErrorTarget.inView ) {\n\n\t\t\t\t\t\tinRegionDistance = Math.min( inRegionDistance, regionErrorTarget.distance );\n\t\t\t\t\t\tinRegionError = Math.max( inRegionError, regionErrorTarget.error );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( target.inView && inRegion !== false ) {\n\n\t\t\t// if the tile is in camera view and we haven't encountered a region (null) or\n\t\t\t// the region is in view (true). regionInView === false means the tile is masked out.\n\t\t\ttarget.error = Math.max( target.error, inRegionError );\n\t\t\ttarget.distanceFromCamera = Math.min( target.distanceFromCamera, inRegionDistance );\n\n\t\t} else if ( inRegion ) {\n\n\t\t\t// if the tile is in a region then display it\n\t\t\ttarget.inView = true;\n\t\t\ttarget.error = inRegionError;\n\t\t\ttarget.distanceFromCamera = inRegionDistance;\n\n\t\t} else {\n\n\t\t\t// otherwise write variables for load priority\n\t\t\ttarget.inView = false;\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\t// dispose of all the plugins\n\t\tconst plugins = [ ...this.plugins ];\n\t\tplugins.forEach( plugin => {\n\n\t\t\tthis.unregisterPlugin( plugin );\n\n\t\t} );\n\n\t\tconst lruCache = this.lruCache;\n\n\t\t// Make sure we've collected all children before disposing of the internal tilesets to avoid\n\t\t// dangling children that we inadvertantly skip when deleting the nested tileset.\n\t\tconst toRemove = [];\n\t\tthis.traverse( t => {\n\n\t\t\ttoRemove.push( t );\n\t\t\treturn false;\n\n\t\t}, null, false );\n\t\tfor ( let i = 0, l = toRemove.length; i < l; i ++ ) {\n\n\t\t\tlruCache.remove( toRemove[ i ] );\n\n\t\t}\n\n\t\tthis.stats = {\n\t\t\tqueued: 0,\n\t\t\tparsing: 0,\n\t\t\tdownloading: 0,\n\t\t\tfailed: 0,\n\t\t\tinFrustum: 0,\n\t\t\ttraversed: 0,\n\t\t\tused: 0,\n\t\t\tactive: 0,\n\t\t\tvisible: 0,\n\t\t};\n\t\tthis.frameCount = 0;\n\t\tthis.loadingTiles.clear();\n\n\t}\n\n\t// Overrideable\n\tcalculateBytesUsed( scene, tile ) {\n\n\t\treturn 0;\n\n\t}\n\n\tdispatchEvent( e ) {}\n\n\taddEventListener( name, callback ) {}\n\n\tremoveEventListener( name, callback ) {}\n\n\tparseTile( buffer, tile, extension ) {\n\n\t\treturn null;\n\n\t}\n\n\tprepareForTraversal() {}\n\n\tdisposeTile( tile ) {\n\n\t\t// TODO: are these necessary? Are we disposing tiles when they are currently visible?\n\t\tif ( tile.traversal.visible ) {\n\n\t\t\tthis.invokeOnePlugin( plugin => plugin.setTileVisible && plugin.setTileVisible( tile, false ) );\n\t\t\ttile.traversal.visible = false;\n\n\t\t}\n\n\t\tif ( tile.traversal.active ) {\n\n\t\t\tthis.invokeOnePlugin( plugin => plugin.setTileActive && plugin.setTileActive( tile, false ) );\n\t\t\ttile.traversal.active = false;\n\n\t\t}\n\n\t\tconst { scene } = tile.engineData;\n\t\tif ( scene ) {\n\n\t\t\tthis.dispatchEvent( {\n\t\t\t\ttype: 'dispose-model',\n\t\t\t\tscene,\n\t\t\t\ttile,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\tpreprocessNode( tile, tilesetDir, parentTile = null ) {\n\n\t\tthis.processedTiles.add( tile );\n\t\tthis.stats.tilesProcessed ++;\n\n\t\tif ( tile.content ) {\n\n\t\t\t// Fix old file formats\n\t\t\tif ( ! ( 'uri' in tile.content ) && 'url' in tile.content ) {\n\n\t\t\t\ttile.content.uri = tile.content.url;\n\t\t\t\tdelete tile.content.url;\n\n\t\t\t}\n\n\t\t\t// NOTE: fix for some cases where tilesets provide the bounding volume\n\t\t\t// but volumes are not present.\n\t\t\tif (\n\t\t\t\ttile.content.boundingVolume &&\n\t\t\t\t! (\n\t\t\t\t\t'box' in tile.content.boundingVolume ||\n\t\t\t\t\t'sphere' in tile.content.boundingVolume ||\n\t\t\t\t\t'region' in tile.content.boundingVolume\n\t\t\t\t)\n\t\t\t) {\n\n\t\t\t\tdelete tile.content.boundingVolume;\n\n\t\t\t}\n\n\t\t}\n\n\t\ttile.parent = parentTile;\n\t\ttile.children = tile.children || [];\n\n\t\t// Initialize internal data\n\t\ttile.internal = {\n\t\t\thasContent: false,\n\t\t\thasRenderableContent: false,\n\t\t\thasUnrenderableContent: false,\n\t\t\tloadingState: UNLOADED,\n\t\t\tbasePath: tilesetDir,\n\t\t\tdepth: - 1,\n\t\t\tdepthFromRenderedParent: - 1,\n\t\t};\n\n\t\tif ( tile.content?.uri ) {\n\n\t\t\t// \"content\" should only indicate loadable meshes, not external tilesets\n\t\t\tconst extension = getUrlExtension( tile.content.uri );\n\t\t\tconst hasUnrenderableContent = Boolean( extension && /json$/.test( extension ) );\n\t\t\ttile.internal.hasContent = true;\n\t\t\ttile.internal.hasUnrenderableContent = hasUnrenderableContent;\n\t\t\ttile.internal.hasRenderableContent = ! hasUnrenderableContent;\n\n\t\t} else {\n\n\t\t\ttile.internal.hasContent = false;\n\t\t\ttile.internal.hasUnrenderableContent = false;\n\t\t\ttile.internal.hasRenderableContent = false;\n\n\t\t}\n\n\t\t// Increment parent's children processed counter\n\t\tif ( parentTile ) {\n\n\t\t\ttile.internal.depth = parentTile.internal.depth + 1;\n\t\t\ttile.internal.depthFromRenderedParent = parentTile.internal.depthFromRenderedParent + ( tile.internal.hasRenderableContent ? 1 : 0 );\n\n\t\t} else {\n\n\t\t\ttile.internal.depth = 0;\n\t\t\ttile.internal.depthFromRenderedParent = tile.internal.hasRenderableContent ? 1 : 0;\n\n\t\t}\n\n\t\t// Initialize traversal data\n\t\ttile.traversal = {\n\t\t\tdistanceFromCamera: Infinity,\n\t\t\terror: Infinity,\n\t\t\tinFrustum: false,\n\t\t\tisLeaf: false,\n\t\t\tused: false,\n\t\t\tusedLastFrame: false,\n\t\t\tvisible: false,\n\t\t\twasSetVisible: false,\n\t\t\tactive: false,\n\t\t\twasSetActive: false,\n\t\t\tallChildrenReady: false,\n\t\t\tkicked: false,\n\t\t\tallUsedChildrenProcessed: false,\n\t\t\tlastFrameVisited: - 1,\n\t\t};\n\n\t\tif ( parentTile === null ) {\n\n\t\t\ttile.refine = tile.refine || 'REPLACE';\n\n\t\t} else {\n\n\t\t\ttile.refine = tile.refine || parentTile.refine;\n\n\t\t}\n\n\t\t// Initialize engineData data structure with engine-agnostic fields\n\t\ttile.engineData = {\n\t\t\tscene: null,\n\t\t\tmetadata: null,\n\t\t\tboundingVolume: null,\n\t\t};\n\n\t\t// Backwards compatibility: cached is an alias for engineData\n\t\tObject.defineProperty( tile, 'cached', {\n\t\t\tget() {\n\n\t\t\t\tconsole.warn( 'TilesRenderer: \"tile.cached\" field has been renamed to \"tile.engineData\".' );\n\t\t\t\treturn this.engineData;\n\n\t\t\t},\n\t\t\tenumerable: false,\n\t\t\tconfigurable: true,\n\t\t} );\n\n\t\tthis.invokeAllPlugins( plugin => {\n\n\t\t\tplugin !== this && plugin.preprocessNode && plugin.preprocessNode( tile, tilesetDir, parentTile );\n\n\t\t} );\n\n\t}\n\n\tsetTileActive( tile, active ) {\n\n\t\tactive ? this.activeTiles.add( tile ) : this.activeTiles.delete( tile );\n\n\t}\n\n\tsetTileVisible( tile, visible ) {\n\n\t\tvisible ? this.visibleTiles.add( tile ) : this.visibleTiles.delete( tile );\n\n\t\tthis.dispatchEvent( {\n\t\t\ttype: 'tile-visibility-change',\n\t\t\tscene: tile.engineData.scene,\n\t\t\ttile,\n\t\t\tvisible,\n\t\t} );\n\n\n\t}\n\n\tcalculateTileViewError( tile, target ) {\n\n\t\t// retrieve whether the tile is visible, screen space error, and distance to camera\n\t\t// set \"inView\", \"error\", \"distance\"\n\n\t}\n\n\tremoveUnusedPendingTiles() {\n\n\t\tconst { lruCache, loadingTiles } = this;\n\n\t\t// cannot delete items while iterating over a set\n\t\tconst toRemove = [];\n\t\tfor ( const tile of loadingTiles ) {\n\n\t\t\t// we only remove tiles that are QUEUED to avoid cancelling tiles that may already be nearly downloaded\n\t\t\t// as the camera moves\n\t\t\tif ( ! lruCache.isUsed( tile ) && tile.internal.loadingState === QUEUED ) {\n\n\t\t\t\ttoRemove.push( tile );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < toRemove.length; i ++ ) {\n\n\t\t\tlruCache.remove( toRemove[ i ] );\n\n\t\t}\n\n\t}\n\n\t// Private Functions\n\tqueueTileForDownload( tile ) {\n\n\t\tif ( tile.internal.loadingState !== UNLOADED || this.lruCache.isFull() ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.queuedTiles.push( tile );\n\n\t}\n\n\tmarkTileUsed( tile ) {\n\n\t\t// save the tile in a separate \"used set\" so we can mark it as unused\n\t\t// before the next tileset traversal\n\t\tthis.usedSet.add( tile );\n\t\tthis.lruCache.markUsed( tile );\n\n\t}\n\n\tfetchData( url, options ) {\n\n\t\treturn fetch( url, options );\n\n\t}\n\n\tensureChildrenArePreprocessed( tile, forceImmediate = this.stats.tilesProcessed < this.maxTilesProcessed ) {\n\n\t\tconst children = tile.children;\n\t\tif ( children.length === 0 || children[ 0 ].internal ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst processChildren = children => {\n\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tthis.preprocessNode( children[ i ], tile.internal.basePath, tile );\n\n\n\t\t\t}\n\n\t\t};\n\n\t\t// process children immediately up to a max number of tiles during traversal\n\t\tif ( forceImmediate ) {\n\n\t\t\tthis.processNodeQueue.remove( tile );\n\t\t\tprocessChildren( children );\n\n\t\t} else {\n\n\n\t\t\tif ( ! this.processNodeQueue.has( tile ) ) {\n\n\t\t\t\tthis.processNodeQueue.add( tile, tile => {\n\n\t\t\t\t\tprocessChildren( tile.children );\n\t\t\t\t\tthis._dispatchNeedsUpdateEvent();\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\n\t}\n\n\t// returns the total bytes used for by the given tile as reported by all plugins\n\tgetBytesUsed( tile ) {\n\n\t\tlet bytes = 0;\n\t\tthis.invokeAllPlugins( plugin => {\n\n\t\t\tif ( plugin.calculateBytesUsed ) {\n\n\t\t\t\tbytes += plugin.calculateBytesUsed( tile, tile.engineData.scene ) || 0;\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn bytes;\n\n\t}\n\n\t// force a recalculation of the tile or all tiles if no tile is provided\n\trecalculateBytesUsed( tile = null ) {\n\n\t\tconst { lruCache, processedTiles } = this;\n\t\tif ( tile === null ) {\n\n\t\t\tlruCache.itemSet.forEach( item => {\n\n\t\t\t\tif ( processedTiles.has( item ) ) {\n\n\t\t\t\t\tlruCache.setMemoryUsage( item, this.getBytesUsed( item ) );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\tlruCache.setMemoryUsage( tile, this.getBytesUsed( tile ) );\n\n\t\t}\n\n\t}\n\n\tpreprocessTileset( json, url, parent = null ) {\n\n\t\t// check for deprecated function usage\n\t\tconst proto = Object.getPrototypeOf( this );\n\t\tif ( Object.hasOwn( proto, 'preprocessTileSet' ) ) {\n\n\t\t\tconsole.warn( `${ proto.constructor.name }: Class overrides deprecated \"preprocessTileSet\" method. Please rename to \"preprocessTileset\".` );\n\n\t\t}\n\n\t\tconst version = json.asset.version;\n\t\tconst [ major, minor ] = version.split( '.' ).map( v => parseInt( v ) );\n\t\tconsole.assert(\n\t\t\tmajor <= 1,\n\t\t\t'TilesRenderer: asset.version is expected to be a 1.x or a compatible version.',\n\t\t);\n\n\t\tif ( major === 1 && minor > 0 ) {\n\n\t\t\tconsole.warn( 'TilesRenderer: tiles versions at 1.1 or higher have limited support. Some new extensions and features may not be supported.' );\n\n\t\t}\n\n\t\t// remove the last file path path-segment from the URL including the trailing slash\n\t\tlet basePath = url.replace( /\\/[^/]*$/, '' );\n\t\tbasePath = new URL( basePath, window.location.href ).toString();\n\t\tthis.preprocessNode( json.root, basePath, parent );\n\n\t}\n\n\tpreprocessTileSet( ...args ) {\n\n\t\tconsole.warn( 'TilesRenderer: \"preprocessTileSet\" has been deprecated. Use \"preprocessTileset\" instead.' );\n\t\treturn this.preprocessTileset( ...args );\n\n\t}\n\n\tloadRootTileset() {\n\n\t\t// check for deprecated function usage\n\t\tconst proto = Object.getPrototypeOf( this );\n\t\tif ( Object.hasOwn( proto, 'loadRootTileSet' ) ) {\n\n\t\t\tconsole.warn( `${ proto.constructor.name }: Class overrides deprecated \"loadRootTileSet\" method. Please rename to \"loadRootTileset\".` );\n\n\t\t}\n\n\t\t// transform the url\n\t\tlet processedUrl = this.rootURL;\n\t\tthis.invokeAllPlugins( plugin => processedUrl = plugin.preprocessURL ? plugin.preprocessURL( processedUrl, null ) : processedUrl );\n\n\t\t// load the tileset root\n\t\tconst pr = this\n\t\t\t.invokeOnePlugin( plugin => plugin.fetchData && plugin.fetchData( processedUrl, this.fetchOptions ) )\n\t\t\t.then( res => {\n\n\t\t\t\tif ( ! ( res instanceof Response ) ) {\n\n\t\t\t\t\treturn res;\n\n\t\t\t\t} else if ( res.ok ) {\n\n\t\t\t\t\treturn res.json();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( `TilesRenderer: Failed to load tileset \"${ processedUrl }\" with status ${ res.status } : ${ res.statusText }` );\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.then( root => {\n\n\t\t\t\tthis.preprocessTileset( root, processedUrl );\n\t\t\t\treturn root;\n\n\t\t\t} );\n\n\t\treturn pr;\n\n\t}\n\n\tloadRootTileSet( ...args ) {\n\n\t\tconsole.warn( 'TilesRenderer: \"loadRootTileSet\" has been deprecated. Use \"loadRootTileset\" instead.' );\n\t\treturn this.loadRootTileSet( ...args );\n\n\t}\n\n\trequestTileContents( tile ) {\n\n\t\t// If the tile is already being loaded then don't\n\t\t// start it again.\n\t\tif ( tile.internal.loadingState !== UNLOADED ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tlet isExternalTileset = false;\n\t\tlet externalTileset = null;\n\t\tlet uri = new URL( tile.content.uri, tile.internal.basePath + '/' ).toString();\n\t\tthis.invokeAllPlugins( plugin => uri = plugin.preprocessURL ? plugin.preprocessURL( uri, tile ) : uri );\n\n\t\tconst stats = this.stats;\n\t\tconst lruCache = this.lruCache;\n\t\tconst downloadQueue = this.downloadQueue;\n\t\tconst parseQueue = this.parseQueue;\n\t\tconst loadingTiles = this.loadingTiles;\n\t\tconst extension = getUrlExtension( uri );\n\n\t\t// track an abort controller and pass-through the below conditions if aborted\n\t\tconst controller = new AbortController();\n\t\tconst signal = controller.signal;\n\t\tconst addedSuccessfully = lruCache.add( tile, t => {\n\n\t\t\t// Stop the load if it's started\n\t\t\tcontroller.abort();\n\n\t\t\t// Clear out all tile content\n\t\t\tif ( isExternalTileset ) {\n\n\t\t\t\tt.children.length = 0;\n\n\t\t\t} else {\n\n\t\t\t\tthis.invokeAllPlugins( plugin => {\n\n\t\t\t\t\tplugin.disposeTile && plugin.disposeTile( t );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\t// Decrement stats\n\t\t\tstats.inCache --;\n\t\t\tif ( this.cachedSinceLoadComplete.has( tile ) ) {\n\n\t\t\t\tthis.cachedSinceLoadComplete.delete( tile );\n\t\t\t\tstats.inCacheSinceLoad --;\n\n\t\t\t}\n\n\t\t\tif ( t.internal.loadingState === QUEUED ) {\n\n\t\t\t\tstats.queued --;\n\n\t\t\t} else if ( t.internal.loadingState === LOADING ) {\n\n\t\t\t\tstats.downloading --;\n\n\t\t\t} else if ( t.internal.loadingState === PARSING ) {\n\n\t\t\t\tstats.parsing --;\n\n\t\t\t} else if ( t.internal.loadingState === LOADED ) {\n\n\t\t\t\tstats.loaded --;\n\n\t\t\t}\n\n\t\t\tt.internal.loadingState = UNLOADED;\n\n\t\t\tparseQueue.remove( t );\n\t\t\tdownloadQueue.remove( t );\n\t\t\tloadingTiles.delete( t );\n\n\t\t} );\n\n\t\t// if we couldn't add the tile to the lru cache because it's full then skip\n\t\tif ( ! addedSuccessfully ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// check if this is the beginning of a new set of tiles to load and dispatch and event\n\t\tif ( ! this.isLoading ) {\n\n\t\t\tthis.isLoading = true;\n\t\t\tthis.dispatchEvent( { type: 'tiles-load-start' } );\n\n\t\t}\n\n\t\tlruCache.setMemoryUsage( tile, this.getBytesUsed( tile ) );\n\t\tthis.cachedSinceLoadComplete.add( tile );\n\t\tstats.inCacheSinceLoad ++;\n\t\tstats.inCache ++;\n\t\tstats.queued ++;\n\t\ttile.internal.loadingState = QUEUED;\n\t\tloadingTiles.add( tile );\n\n\t\t// queue the download and parse\n\t\treturn downloadQueue.add( tile, downloadTile => {\n\n\t\t\tif ( signal.aborted ) {\n\n\t\t\t\treturn Promise.resolve();\n\n\t\t\t}\n\n\t\t\ttile.internal.loadingState = LOADING;\n\t\t\tstats.downloading ++;\n\t\t\tstats.queued --;\n\n\t\t\tconst res = this.invokeOnePlugin( plugin => plugin.fetchData && plugin.fetchData( uri, { ...this.fetchOptions, signal } ) );\n\t\t\tthis.dispatchEvent( { type: 'tile-download-start', tile, uri } );\n\t\t\treturn res;\n\n\t\t} )\n\t\t\t.then( res => {\n\n\t\t\t\tif ( signal.aborted ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( res instanceof Response ) ) {\n\n\t\t\t\t\treturn res;\n\n\t\t\t\t} else if ( res.ok ) {\n\n\t\t\t\t\treturn extension === 'json' ? res.json() : res.arrayBuffer();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( `Failed to load model with error code ${res.status}` );\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.then( content => {\n\n\t\t\t\t// if it has been unloaded then the tile has been disposed\n\t\t\t\tif ( signal.aborted ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tstats.downloading --;\n\t\t\t\tstats.parsing ++;\n\t\t\t\ttile.internal.loadingState = PARSING;\n\n\t\t\t\treturn parseQueue.add( tile, parseTile => {\n\n\t\t\t\t\t// if it has been unloaded then the tile has been disposed\n\t\t\t\t\tif ( signal.aborted ) {\n\n\t\t\t\t\t\treturn Promise.resolve();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( extension === 'json' && content.root ) {\n\n\t\t\t\t\t\tthis.preprocessTileset( content, uri, tile );\n\t\t\t\t\t\ttile.children.push( content.root );\n\t\t\t\t\t\texternalTileset = content;\n\t\t\t\t\t\tisExternalTileset = true;\n\t\t\t\t\t\treturn Promise.resolve();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn this.invokeOnePlugin( plugin => plugin.parseTile && plugin.parseTile( content, parseTile, extension, uri, signal ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t} )\n\t\t\t.then( () => {\n\n\t\t\t\t// if it has been unloaded then the tile has been disposed\n\t\t\t\tif ( signal.aborted ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tstats.parsing --;\n\t\t\t\tstats.loaded ++;\n\t\t\t\ttile.internal.loadingState = LOADED;\n\t\t\t\tloadingTiles.delete( tile );\n\t\t\t\tlruCache.setLoaded( tile, true );\n\n\t\t\t\t// If the memory of the item hasn't been registered yet then that means the memory usage hasn't\n\t\t\t\t// been accounted for by the cache yet so we need to check if it fits or if we should remove it.\n\t\t\t\tconst bytesUsed = this.getBytesUsed( tile );\n\t\t\t\tif ( lruCache.getMemoryUsage( tile ) === 0 && bytesUsed > 0 && lruCache.isFull() ) {\n\n\t\t\t\t\t// And if the cache is full due to newly loaded memory then lets discard this tile - it will\n\t\t\t\t\t// be loaded again later from the disk cache if needed.\n\t\t\t\t\tlruCache.remove( tile );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\t// update memory\n\t\t\t\tlruCache.setMemoryUsage( tile, bytesUsed );\n\n\t\t\t\t// dispatch an event indicating that this model has completed and that a new\n\t\t\t\t// call to \"update\" is needed.\n\t\t\t\tthis.dispatchEvent( { type: 'needs-update' } );\n\t\t\t\tthis.dispatchEvent( { type: 'load-content' } );\n\t\t\t\tif ( isExternalTileset ) {\n\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'load-tileset',\n\t\t\t\t\t\ttileset: externalTileset,\n\t\t\t\t\t\turl: uri,\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tif ( tile.engineData.scene ) {\n\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'load-model',\n\t\t\t\t\t\tscene: tile.engineData.scene,\n\t\t\t\t\t\ttile,\n\t\t\t\t\t\turl: uri,\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.catch( error => {\n\n\t\t\t\t// if it has been unloaded then the tile has been disposed\n\t\t\t\tif ( signal.aborted ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( error.name !== 'AbortError' ) {\n\n\t\t\t\t\tparseQueue.remove( tile );\n\t\t\t\t\tdownloadQueue.remove( tile );\n\n\t\t\t\t\tif ( tile.internal.loadingState === QUEUED ) {\n\n\t\t\t\t\t\tstats.queued --;\n\n\t\t\t\t\t} else if ( tile.internal.loadingState === LOADING ) {\n\n\t\t\t\t\t\tstats.downloading --;\n\n\t\t\t\t\t} else if ( tile.internal.loadingState === PARSING ) {\n\n\t\t\t\t\t\tstats.parsing --;\n\n\t\t\t\t\t} else if ( tile.internal.loadingState === LOADED ) {\n\n\t\t\t\t\t\tstats.loaded --;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tstats.failed ++;\n\n\t\t\t\t\tconsole.error( `TilesRenderer : Failed to load tile at url \"${ tile.content.uri }\".` );\n\t\t\t\t\tconsole.error( error );\n\t\t\t\t\ttile.internal.loadingState = FAILED;\n\t\t\t\t\tloadingTiles.delete( tile );\n\t\t\t\t\tlruCache.setLoaded( tile, true );\n\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'load-error',\n\t\t\t\t\t\ttile,\n\t\t\t\t\t\terror,\n\t\t\t\t\t\turl: uri,\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlruCache.remove( tile );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t}\n\n}\n"],"names":["getUrlExtension","url","endIndex","queryIndex","fragmentIndex","lastPeriodIndex","lastSlashIndex","protocolIndex","GIGABYTE_BYTES","LRUCache","cb","a","b","valA","valB","itemSet","item","bytes","bytesMap","removeCb","usedSet","itemList","callbacks","loadedSet","index","value","unloadPercent","minSize","maxSize","minBytesSize","maxBytesSize","unused","unloaded","excessNodes","excessBytes","unloadPriorityCallback","needsRerun","hasNodesToUnload","usedA","usedB","loadedA","loadedB","maxUnload","nodesToUnload","maxBytesUnload","bytesToUnload","removedNodes","removedBytes","PriorityQueueItemRemovedError","PriorityQueue","func","priorityCallback","items","callback","data","resolve","reject","info","err","filter","i","maxJobs","iterated","completedCallback","result","viewErrorTarget","isDownloadFinished","LOADED","FAILED","isUsedThisFrame","tile","frameCount","isProcessed","areChildrenProcessed","childrenReady","contentReady","canUnconditionallyRefine","resetFrameState","renderer","recursivelyMarkUsed","cacheOnly","markUsed","children","l","recursivelyMarkPreviouslyUsed","canTraverse","kickActiveChildren","c","isChildReady","markUsedTiles","anyChildrenUsed","anyChildrenInFrustum","markUsedSetLeaves","allUsedChildrenProcessed","markVisibleTiles","hasContent","loadedContent","allChildrenReady","thisTileIsVisible","toggleTiles","isUsed","_a","setActive","setVisible","plugin","runTraversal","LOAD_ROOT_SIBLINGS","recursivelyLoadNextRenderableTiles","childCanDisplay","stats","errorRequirement","meetsSSE","isAdditiveRefine","throttle","handle","traverseSet","beforeCb","afterCb","stack","depth","parent","traverseAncestors","current","PLUGIN_REGISTERED","regionErrorTarget","defaultPriorityCallback","aPriority","bPriority","optimizedPriorityCallback","lruPriorityCallback","TilesRendererBase","tileset","isLoading","loading","total","v","UNLOADED","lruCache","downloadQueue","parseQueue","processNodeQueue","aParent","bParent","plugins","priority","insertionPoint","name","p","pending","beforecb","aftercb","ensureFullyProcessed","args","target","root","optimizedLoadStrategy","LOADING","processedUrl","error","needsUpdate","res","optimizedRunTraversal","queuedTiles","inRegion","inRegionError","inRegionDistance","toRemove","t","scene","buffer","extension","tilesetDir","parentTile","hasUnrenderableContent","active","visible","loadingTiles","QUEUED","options","forceImmediate","processChildren","processedTiles","json","proto","version","major","minor","basePath","isExternalTileset","externalTileset","uri","controller","signal","PARSING","downloadTile","content","parseTile","bytesUsed"],"mappings":"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"}