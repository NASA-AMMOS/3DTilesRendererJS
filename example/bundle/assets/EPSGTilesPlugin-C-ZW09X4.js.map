{"version":3,"file":"EPSGTilesPlugin-C-ZW09X4.js","sources":["../../../src/three/plugins/images/utils/getCartographicToMeterDerivative.js","../../../src/three/plugins/images/EllipsoidProjectionTilesPlugin.js","../../../src/three/plugins/images/sources/WMTSImageSource.js","../../../src/three/plugins/images/sources/WMSImageSource.js","../../../src/three/plugins/images/EPSGTilesPlugin.js"],"sourcesContent":["import { Vector3 } from 'three';\n\nconst _v0 = /* @__PURE__ */ new Vector3();\nconst _v1 = /* @__PURE__ */ new Vector3();\n\nexport function getCartographicToMeterDerivative( ellipsoid, lat, lon ) {\n\n\tconst EPS = 1e-5;\n\tconst lonp = lon + EPS;\n\tlet latp = lat + EPS;\n\tif ( Math.abs( latp ) > Math.PI / 2 ) {\n\n\t\tlatp = latp - EPS;\n\n\t}\n\n\tellipsoid.getCartographicToPosition( lat, lon, 0, _v0 );\n\n\tellipsoid.getCartographicToPosition( latp, lon, 0, _v1 );\n\tconst dy = _v0.distanceTo( _v1 ) / EPS;\n\n\tellipsoid.getCartographicToPosition( lat, lonp, 0, _v1 );\n\tconst dx = _v0.distanceTo( _v1 ) / EPS;\n\n\treturn [ dx, dy ];\n\n}\n","import { ImageFormatPlugin, TILE_LEVEL, TILE_X, TILE_Y } from './ImageFormatPlugin.js';\nimport { MathUtils, PlaneGeometry, Sphere, Vector2, Vector3 } from 'three';\nimport { getCartographicToMeterDerivative } from './utils/getCartographicToMeterDerivative.js';\n\nconst MIN_LON_VERTS = 30;\nconst MIN_LAT_VERTS = 15;\n\nconst _pos = /* @__PURE__ */ new Vector3();\nconst _norm = /* @__PURE__ */ new Vector3();\nconst _uv = /* @__PURE__ */ new Vector2();\nconst _sphere = /* @__PURE__ */ new Sphere();\n\nexport class EllipsoidProjectionTilesPlugin extends ImageFormatPlugin {\n\n\tget projection() {\n\n\t\treturn this.tiling.projection;\n\n\t}\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\tshape = 'planar',\n\t\t\tendCaps = true,\n\t\t\t...rest\n\t\t} = options;\n\n\t\tsuper( rest );\n\n\t\t// options\n\t\tthis.shape = shape;\n\t\tthis.endCaps = endCaps;\n\n\t}\n\n\t// override the parse to mesh logic to support a region mesh\n\tasync parseToMesh( buffer, tile, ...args ) {\n\n\t\tconst mesh = await super.parseToMesh( buffer, tile, ...args );\n\n\t\t// if displaying the tiles as an ellipsoid\n\t\tconst { shape, projection, tiles, tiling } = this;\n\t\tif ( shape === 'ellipsoid' ) {\n\n\t\t\tconst ellipsoid = tiles.ellipsoid;\n\t\t\tconst level = tile[ TILE_LEVEL ];\n\t\t\tconst x = tile[ TILE_X ];\n\t\t\tconst y = tile[ TILE_Y ];\n\n\t\t\t// new geometry\n\t\t\t// default to a minimum number of vertices per degree on each axis\n\t\t\tconst [ west, south, east, north ] = tile.boundingVolume.region;\n\t\t\tconst latVerts = Math.ceil( ( north - south ) * MathUtils.RAD2DEG * 0.25 );\n\t\t\tconst lonVerts = Math.ceil( ( east - west ) * MathUtils.RAD2DEG * 0.25 );\n\t\t\tconst yVerts = Math.max( MIN_LAT_VERTS, latVerts );\n\t\t\tconst xVerts = Math.max( MIN_LON_VERTS, lonVerts );\n\t\t\tconst geometry = new PlaneGeometry( 1, 1, xVerts, yVerts );\n\n\t\t\tconst [ minU, minV, maxU, maxV ] = tiling.getTileBounds( x, y, level, true, true );\n\t\t\tconst uvRange = tiling.getTileContentUVBounds( x, y, level );\n\n\t\t\t// adjust the geometry to position it at the region\n\t\t\tconst { position, normal, uv } = geometry.attributes;\n\t\t\tconst vertCount = position.count;\n\t\t\ttile.cached.boundingVolume.getSphere( _sphere );\n\t\t\tfor ( let i = 0; i < vertCount; i ++ ) {\n\n\t\t\t\t// retrieve attributes\n\t\t\t\t_pos.fromBufferAttribute( position, i );\n\t\t\t\t_uv.fromBufferAttribute( uv, i );\n\n\t\t\t\t// convert the plane position to lat / lon\n\t\t\t\tconst lon = projection.convertProjectionToLongitude( MathUtils.mapLinear( _uv.x, 0, 1, minU, maxU ) );\n\t\t\t\tlet lat = projection.convertProjectionToLatitude( MathUtils.mapLinear( _uv.y, 0, 1, minV, maxV ) );\n\n\t\t\t\t// snap the edges to the poles if using mercator projection and end caps are enabled\n\t\t\t\tif ( projection.isMercator && this.endCaps ) {\n\n\t\t\t\t\tif ( maxV === 1 && _uv.y === 1 ) {\n\n\t\t\t\t\t\tlat = Math.PI / 2;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( minV === 0 && _uv.y === 0 ) {\n\n\t\t\t\t\t\tlat = - Math.PI / 2;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// ensure we have an edge loop positioned at the mercator limit to avoid UV distortion\n\t\t\t\t// as much as possible at low LoDs.\n\t\t\t\tif ( projection.isMercator && _uv.y !== 0 && _uv.y !== 1 ) {\n\n\t\t\t\t\tconst latLimit = projection.convertProjectionToLatitude( 1 );\n\t\t\t\t\tconst vStep = 1 / yVerts;\n\n\t\t\t\t\tconst prevLat = MathUtils.mapLinear( _uv.y - vStep, 0, 1, south, north );\n\t\t\t\t\tconst nextLat = MathUtils.mapLinear( _uv.y + vStep, 0, 1, south, north );\n\t\t\t\t\tif ( lat > latLimit && prevLat < latLimit ) {\n\n\t\t\t\t\t\tlat = latLimit;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( lat < - latLimit && nextLat > - latLimit ) {\n\n\t\t\t\t\t\tlat = - latLimit;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// get the position and normal\n\t\t\t\tellipsoid.getCartographicToPosition( lat, lon, 0, _pos ).sub( _sphere.center );\n\t\t\t\tellipsoid.getCartographicToNormal( lat, lon, _norm );\n\n\t\t\t\t// map from the uvs for the tile into the uv range\n\t\t\t\tconst u = MathUtils.mapLinear( projection.convertLongitudeToProjection( lon ), minU, maxU, uvRange[ 0 ], uvRange[ 2 ] );\n\t\t\t\tconst v = MathUtils.mapLinear( projection.convertLatitudeToProjection( lat ), minV, maxV, uvRange[ 1 ], uvRange[ 3 ] );\n\n\t\t\t\t// update the geometry\n\t\t\t\tuv.setXY( i, u, v );\n\t\t\t\tposition.setXYZ( i, ..._pos );\n\t\t\t\tnormal.setXYZ( i, ..._norm );\n\n\t\t\t}\n\n\t\t\tmesh.geometry = geometry;\n\t\t\tmesh.position.copy( _sphere.center );\n\n\t\t}\n\n\t\treturn mesh;\n\n\t}\n\n\tcreateBoundingVolume( x, y, level ) {\n\n\t\tif ( this.shape === 'ellipsoid' ) {\n\n\t\t\tconst { tiling, endCaps } = this;\n\t\t\tconst isRoot = level === - 1;\n\t\t\tconst normalizedBounds = isRoot ? tiling.getContentBounds( true ) : tiling.getTileBounds( x, y, level, true, true );\n\t\t\tconst cartBounds = isRoot ? tiling.getContentBounds() : tiling.getTileBounds( x, y, level, false, true );\n\n\t\t\tif ( endCaps ) {\n\n\t\t\t\t// if the north side is at the edge\n\t\t\t\tif ( normalizedBounds[ 3 ] === 1 ) {\n\n\t\t\t\t\tcartBounds[ 3 ] = Math.PI / 2;\n\n\t\t\t\t}\n\n\t\t\t\t// if the south side is at the edge\n\t\t\t\tif ( normalizedBounds[ 1 ] === 0 ) {\n\n\t\t\t\t\tcartBounds[ 1 ] = - Math.PI / 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tregion: [ ...cartBounds, - 1, 1 ],\n\t\t\t};\n\n\t\t} else {\n\n\t\t\treturn super.createBoundingVolume( x, y, level );\n\n\t\t}\n\n\t}\n\n\tcreateChild( ...args ) {\n\n\t\tconst tile = super.createChild( ...args );\n\n\t\tconst { shape, projection, tiling } = this;\n\t\tif ( tile && shape === 'ellipsoid' ) {\n\n\t\t\tconst level = tile[ TILE_LEVEL ];\n\t\t\tconst x = tile[ TILE_X ];\n\t\t\tconst y = tile[ TILE_Y ];\n\n\t\t\t// if this is the root node then skip calculating the geometric error\n\t\t\tif ( level === - 1 ) {\n\n\t\t\t\ttile.geometricError = 1e50;\n\t\t\t\treturn parent;\n\n\t\t\t}\n\n\t\t\tconst [ minU, minV, maxU, maxV ] = tiling.getTileBounds( x, y, level, true );\n\t\t\tconst { tilePixelWidth, tilePixelHeight } = tiling.getLevel( level );\n\n\t\t\t// one pixel width in uv space\n\t\t\tconst tileUWidth = ( maxU - minU ) / tilePixelWidth;\n\t\t\tconst tileVWidth = ( maxV - minV ) / tilePixelHeight;\n\n\t\t\t// calculate the region ranges\n\t\t\tconst [ /* west */, south, east, north ] = tiling.getTileBounds( x, y, level );\n\n\t\t\t// calculate the changes in lat / lon at the given point\n\t\t\t// find the most bowed point of the latitude range since the amount that latitude changes is\n\t\t\t// dependent on the Y value of the image\n\t\t\tconst midLat = ( south > 0 ) !== ( north > 0 ) ? 0 : Math.min( Math.abs( south ), Math.abs( north ) );\n\t\t\tconst midV = projection.convertLatitudeToProjection( midLat );\n\t\t\tconst lonFactor = projection.getLongitudeDerivativeAtProjection( minU );\n\t\t\tconst latFactor = projection.getLatitudeDerivativeAtProjection( midV );\n\n\t\t\t// calculate the size of a pixel on the surface\n\t\t\tconst [ xDeriv, yDeriv ] = getCartographicToMeterDerivative( this.tiles.ellipsoid, midLat, east );\n\t\t\tconst projectedPixelWidth = Math.max( tileUWidth * lonFactor * xDeriv, tileVWidth * latFactor * yDeriv );\n\t\t\ttile.geometricError = projectedPixelWidth;\n\n\t\t}\n\n\t\treturn tile;\n\n\t}\n\n}\n\n","import { TiledImageSource } from './TiledImageSource.js';\nimport { ProjectionScheme } from '../utils/ProjectionScheme.js';\n\nexport class WMTSImageSource extends TiledImageSource {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper();\n\n\t\tconst {\n\t\t\tcapabilities = null,\n\t\t\tlayer = null,\n\t\t\ttileMatrixSet = null,\n\t\t\tstyle = null,\n\t\t\turl = null,\n\t\t\tdimensions = {},\n\t\t} = options;\n\n\t\tthis.capabilities = capabilities;\n\t\tthis.layer = layer;\n\t\tthis.tileMatrixSet = tileMatrixSet;\n\t\tthis.style = style;\n\t\tthis.dimensions = dimensions;\n\t\tthis.url = url;\n\n\t}\n\n\tgetUrl( x, y, level ) {\n\n\t\treturn this.url\n\t\t\t.replace( /{\\s*TileMatrix\\s*}/gi, level )\n\t\t\t.replace( /{\\s*TileCol\\s*}/gi, x )\n\t\t\t.replace( /{\\s*TileRow\\s*}/gi, y );\n\n\t}\n\n\tinit() {\n\n\t\tconst { tiling, dimensions, capabilities } = this;\n\t\tlet { layer, tileMatrixSet, style, url } = this;\n\n\t\t// extract the layer to use\n\t\tif ( ! layer ) {\n\n\t\t\tlayer = capabilities.layers[ 0 ];\n\n\t\t} else if ( typeof layer === 'string' ) {\n\n\t\t\tlayer = capabilities.layers.find( l => l.identifier === layer );\n\n\t\t}\n\n\t\t// extract the tile matrix set\n\t\tif ( ! tileMatrixSet ) {\n\n\t\t\ttileMatrixSet = layer.tileMatrixSets[ 0 ];\n\n\t\t} else if ( typeof tileMatrixSet === 'string' ) {\n\n\t\t\ttileMatrixSet = layer.tileMatrixSets.find( tms => tms.identifier === tileMatrixSet );\n\n\t\t}\n\n\t\t// extract the style\n\t\tif ( ! style ) {\n\n\t\t\tstyle = layer.styles.find( style => style.isDefault ).identifier;\n\n\t\t}\n\n\t\t// extract the url template\n\t\tif ( ! url ) {\n\n\t\t\turl = layer.resourceUrls[ 0 ].template;\n\n\t\t}\n\n\t\t// determine the projection\n\t\tconst projection = tileMatrixSet.supportedCRS.includes( '4326' ) ? 'EPSG:4326' : 'EPSG:3857';\n\n\t\t// generate the tiling scheme\n\t\ttiling.flipY = true;\n\t\ttiling.setProjection( new ProjectionScheme( projection ) );\n\n\t\tif ( layer.boundingBox !== null ) {\n\n\t\t\ttiling.setContentBounds( ...layer.boundingBox.bounds );\n\n\t\t} else {\n\n\t\t\ttiling.setContentBounds( ...tiling.projection.getBounds() );\n\n\t\t}\n\n\t\ttileMatrixSet.tileMatrices.forEach( ( tm, i ) => {\n\n\t\t\t// TODO: needs to set tileCountX from matrix width?\n\t\t\t// TODO: How does bounds and tile count work together here?\n\t\t\t// Can one typically be generated from the other?\n\n\t\t\tconst { tileWidth, tileHeight, matrixWidth, matrixHeight } = tm;\n\t\t\ttiling.setLevel( i, {\n\t\t\t\ttilePixelWidth: tileWidth,\n\t\t\t\ttilePixelHeight: tileHeight,\n\t\t\t\ttileCountX: matrixWidth || tiling.projection.tileCountX * 2 ** i,\n\t\t\t\ttileCountY: matrixHeight || tiling.projection.tileCountY * 2 ** i,\n\t\t\t\ttileBounds: tm.bounds,\n\t\t\t} );\n\n\t\t} );\n\n\t\t// construct the url\n\t\turl = url\n\t\t\t.replace( /{\\s*TileMatrixSet\\s*}/g, tileMatrixSet.identifier )\n\t\t\t.replace( /{\\s*Style\\s*}/g, style );\n\n\t\t// fill in the dimension values\n\t\tfor ( const key in dimensions ) {\n\n\t\t\turl = url.replace( new RegExp( `{\\\\s*${ key }\\\\s*}` ), dimensions[ key ] );\n\n\t\t}\n\n\t\tlayer.dimensions.forEach( dim => {\n\n\t\t\turl = url.replace( new RegExp( `{\\\\s*${ dim.identifier }\\\\s*}` ), dim.defaultValue );\n\n\t\t} );\n\n\t\tthis.url = url;\n\n\t\treturn Promise.resolve();\n\n\t}\n\n}\n","import { TiledImageSource } from './TiledImageSource.js';\nimport { ProjectionScheme } from '../utils/ProjectionScheme.js';\nimport { MathUtils } from 'three';\n\nexport class WMSImageSource extends TiledImageSource {\n\n\t// TODO: layer and styles can be arrays, comma separated lists\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\turl = null,\n\t\t\tlayer = null,\n\t\t\tstyles = null,\n\t\t\tcontentBoundingBox = null,\n\t\t\tversion = '1.3.0',\n\t\t\tcrs = 'EPSG:4326',\n\t\t\tformat = 'image/png',\n\t\t\ttransparent = false,\n\t\t\tlevels = 18,\n\t\t\ttileDimension = 256,\n\t\t} = options;\n\n\t\tsuper();\n\t\tthis.url = url;\n\t\tthis.layer = layer;\n\t\tthis.crs = crs;\n\t\tthis.format = format;\n\t\tthis.tileDimension = tileDimension;\n\t\tthis.styles = styles;\n\t\tthis.version = version;\n\t\tthis.levels = levels;\n\t\tthis.transparent = transparent;\n\t\tthis.contentBoundingBox = contentBoundingBox;\n\n\t}\n\n\tinit() {\n\n\t\tconst { tiling, levels, tileDimension, contentBoundingBox } = this;\n\t\ttiling.setProjection( new ProjectionScheme( this.crs ) );\n\t\ttiling.flipY = true;\n\t\ttiling.generateLevels( levels, tiling.projection.tileCountX, tiling.projection.tileCountY, {\n\t\t\ttilePixelWidth: tileDimension,\n\t\t\ttilePixelHeight: tileDimension,\n\t\t} );\n\n\t\tif ( contentBoundingBox !== null ) {\n\n\t\t\ttiling.setContentBounds( ...contentBoundingBox );\n\n\t\t} else {\n\n\t\t\ttiling.setContentBounds( ...tiling.projection.getBounds() );\n\n\t\t}\n\n\t\treturn Promise.resolve();\n\n\t}\n\n\t// TODO: handle this in ProjectionScheme or TilingScheme? Or Loader?\n\tnormalizedToMercatorX( v ) {\n\n\t\tconst MERCATOR_MIN = - 20037508.342789244;\n\t\tconst MERCATOR_MAX = 20037508.342789244;\n\t\treturn MathUtils.mapLinear( v, 0, 1, MERCATOR_MIN, MERCATOR_MAX );\n\n\t}\n\n\tnormalizedToMercatorY( v ) {\n\n\t\tconst MERCATOR_MIN = - 20037508.342789244;\n\t\tconst MERCATOR_MAX = 20037508.342789244;\n\t\treturn MathUtils.mapLinear( v, 0, 1, MERCATOR_MIN, MERCATOR_MAX );\n\n\t}\n\n\tgetUrl( x, y, level ) {\n\n\t\tconst {\n\t\t\ttiling,\n\t\t\tlayer,\n\t\t\tcrs,\n\t\t\tformat,\n\t\t\ttileDimension,\n\t\t\tstyles,\n\t\t\tversion,\n\t\t\ttransparent,\n\t\t} = this;\n\n\t\t// Axis order and CRS param name depend on WMS version and CRS\n\t\t// crsParam: 'SRS' for WMS 1.1.1, 'CRS' for WMS 1.3.0\n\t\tconst crsParam = version === '1.1.1' ? 'SRS' : 'CRS';\n\t\tlet bboxParam;\n\n\t\tif ( crs === 'EPSG:3857' ) {\n\n\t\t\t// Always lon / lat order for both versions\n\t\t\tconst range = tiling.getTileBounds( x, y, level, true, false );\n\t\t\tconst minx = this.normalizedToMercatorX( range[ 0 ] );\n\t\t\tconst miny = this.normalizedToMercatorY( range[ 1 ] );\n\t\t\tconst maxx = this.normalizedToMercatorX( range[ 2 ] );\n\t\t\tconst maxy = this.normalizedToMercatorY( range[ 3 ] );\n\t\t\tbboxParam = [ minx, miny, maxx, maxy ];\n\n\t\t} else {\n\n\t\t\t// Get the tile bounds as degrees\n\t\t\tconst [ minx, miny, maxx, maxy ] = tiling\n\t\t\t\t.getTileBounds( x, y, level, false, false )\n\t\t\t\t.map( v => v * MathUtils.RAD2DEG );\n\n\t\t\tif ( crs === 'EPSG:4326' ) {\n\n\t\t\t\t// Note: In WMS 1.1.1 EPSG:4326 is wrongly defined as having long/lat coordinate axes. See v1.3.0 documentation for details.\n\t\t\t\t// Docs:  https://docs.foursquare.com/analytics-products/docs/data-formats-wms\n\t\t\t\t// Topic: https://gis.stackexchange.com/questions/23347/getmap-wms-1-1-1-vs-1-3-0\n\t\t\t\tif ( version === '1.1.1' ) {\n\n\t\t\t\t\t// WMS 1.1.1: lon / lat order\n\t\t\t\t\tbboxParam = [ minx, miny, maxx, maxy ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// WMS 1.3.0: lat / lon order\n\t\t\t\t\tbboxParam = [ miny, minx, maxy, maxx ];\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tbboxParam = [ minx, miny, maxx, maxy ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst params = new URLSearchParams( {\n\t\t\tSERVICE: 'WMS',\n\t\t\tREQUEST: 'GetMap',\n\t\t\tVERSION: version,\n\t\t\tLAYERS: layer,\n\t\t\tSTYLES: styles,\n\t\t\t[ crsParam ]: crs,\n\t\t\tBBOX: bboxParam.join( ',' ),\n\t\t\tWIDTH: tileDimension,\n\t\t\tHEIGHT: tileDimension,\n\t\t\tFORMAT: format,\n\t\t\tTRANSPARENT: transparent ? 'TRUE' : 'FALSE',\n\t\t} );\n\n\t\treturn new URL( '?' + params.toString(), this.url ).toString();\n\n\t}\n\n}\n","\n// Support for XYZ / Slippy tile systems\n\nimport { EllipsoidProjectionTilesPlugin } from './EllipsoidProjectionTilesPlugin.js';\nimport { XYZImageSource } from './sources/XYZImageSource.js';\nimport { TMSImageSource } from './sources/TMSImageSource.js';\nimport { WMTSImageSource } from './sources/WMTSImageSource.js';\nimport { WMSImageSource } from './sources/WMSImageSource.js';\n\n// https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames\nexport class XYZTilesPlugin extends EllipsoidProjectionTilesPlugin {\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\tlevels,\n\t\t\ttileDimension,\n\t\t\tbounds,\n\t\t\turl,\n\t\t\t...rest\n\t\t} = options;\n\n\t\tsuper( rest );\n\n\t\tthis.name = 'XYZ_TILES_PLUGIN';\n\t\tthis.imageSource = new XYZImageSource( { url, levels, tileDimension, bounds } );\n\n\t}\n\n}\n\n// Support for TMS tiles\n// https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification\n// NOTE: Most, if not all, TMS generation implementations do not correctly support the Origin tag\n// and tile index offsets, including CesiumJS and Ion.\nexport class TMSTilesPlugin extends EllipsoidProjectionTilesPlugin {\n\n\tconstructor( options = {} ) {\n\n\t\tconst { url, ...rest } = options;\n\t\tsuper( rest );\n\n\t\tthis.name = 'TMS_TILES_PLUGIN';\n\t\tthis.imageSource = new TMSImageSource( { url } );\n\n\t}\n\n}\n\n// Support for WMTS tiles via a url template\nexport class WMTSTilesPlugin extends EllipsoidProjectionTilesPlugin {\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\tcapabilities,\n\t\t\tlayer,\n\t\t\ttileMatrixSet,\n\t\t\tstyle,\n\t\t\tdimensions,\n\t\t\t...rest\n\t\t} = options;\n\n\t\tsuper( rest );\n\n\t\tthis.name = 'WTMS_TILES_PLUGIN';\n\t\tthis.imageSource = new WMTSImageSource( {\n\t\t\tcapabilities,\n\t\t\tlayer,\n\t\t\ttileMatrixSet,\n\t\t\tstyle,\n\t\t\tdimensions\n\t\t} );\n\n\t}\n\n}\n\nexport class WMSTilesPlugin extends EllipsoidProjectionTilesPlugin {\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\turl,\n\t\t\tlayer,\n\t\t\tcrs,\n\t\t\tformat,\n\t\t\ttileDimension,\n\t\t\tstyles,\n\t\t\tversion,\n\t\t\t...rest\n\t\t} = options;\n\n\t\tsuper( rest );\n\n\t\tthis.name = 'WMS_TILES_PLUGIN';\n\t\tthis.imageSource = new WMSImageSource( {\n\t\t\turl,\n\t\t\tlayer,\n\t\t\tcrs,\n\t\t\tformat,\n\t\t\ttileDimension,\n\t\t\tstyles,\n\t\t\tversion\n\t\t} );\n\n\t}\n\n}\n"],"names":["_v0","Vector3","_v1","getCartographicToMeterDerivative","ellipsoid","lat","lon","lonp","latp","dy","MIN_LON_VERTS","MIN_LAT_VERTS","_pos","_norm","_uv","Vector2","_sphere","Sphere","EllipsoidProjectionTilesPlugin","ImageFormatPlugin","options","shape","endCaps","rest","buffer","tile","args","mesh","projection","tiles","tiling","level","TILE_LEVEL","x","TILE_X","y","TILE_Y","west","south","east","north","latVerts","MathUtils","lonVerts","yVerts","xVerts","geometry","PlaneGeometry","minU","minV","maxU","maxV","uvRange","position","normal","uv","vertCount","i","latLimit","vStep","prevLat","nextLat","u","v","isRoot","normalizedBounds","cartBounds","tilePixelWidth","tilePixelHeight","tileUWidth","tileVWidth","midLat","midV","lonFactor","latFactor","xDeriv","yDeriv","projectedPixelWidth","WMTSImageSource","TiledImageSource","capabilities","layer","tileMatrixSet","style","url","dimensions","l","tms","ProjectionScheme","tm","tileWidth","tileHeight","matrixWidth","matrixHeight","key","dim","WMSImageSource","styles","contentBoundingBox","version","crs","format","transparent","levels","tileDimension","crsParam","bboxParam","range","minx","miny","maxx","maxy","params","XYZTilesPlugin","bounds","XYZImageSource","TMSTilesPlugin","TMSImageSource","WMTSTilesPlugin","WMSTilesPlugin"],"mappings":"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"}