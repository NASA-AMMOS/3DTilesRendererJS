import{h as ut,a_ as mt,b as ft,V as M,ah as lt,n as J,aQ as Pt,av as ht,o as v,R as gt,u as vt,Q as dt,M as B}from"./three.module-D-uF--xd.js";class yt extends ut{constructor(){super(new mt(0,0),new xt),this.renderOrder=1/0}onBeforeRender(t){const e=this.material.uniforms;t.getSize(e.resolution.value)}updateMatrixWorld(){this.matrixWorld.makeTranslation(this.position)}dispose(){this.geometry.dispose(),this.material.dispose()}}class xt extends ft{constructor(){super({depthWrite:!1,depthTest:!1,transparent:!0,uniforms:{resolution:{value:new M},size:{value:15},thickness:{value:2},opacity:{value:1}},vertexShader:`

				uniform float size;
				uniform float thickness;
				uniform vec2 resolution;
				varying vec2 vUv;

				void main() {

					vUv = uv;

					float aspect = resolution.x / resolution.y;
					vec2 offset = uv * 2.0 - vec2( 1.0 );
					offset.y *= aspect;

					vec4 screenPoint = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
					screenPoint.xy += offset * ( size + thickness ) * screenPoint.w / resolution.x;

					gl_Position = screenPoint;

				}
			`,fragmentShader:`

				uniform float size;
				uniform float thickness;
				uniform float opacity;

				varying vec2 vUv;
				void main() {

					float ht = 0.5 * thickness;
					float planeDim = size + thickness;
					float offset = ( planeDim - ht - 2.0 ) / planeDim;
					float texelThickness = ht / planeDim;

					vec2 vec = vUv * 2.0 - vec2( 1.0 );
					float dist = abs( length( vec ) - offset );
					float fw = fwidth( dist ) * 0.5;
					float a = smoothstep( texelThickness - fw, texelThickness + fw, dist );

					gl_FragColor = vec4( 1, 1, 1, opacity * ( 1.0 - a ) );

				}
			`})}}const et=new M,it=new M;class St{constructor(){this.domElement=null,this.buttons=0,this.pointerType=null,this.pointerOrder=[],this.previousPositions={},this.pointerPositions={},this.startPositions={},this.pointerSetThisFrame={},this.hoverPosition=new M,this.hoverSet=!1}reset(){this.buttons=0,this.pointerType=null,this.pointerOrder=[],this.previousPositions={},this.pointerPositions={},this.startPositions={},this.pointerSetThisFrame={},this.hoverPosition=new M,this.hoverSet=!1}updateFrame(){const{previousPositions:t,pointerPositions:e}=this;for(const i in e)t[i].copy(e[i])}setHoverEvent(t){(t.pointerType==="mouse"||t.type==="wheel")&&(this.getAdjustedPointer(t,this.hoverPosition),this.hoverSet=!0)}getLatestPoint(t){return this.pointerType!==null?(this.getCenterPoint(t),t):this.hoverSet?(t.copy(this.hoverPosition),t):null}getAdjustedPointer(t,e){const o=(this.domElement?this.domElement:t.target).getBoundingClientRect(),s=t.clientX-o.left,d=t.clientY-o.top;e.set(s,d)}addPointer(t){const e=t.pointerId,i=new M;this.getAdjustedPointer(t,i),this.pointerOrder.push(e),this.pointerPositions[e]=i,this.previousPositions[e]=i.clone(),this.startPositions[e]=i.clone(),this.getPointerCount()===1&&(this.pointerType=t.pointerType,this.buttons=t.buttons)}updatePointer(t){const e=t.pointerId;return e in this.pointerPositions?(this.getAdjustedPointer(t,this.pointerPositions[e]),!0):!1}deletePointer(t){const e=t.pointerId,i=this.pointerOrder;i.splice(i.indexOf(e),1),delete this.pointerPositions[e],delete this.previousPositions[e],delete this.startPositions[e],this.getPointerCount()===0&&(this.buttons=0,this.pointerType=null)}getPointerCount(){return this.pointerOrder.length}getCenterPoint(t,e=this.pointerPositions){const i=this.pointerOrder;if(this.getPointerCount()===1||this.getPointerType()==="mouse"){const o=i[0];return t.copy(e[o]),t}else if(this.getPointerCount()===2){const o=this.pointerOrder[0],s=this.pointerOrder[1],d=e[o],a=e[s];return t.addVectors(d,a).multiplyScalar(.5),t}return null}getPreviousCenterPoint(t){return this.getCenterPoint(t,this.previousPositions)}getStartCenterPoint(t){return this.getCenterPoint(t,this.startPositions)}getMoveDistance(){return this.getCenterPoint(et),this.getPreviousCenterPoint(it),et.sub(it).length()}getTouchPointerDistance(t=this.pointerPositions){if(this.getPointerCount()<=1||this.getPointerType()==="mouse")return 0;const{pointerOrder:e}=this,i=e[0],o=e[1],s=t[i],d=t[o];return s.distanceTo(d)}getPreviousTouchPointerDistance(){return this.getTouchPointerDistance(this.previousPositions)}getStartTouchPointerDistance(){return this.getTouchPointerDistance(this.startPositions)}getPointerType(){return this.pointerType}isPointerTouch(){return this.getPointerType()==="touch"}getPointerButtons(){return this.buttons}isLeftClicked(){return!!(this.buttons&1)}isRightClicked(){return!!(this.buttons&2)}}const F=new J;function N(f,t,e){return e.makeTranslation(-f.x,-f.y,-f.z),F.makeRotationFromQuaternion(t),e.premultiply(F),F.makeTranslation(f.x,f.y,f.z),e.premultiply(F),e}function U(f,t,e){e.x=f.x/t.clientWidth*2-1,e.y=-(f.y/t.clientHeight)*2+1,e.isVector3&&(e.z=0)}function w(f,t,e){const i=f instanceof lt?f:f.ray,{origin:o,direction:s}=i;o.set(t.x,t.y,-1).unproject(e),s.set(t.x,t.y,1).unproject(e).sub(o),f.isRay||(f.near=0,f.far=s.length(),f.camera=e),s.normalize()}const C=0,R=1,T=2,A=3,Q=4,G=.05,Y=.025,k=new J,V=new J,D=new v,h=new v,L=new v,H=new v,x=new v,b=new v,K=new v,j=new v,z=new dt,ot=new ht,P=new v,Z=new v,X=new v,_t=new dt,m=new lt,q=new M,_=new M,st=new M,O=new M,$=new M,nt=new M,rt={type:"change"},at={type:"start"},ct={type:"end"};class Mt extends Pt{get enabled(){return this._enabled}set enabled(t){t!==this.enabled&&(this._enabled=t,this.resetState(),this.pointerTracker.reset(),this.enabled||(this.dragInertia.set(0,0,0),this.rotationInertia.set(0,0)))}constructor(t=null,e=null,i=null,o=null){super(),this.isEnvironmentControls=!0,this.domElement=null,this.camera=null,this.scene=null,this.tilesRenderer=null,this._enabled=!0,this.cameraRadius=5,this.rotationSpeed=1,this.minAltitude=0,this.maxAltitude=.45*Math.PI,this.minDistance=10,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.zoomSpeed=1,this.adjustHeight=!0,this.enableDamping=!1,this.dampingFactor=.15,this.fallbackPlane=new ht(new v(0,1,0),0),this.useFallbackPlane=!0,this.scaleZoomOrientationAtEdges=!1,this.autoAdjustCameraRotation=!0,this.state=C,this.pointerTracker=new St,this.needsUpdate=!1,this.actionHeightOffset=0,this.pivotPoint=new v,this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.zoomDirection=new v,this.zoomPoint=new v,this.zoomDelta=0,this.rotationInertiaPivot=new v,this.rotationInertia=new M,this.dragInertia=new v,this.inertiaTargetDistance=1/0,this.inertiaStableFrames=0,this.pivotMesh=new yt,this.pivotMesh.raycast=()=>{},this.pivotMesh.scale.setScalar(.25),this.raycaster=new gt,this.raycaster.firstHitOnly=!0,this.up=new v(0,1,0),this.clock=new vt,this._detachCallback=null,this._upInitialized=!1,this._lastUsedState=C,this._zoomPointWasSet=!1,this._tilesOnChangeCallback=()=>this.zoomPointSet=!1,i&&this.attach(i),e&&this.setCamera(e),t&&this.setScene(t),o&&this.setTilesRenderer(o)}setScene(t){this.scene=t}setCamera(t){this.camera=t,this._upInitialized=!1,this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.needsUpdate=!0,this.raycaster.camera=t,this.resetState()}setTilesRenderer(t){console.warn('EnvironmentControls: "setTilesRenderer" has been deprecated. Use "setScene" and "setEllipsoid", instead.'),this.tilesRenderer=t,this.tilesRenderer!==null&&this.setScene(this.tilesRenderer.group)}attach(t){if(this.domElement)throw new Error("EnvironmentControls: Controls already attached to element");this.domElement=t,this.pointerTracker.domElement=t,t.style.touchAction="none";const e=n=>{this.enabled&&n.preventDefault()},i=n=>{if(!this.enabled)return;n.preventDefault();const{camera:l,raycaster:r,domElement:S,up:y,pivotMesh:p,pointerTracker:g,scene:W,pivotPoint:E,enabled:pt}=this;if(g.addPointer(n),this.needsUpdate=!0,g.isPointerTouch()){if(p.visible=!1,g.getPointerCount()===0)S.setPointerCapture(n.pointerId);else if(g.getPointerCount()>2){this.resetState();return}}g.getCenterPoint(_),U(_,S,_),w(r,_,l);const tt=Math.abs(r.ray.direction.dot(y));if(tt<G||tt<Y)return;const I=this._raycast(r);I&&(g.getPointerCount()===2||g.isRightClicked()||g.isLeftClicked()&&n.shiftKey?(this.setState(g.isPointerTouch()?Q:T),E.copy(I.point),p.position.copy(I.point),p.visible=g.isPointerTouch()?!1:pt,p.updateMatrixWorld(),W.add(p)):g.isLeftClicked()&&(this.setState(R),E.copy(I.point),p.position.copy(I.point),p.updateMatrixWorld(),W.add(p)))};let o=!1;const s=n=>{const{pointerTracker:l}=this;if(!this.enabled)return;n.preventDefault();const{pivotMesh:r,enabled:S}=this;this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.state!==C&&(this.needsUpdate=!0),l.setHoverEvent(n),l.updatePointer(n)&&(l.isPointerTouch()&&l.getPointerCount()===2&&(o||(o=!0,queueMicrotask(()=>{o=!1,l.getCenterPoint($);const y=l.getStartTouchPointerDistance(),p=l.getTouchPointerDistance(),g=p-y;if(this.state===C||this.state===Q){l.getCenterPoint($),l.getStartCenterPoint(nt);const W=2*window.devicePixelRatio,E=$.distanceTo(nt);(Math.abs(g)>W||E>W)&&(Math.abs(g)>E?(this.setState(A),this.zoomDirectionSet=!1):this.setState(T))}if(this.state===A){const W=l.getPreviousTouchPointerDistance();this.zoomDelta+=p-W,r.visible=!1}else this.state===T&&(r.visible=S)}))),this.dispatchEvent(rt))},d=n=>{const{pointerTracker:l}=this;!this.enabled||l.getPointerCount()===0||(l.deletePointer(n),l.getPointerType()==="touch"&&l.getPointerCount()===0&&t.releasePointerCapture(n.pointerId),this.resetState(),this.needsUpdate=!0)},a=n=>{if(!this.enabled)return;n.preventDefault();const{pointerTracker:l}=this;l.setHoverEvent(n),l.updatePointer(n),this.dispatchEvent(at);let r;switch(n.deltaMode){case 2:r=n.deltaY*800;break;case 1:r=n.deltaY*40;break;case 0:r=n.deltaY;break}const S=Math.sign(r),y=Math.abs(r);this.zoomDelta-=.25*S*y,this.needsUpdate=!0,this._lastUsedState=A,this.dispatchEvent(ct)},u=n=>{this.enabled&&this.resetState()};t.addEventListener("contextmenu",e),t.addEventListener("pointerdown",i),t.addEventListener("wheel",a,{passive:!1});const c=t.getRootNode();c.addEventListener("pointermove",s),c.addEventListener("pointerup",d),c.addEventListener("pointerleave",u),this._detachCallback=()=>{t.removeEventListener("contextmenu",e),t.removeEventListener("pointerdown",i),t.removeEventListener("wheel",a),c.removeEventListener("pointermove",s),c.removeEventListener("pointerup",d),c.removeEventListener("pointerleave",u)}}detach(){this.domElement=null,this._detachCallback&&(this._detachCallback(),this._detachCallback=null,this.pointerTracker.reset())}getUpDirection(t,e){e.copy(this.up)}getCameraUpDirection(t){this.getUpDirection(this.camera.position,t)}getPivotPoint(t){let e=null;this._lastUsedState===A?this._zoomPointWasSet&&(e=t.copy(this.zoomPoint)):(this._lastUsedState===T||this._lastUsedState===R)&&(e=t.copy(this.pivotPoint));const{camera:i,raycaster:o}=this;e!==null&&(h.copy(e).project(i),(h.x<-1||h.x>1||h.y<-1||h.y>1)&&(e=null)),w(o,{x:0,y:0},i);const s=this._raycast(o);return s&&(e===null||s.distance<e.distanceTo(o.ray.origin))&&(e=t.copy(s.point)),e}resetState(){this.state!==C&&this.dispatchEvent(ct),this.state=C,this.pivotMesh.removeFromParent(),this.pivotMesh.visible=this.enabled,this.actionHeightOffset=0,this.pointerTracker.reset()}setState(t=this.state,e=!0){this.state!==t&&(this.state===C&&e&&this.dispatchEvent(at),this.pivotMesh.visible=this.enabled,this.dragInertia.set(0,0,0),this.rotationInertia.set(0,0),this.inertiaStableFrames=0,this.state=t,t!==C&&t!==Q&&(this._lastUsedState=t))}update(t=Math.min(this.clock.getDelta(),64/1e3)){if(!this.enabled||!this.camera||t===0)return;const{camera:e,cameraRadius:i,pivotPoint:o,up:s,state:d,adjustHeight:a,autoAdjustCameraRotation:u}=this;e.updateMatrixWorld(),this.getCameraUpDirection(P),this._upInitialized||(this._upInitialized=!0,this.up.copy(P)),this.zoomPointSet=!1;const c=this._inertiaNeedsUpdate(),n=this.needsUpdate||c;if(this.needsUpdate||c){const r=this.zoomDelta;this._updateZoom(),this._updatePosition(t),this._updateRotation(t),d===R||d===T?(x.set(0,0,-1).transformDirection(e.matrixWorld),this.inertiaTargetDistance=h.copy(o).sub(e.position).dot(x)):d===C&&this._updateInertia(t),(d!==C||r!==0||c)&&this.dispatchEvent(rt),this.needsUpdate=!1}const l=e.isOrthographicCamera?null:a&&this._getPointBelowCamera()||null;if(this.getCameraUpDirection(P),this._setFrame(P),(this.state===R||this.state===T)&&this.actionHeightOffset!==0){const{actionHeightOffset:r}=this;e.position.addScaledVector(s,-r),o.addScaledVector(s,-r),l&&(l.distance-=r)}if(this.actionHeightOffset=0,l){const r=l.distance;if(r<i){const S=i-r;e.position.addScaledVector(s,S),o.addScaledVector(s,S),this.actionHeightOffset=S}}this.pointerTracker.updateFrame(),n&&u&&(this.getCameraUpDirection(P),this._alignCameraUp(P,1),this.getCameraUpDirection(P),this._clampRotation(P))}adjustCamera(t){const{adjustHeight:e,cameraRadius:i}=this;if(t.isPerspectiveCamera){this.getUpDirection(t.position,P);const o=e&&this._getPointBelowCamera(t.position,P)||null;if(o){const s=o.distance;s<i&&t.position.addScaledVector(P,i-s)}}}dispose(){this.detach()}_updateInertia(t){const{rotationInertia:e,pivotPoint:i,dragInertia:o,enableDamping:s,dampingFactor:d,camera:a,cameraRadius:u,minDistance:c,inertiaTargetDistance:n}=this;if(!this.enableDamping||this.inertiaStableFrames>1){o.set(0,0,0),e.set(0,0,0);return}const l=Math.pow(2,-t/d),r=Math.max(a.near,u,c,n),p=.25*(2/(2*1e3));if(e.lengthSq()>0){w(m,h.set(0,0,-1),a),m.applyMatrix4(a.matrixWorldInverse),m.direction.normalize(),m.recast(-m.direction.dot(m.origin)).at(r/m.direction.z,h),h.applyMatrix4(a.matrixWorld),w(m,D.set(p,p,-1),a),m.applyMatrix4(a.matrixWorldInverse),m.direction.normalize(),m.recast(-m.direction.dot(m.origin)).at(r/m.direction.z,D),D.applyMatrix4(a.matrixWorld),h.sub(i).normalize(),D.sub(i).normalize();const g=h.angleTo(D)/t;e.multiplyScalar(l),(e.lengthSq()<g**2||!s)&&e.set(0,0)}if(o.lengthSq()>0){w(m,h.set(0,0,-1),a),m.applyMatrix4(a.matrixWorldInverse),m.direction.normalize(),m.recast(-m.direction.dot(m.origin)).at(r/m.direction.z,h),h.applyMatrix4(a.matrixWorld),w(m,D.set(p,p,-1),a),m.applyMatrix4(a.matrixWorldInverse),m.direction.normalize(),m.recast(-m.direction.dot(m.origin)).at(r/m.direction.z,D),D.applyMatrix4(a.matrixWorld);const g=h.distanceTo(D)/t;o.multiplyScalar(l),(o.lengthSq()<g**2||!s)&&o.set(0,0,0)}e.lengthSq()>0&&this._applyRotation(e.x*t,e.y*t,i),o.lengthSq()>0&&(a.position.addScaledVector(o,t),a.updateMatrixWorld())}_inertiaNeedsUpdate(){const{rotationInertia:t,dragInertia:e}=this;return t.lengthSq()!==0||e.lengthSq()!==0}_updateZoom(){const{zoomPoint:t,zoomDirection:e,camera:i,minDistance:o,maxDistance:s,pointerTracker:d,domElement:a,minZoom:u,maxZoom:c,zoomSpeed:n,state:l}=this;let r=this.zoomDelta;if(this.zoomDelta=0,!(!d.getLatestPoint(_)||r===0&&l!==A))if(this.rotationInertia.set(0,0),this.dragInertia.set(0,0,0),i.isOrthographicCamera){this._updateZoomDirection();const S=this.zoomPointSet||this._updateZoomPoint();Z.unproject(i);const y=Math.pow(.95,Math.abs(r*.05));let p=r>0?1/Math.abs(y):y;p*=n,p>1?c<i.zoom*p&&(p=1):u>i.zoom*p&&(p=1),i.zoom*=p,i.updateProjectionMatrix(),S&&(U(_,a,X),X.unproject(i),i.position.sub(X).add(Z),i.updateMatrixWorld())}else{this._updateZoomDirection();const S=h.copy(e);if(this.zoomPointSet||this._updateZoomPoint()){const y=t.distanceTo(i.position);if(r<0){const p=Math.min(0,y-s);r=r*y*n*.0025,r=Math.max(r,p)}else{const p=Math.max(0,y-o);r=r*Math.max(y-o,0)*n*.0025,r=Math.min(r,p)}i.position.addScaledVector(e,r),i.updateMatrixWorld()}else{const y=this._getPointBelowCamera();if(y){const p=y.distance;S.set(0,0,-1).transformDirection(i.matrixWorld),i.position.addScaledVector(S,r*p*.01),i.updateMatrixWorld()}}}}_updateZoomDirection(){if(this.zoomDirectionSet)return;const{domElement:t,raycaster:e,camera:i,zoomDirection:o,pointerTracker:s}=this;s.getLatestPoint(_),U(_,t,Z),w(e,Z,i),o.copy(e.ray.direction).normalize(),this.zoomDirectionSet=!0}_updateZoomPoint(){const{camera:t,zoomDirectionSet:e,zoomDirection:i,raycaster:o,zoomPoint:s,pointerTracker:d,domElement:a}=this;if(this._zoomPointWasSet=!1,!e)return!1;t.isOrthographicCamera&&d.getLatestPoint(q)?(U(q,a,q),w(o,q,t)):(o.ray.origin.copy(t.position),o.ray.direction.copy(i),o.near=0,o.far=1/0);const u=this._raycast(o);return u?(s.copy(u.point),this.zoomPointSet=!0,this._zoomPointWasSet=!0,!0):!1}_getPointBelowCamera(t=this.camera.position,e=this.up){const{raycaster:i}=this;i.ray.direction.copy(e).multiplyScalar(-1),i.ray.origin.copy(t).addScaledVector(e,1e5),i.near=0,i.far=1/0;const o=this._raycast(i);return o&&(o.distance-=1e5),o}_updatePosition(t){const{raycaster:e,camera:i,pivotPoint:o,up:s,pointerTracker:d,domElement:a,state:u,dragInertia:c}=this;if(u===R){if(d.getCenterPoint(_),U(_,a,_),ot.setFromNormalAndCoplanarPoint(s,o),w(e,_,i),Math.abs(e.ray.direction.dot(s))<G){const n=Math.acos(G);j.crossVectors(e.ray.direction,s).normalize(),e.ray.direction.copy(s).applyAxisAngle(j,n).multiplyScalar(-1)}if(this.getUpDirection(o,P),Math.abs(e.ray.direction.dot(P))<Y){const n=Math.acos(Y);j.crossVectors(e.ray.direction,P).normalize(),e.ray.direction.copy(P).applyAxisAngle(j,n).multiplyScalar(-1)}e.ray.intersectPlane(ot,h)&&(D.subVectors(o,h),i.position.add(D),i.updateMatrixWorld(),D.multiplyScalar(1/t),d.getMoveDistance()/t<2*window.devicePixelRatio?this.inertiaStableFrames++:(c.copy(D),this.inertiaStableFrames=0))}}_updateRotation(t){const{pivotPoint:e,pointerTracker:i,domElement:o,state:s,rotationInertia:d}=this;s===T&&(i.getCenterPoint(_),i.getPreviousCenterPoint(st),O.subVectors(_,st).multiplyScalar(2*Math.PI/o.clientHeight),this._applyRotation(O.x,O.y,e),O.multiplyScalar(1/t),i.getMoveDistance()/t<2*window.devicePixelRatio?this.inertiaStableFrames++:(d.copy(O),this.inertiaStableFrames=0))}_applyRotation(t,e,i){if(t===0&&e===0)return;const{camera:o,minAltitude:s,maxAltitude:d,rotationSpeed:a}=this,u=-t*a;let c=e*a;x.set(0,0,1).transformDirection(o.matrixWorld),b.set(1,0,0).transformDirection(o.matrixWorld),this.getUpDirection(i,P);let n;P.dot(x)>1-1e-10?n=0:(h.crossVectors(P,x).normalize(),n=Math.sign(h.dot(b))*P.angleTo(x)),c>0?(c=Math.min(n-s,c),c=Math.max(0,c)):(c=Math.max(n-d,c),c=Math.min(0,c)),z.setFromAxisAngle(P,u),N(i,z,k),o.matrixWorld.premultiply(k),b.set(1,0,0).transformDirection(o.matrixWorld),z.setFromAxisAngle(b,-c),N(i,z,k),o.matrixWorld.premultiply(k),o.matrixWorld.decompose(o.position,o.quaternion,h)}_setFrame(t){const{up:e,camera:i,zoomPoint:o,zoomDirectionSet:s,zoomPointSet:d,scaleZoomOrientationAtEdges:a}=this;if(s&&(d||this._updateZoomPoint())){if(z.setFromUnitVectors(e,t),a){this.getUpDirection(o,h);let u=Math.max(h.dot(e)-.6,0)/.4;u=B.mapLinear(u,0,.5,0,1),u=Math.min(u,1),i.isOrthographicCamera&&(u*=.1),z.slerp(_t,1-u)}N(o,z,k),i.updateMatrixWorld(),i.matrixWorld.premultiply(k),i.matrixWorld.decompose(i.position,i.quaternion,h),this.zoomDirectionSet=!1,this._updateZoomDirection()}e.copy(t),i.updateMatrixWorld()}_raycast(t){const{scene:e,useFallbackPlane:i,fallbackPlane:o}=this,s=t.intersectObject(e)[0]||null;if(s)return s;if(i){const d=o;if(t.ray.intersectPlane(d,h))return{point:h.clone(),distance:t.ray.origin.distanceTo(h)}}return null}_alignCameraUp(t,e=1){const{camera:i,state:o,pivotPoint:s,zoomPoint:d,zoomPointSet:a}=this;i.updateMatrixWorld(),x.set(0,0,-1).transformDirection(i.matrixWorld),b.set(-1,0,0).transformDirection(i.matrixWorld);let u=B.mapLinear(1-Math.abs(x.dot(t)),0,.2,0,1);u=B.clamp(u,0,1),e*=u,K.crossVectors(t,x),K.lerp(b,1-e).normalize(),z.setFromUnitVectors(b,K),i.quaternion.premultiply(z);let c=null;o===R||o===T?c=L.copy(s):a&&(c=L.copy(d)),c&&(V.copy(i.matrixWorld).invert(),h.copy(c).applyMatrix4(V),i.updateMatrixWorld(),h.applyMatrix4(i.matrixWorld),H.subVectors(c,h),i.position.add(H)),i.updateMatrixWorld()}_clampRotation(t){const{camera:e,minAltitude:i,maxAltitude:o,state:s,pivotPoint:d,zoomPoint:a,zoomPointSet:u}=this;e.updateMatrixWorld(),x.set(0,0,1).transformDirection(e.matrixWorld),b.set(1,0,0).transformDirection(e.matrixWorld);let c;t.dot(x)>1-1e-10?c=0:(h.crossVectors(t,x),c=Math.sign(h.dot(b))*t.angleTo(x));let n;if(c>o)n=o;else if(c<i)n=i;else return;x.copy(t),z.setFromAxisAngle(b,n),x.applyQuaternion(z).normalize(),h.crossVectors(x,b).normalize(),k.makeBasis(b,h,x),e.quaternion.setFromRotationMatrix(k);let l=null;s===R||s===T?l=L.copy(d):u&&(l=L.copy(a)),l&&(V.copy(e.matrixWorld).invert(),h.copy(l).applyMatrix4(V),e.updateMatrixWorld(),h.applyMatrix4(e.matrixWorld),H.subVectors(l,h),e.position.add(H)),e.updateMatrixWorld()}}export{R as D,Mt as E,C as N,A as Z,U as a,N as m,w as s};
//# sourceMappingURL=EnvironmentControls-BRF5UI-K.js.map
