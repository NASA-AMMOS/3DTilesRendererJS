import"./modulepreload-polyfill-B5Qt9EMX.js";/* empty css               */import{T as W}from"./TilesRenderer-Bm042Xsy.js";import{C as z,t as N}from"./Ellipsoid-Dwquuq5w.js";import{W as P}from"./I3DMLoader-BWluRuWb.js";import{G as V}from"./GlobeControls-4ScISV7m.js";import{C as j}from"./CameraTransitionManager-DLsYaW0B.js";import{C as H}from"./plugins-DBdp9Zs1.js";import{m as $,n as A,o as R,p as J,h as Z,B as q,d as Q,q as Y,r as L,e as X,s as K,W as ee,S as te,a as ae,O as ie,M as T}from"./three.module-D-uF--xd.js";import{D as se}from"./DRACOLoader-gn1nzdEq.js";import{g as ne}from"./lil-gui.module.min-BH_YJbPT.js";import{S as re}from"./stats.module--VATS4Kh.js";import{T as oe}from"./TopoLinesPlugin-S7dTYZuX.js";import{L as ce}from"./TilesRendererBase-CFsQu8zV.js";import{F as le,G as de}from"./GLTFExtensionsPlugin-CGSNI2LM.js";import{T as he}from"./TileCompressionPlugin-wL72WIwu.js";import{U as ue}from"./UpdateOnChangePlugin-BPSehBEG.js";import{T as me}from"./TilesFadePlugin-BRcOjUD_.js";import"./BatchTable-CRr3zuRk.js";import"./B3DMLoader-Cnf0ja_2.js";import"./B3DMLoaderBase-w5mdSgm-.js";import"./GLTFLoader-B4GrkiON.js";import"./PNTSLoader-DwvZQNdL.js";import"./CMPTLoader-BOTrymv0.js";import"./EllipsoidRegion-VNvPMw5b.js";import"./constants-JFoaxC9y.js";import"./EnvironmentControls-BRF5UI-K.js";import"./GoogleCloudAuth-vMnc9CC1.js";import"./CesiumIonAuth-ByA9ya_o.js";import"./EPSGTilesPlugin-DX3n6hNw.js";import"./ImageFormatPlugin-DGN9sc3I.js";import"./TMSImageSource-BIqdNmly.js";import"./TiledImageSource-DmD64Gn9.js";import"./GeometryClipper-7b525s21.js";class pe{set delay(e){this.deferCallbacks.delay=e}get delay(){return this.deferCallbacks.delay}set bytesTarget(e){this.lruCache.minBytesSize=e}get bytesTarget(){return this.lruCache.minBytesSize}get estimatedGpuBytes(){return this.lruCache.cachedBytes}constructor(e={}){const{delay:t=0,bytesTarget:a=0}=e;this.name="UNLOAD_TILES_PLUGIN",this.tiles=null,this.lruCache=new ce,this.deferCallbacks=new ge,this.delay=t,this.bytesTarget=a}init(e){this.tiles=e;const{lruCache:t,deferCallbacks:a}=this;a.callback=r=>{t.markUnused(r),t.scheduleUnload(!1)};const s=r=>{const i=r.engineData.scene;e.visibleTiles.has(r)||e.invokeOnePlugin(c=>c.unloadTileFromGPU&&c.unloadTileFromGPU(i,r))};this._onUpdateBefore=()=>{t.unloadPriorityCallback=e.lruCache.unloadPriorityCallback,t.computeMemoryUsageCallback=e.lruCache.computeMemoryUsageCallback,t.minSize=1/0,t.maxSize=1/0,t.maxBytesSize=1/0,t.unloadPercent=1,t.autoMarkUnused=!1},this._onVisibilityChangeCallback=({tile:r,visible:i})=>{i?(t.add(r,s),e.markTileUsed(r),a.cancel(r)):a.run(r)},e.forEachLoadedModel((r,i)=>{const o=e.visibleTiles.has(i);this._onVisibilityChangeCallback({scene:r,visible:o})}),e.addEventListener("tile-visibility-change",this._onVisibilityChangeCallback),e.addEventListener("update-before",this._onUpdateBefore)}unloadTileFromGPU(e,t){e&&e.traverse(a=>{if(a.material){const s=a.material;s.dispose();for(const r in s){const i=s[r];i&&i.isTexture&&i.dispose()}}a.geometry&&a.geometry.dispose()})}dispose(){this.tiles.removeEventListener("tile-visibility-change",this._onVisibilityChangeCallback),this.tiles.removeEventListener("update-before",this._onUpdateBefore),this.deferCallbacks.cancelAll()}}class ge{constructor(e=()=>{}){this.map=new Map,this.callback=e,this.delay=0}run(e){const{map:t,delay:a}=this;if(t.has(e))throw new Error("DeferCallbackManager: Callback already initialized.");a===0?this.callback(e):t.set(e,setTimeout(()=>this.callback(e),a))}cancel(e){const{map:t}=this;t.has(e)&&(clearTimeout(t.get(e)),t.delete(e))}cancelAll(){this.map.forEach((e,t)=>{this.cancel(t)})}}const v=new A,B=new R,F=new R;class fe extends ${constructor(...e){super(...e),this.resetDistance=1e4,this._matricesTextureHandle=null,this._lastCameraPos=new A,this._forceUpdate=!0,this._matrices=[]}setMatrixAt(e,t){super.setMatrixAt(e,t),this._forceUpdate=!0;const a=this._matrices;for(;a.length<=e;)a.push(new A);a[e].copy(t)}setInstanceCount(...e){super.setInstanceCount(...e);const t=this._matrices;for(;t.length>this.instanceCount;)t.pop()}onBeforeRender(e,t,a,s,r,i){super.onBeforeRender(e,t,a,s,r,i),B.setFromMatrixPosition(a.matrixWorld),F.setFromMatrixPosition(this._lastCameraPos);const o=this._matricesTexture;let c=this._modelViewMatricesTexture;if((!c||c.image.width!==o.image.width||c.image.height!==o.image.height)&&(c&&c.dispose(),c=o.clone(),c.source=new J({...c.image,data:c.image.data.slice()}),this._modelViewMatricesTexture=c),this._forceUpdate||B.distanceTo(F)>this.resetDistance){const h=this._matrices,m=c.image.data;for(let p=0;p<this.maxInstanceCount;p++){const f=h[p];f?v.copy(f):v.identity(),v.premultiply(this.matrixWorld).premultiply(a.matrixWorldInverse).toArray(m,p*16)}c.needsUpdate=!0,this._lastCameraPos.copy(a.matrixWorld),this._forceUpdate=!1}this._matricesTextureHandle=this._matricesTexture,this._matricesTexture=this._modelViewMatricesTexture,this.matrixWorld.copy(this._lastCameraPos)}onAfterRender(){this.updateMatrixWorld(),this._matricesTexture=this._matricesTextureHandle,this._matricesTextureHandle=null}onAfterShadow(e,t,a,s,r,i){this.onAfterRender(e,null,s,r,i)}dispose(){super.dispose(),this._modelViewMatricesTexture&&this._modelViewMatricesTexture.dispose()}}const C=new Z,w=[];class xe extends fe{constructor(...e){super(...e),this.expandPercent=.25,this.maxInstanceExpansionSize=1/0,this._freeGeometryIds=[]}findFreeId(e,t,a){const s=!!this.geometry.index,r=Math.max(s?e.index.count:-1,a),i=Math.max(e.attributes.position.count,t);let o=-1,c=1/0;const h=this._freeGeometryIds;if(h.forEach((m,p)=>{const f=this.getGeometryRangeAt(m),{reservedIndexCount:g,reservedVertexCount:x}=f;if(g>=r&&x>=i){const M=r-g+(i-x);M<c&&(o=p,c=M)}}),o!==-1){const m=h[o];return h.splice(o,1),m}else return-1}addGeometry(e,t,a){const s=!!this.geometry.index;a=Math.max(s?e.index.count:-1,a),t=Math.max(e.attributes.position.count,t);const{expandPercent:r,_freeGeometryIds:i}=this;let o=this.findFreeId(e,t,a);if(o!==-1)this.setGeometryAt(o,e);else{const c=()=>{const p=this.unusedVertexCount<t,f=this.unusedIndexCount<a;return p||f},h=e.index,m=e.attributes.position;if(t=Math.max(t,m.count),a=Math.max(a,h?h.count:0),c()&&(i.forEach(p=>this.deleteGeometry(p)),i.length=0,this.optimize(),c())){const p=this.geometry.index,f=this.geometry.attributes.position;let g,x;if(p){const M=Math.ceil(r*p.count);g=Math.max(M,a,h.count)+p.count}else g=Math.max(this.unusedIndexCount,a);if(f){const M=Math.ceil(r*f.count);x=Math.max(M,t,m.count)+f.count}else x=Math.max(this.unusedVertexCount,t);this.setGeometrySize(x,g)}o=super.addGeometry(e,t,a)}return o}addInstance(e){if(this.maxInstanceCount===this.instanceCount){const t=Math.ceil(this.maxInstanceCount*(1+this.expandPercent));this.setInstanceCount(Math.min(t,this.maxInstanceExpansionSize))}return super.addInstance(e)}deleteInstance(e){const t=this.getGeometryIdAt(e);return t!==-1&&this._freeGeometryIds.push(t),super.deleteInstance(e)}raycastInstance(e,t,a){const s=this.geometry,r=this.getGeometryIdAt(e);C.material=this.material,C.geometry.index=s.index,C.geometry.attributes=s.attributes;const i=this.getGeometryRangeAt(r);C.geometry.setDrawRange(i.start,i.count),C.geometry.boundingBox===null&&(C.geometry.boundingBox=new q),C.geometry.boundingSphere===null&&(C.geometry.boundingSphere=new Q),this.getMatrixAt(e,C.matrixWorld).premultiply(this.matrixWorld),this.getBoundingBoxAt(r,C.geometry.boundingBox),this.getBoundingSphereAt(r,C.geometry.boundingSphere),C.raycast(t,w);for(let o=0,c=w.length;o<c;o++){const h=w[o];h.object=this,h.batchId=e,a.push(h)}w.length=0}}function ye(l){return l.r===1&&l.g===1&&l.b===1}function Ce(l){l.needsUpdate=!0,l.onBeforeCompile=e=>{e.vertexShader=e.vertexShader.replace("#include <common>",`
				#include <common>
				varying float texture_index;
				`).replace("#include <uv_vertex>",`
				#include <uv_vertex>
				texture_index = getIndirectIndex( gl_DrawID );
				`),e.fragmentShader=e.fragmentShader.replace("#include <map_pars_fragment>",`
				#ifdef USE_MAP
				precision highp sampler2DArray;
				uniform sampler2DArray map;
				varying float texture_index;
				#endif
				`).replace("#include <map_fragment>",`
				#ifdef USE_MAP
					diffuseColor *= texture( map, vec3( vMapUv, texture_index ) );
				#endif
				`)}}const E=new le(new K),D=new X(new Uint8Array([255,255,255,255]),1,1);D.needsUpdate=!0;class Te{constructor(e={}){if(parseInt(Y)<170)throw new Error("BatchedTilesPlugin: Three.js revision 170 or higher required.");e={instanceCount:500,vertexCount:750,indexCount:2e3,expandPercent:.25,maxInstanceCount:1/0,discardOriginalContent:!0,textureSize:null,material:null,renderer:null,...e},this.name="BATCHED_TILES_PLUGIN",this.priority=-1;const t=e.renderer.getContext();this.instanceCount=e.instanceCount,this.vertexCount=e.vertexCount,this.indexCount=e.indexCount,this.material=e.material?e.material.clone():null,this.expandPercent=e.expandPercent,this.maxInstanceCount=Math.min(e.maxInstanceCount,t.getParameter(t.MAX_3D_TEXTURE_SIZE)),this.renderer=e.renderer,this.discardOriginalContent=e.discardOriginalContent,this.textureSize=e.textureSize,this.batchedMesh=null,this.arrayTarget=null,this.tiles=null,this._onLoadModel=null,this._onDisposeModel=null,this._onVisibilityChange=null,this._tileToInstanceId=new Map}init(e){this._onDisposeModel=({scene:t,tile:a})=>{this.removeSceneFromBatchedMesh(t,a)},e.addEventListener("dispose-model",this._onDisposeModel),this.tiles=e}initTextureArray(e){if(this.arrayTarget!==null||e.material.map===null)return;const{instanceCount:t,renderer:a,textureSize:s,batchedMesh:r}=this,i=e.material.map,o={colorSpace:i.colorSpace,wrapS:i.wrapS,wrapT:i.wrapT,wrapR:i.wrapS,magFilter:i.magFilter},c=new L(s||i.image.width,s||i.image.height,t);Object.assign(c.texture,o),a.initRenderTarget(c),r.material.map=c.texture,this.arrayTarget=c,this._tileToInstanceId.forEach(h=>{h.forEach(m=>{this.assignTextureToLayer(D,m)})})}initBatchedMesh(e){if(this.batchedMesh!==null)return;const{instanceCount:t,vertexCount:a,indexCount:s,tiles:r}=this,i=this.material?this.material:new e.material.constructor,o=new xe(t,t*a,t*s,i);o.name="BatchTilesPlugin",o.frustumCulled=!1,r.group.add(o),o.updateMatrixWorld(),Ce(o.material),this.batchedMesh=o}setTileVisible(e,t){const a=e.engineData.scene;if(t&&this.addSceneToBatchedMesh(a,e),this._tileToInstanceId.has(e)){this._tileToInstanceId.get(e).forEach(i=>{this.batchedMesh.setVisibleAt(i,t)});const r=this.tiles;return t?r.visibleTiles.add(e):r.visibleTiles.delete(e),r.dispatchEvent({type:"tile-visibility-change",scene:a,tile:e,visible:t}),!0}return!1}unloadTileFromGPU(e,t){return!this.discardOriginalContent&&this._tileToInstanceId.has(t)?(this.removeSceneFromBatchedMesh(e,t),!0):!1}assignTextureToLayer(e,t){if(!this.arrayTarget)return;this.expandArrayTargetIfNeeded();const{renderer:a}=this,s=a.getRenderTarget();a.setRenderTarget(this.arrayTarget,t),E.material.map=e,E.render(a),a.setRenderTarget(s),E.material.map=null,e.dispose()}expandArrayTargetIfNeeded(){const{batchedMesh:e,arrayTarget:t,renderer:a}=this,s=Math.min(e.maxInstanceCount,this.maxInstanceCount);if(s>t.depth){const r={colorSpace:t.texture.colorSpace,wrapS:t.texture.wrapS,wrapT:t.texture.wrapT,generateMipmaps:t.texture.generateMipmaps,minFilter:t.texture.minFilter,magFilter:t.texture.magFilter},i=new L(t.width,t.height,s);Object.assign(i.texture,r),a.initRenderTarget(i),a.copyTextureToTexture(t.texture,i.texture),t.dispose(),e.material.map=i.texture,this.arrayTarget=i}}removeSceneFromBatchedMesh(e,t){if(this._tileToInstanceId.has(t)){const a=this._tileToInstanceId.get(t);this._tileToInstanceId.delete(t),a.forEach(s=>{this.batchedMesh.deleteInstance(s)})}}addSceneToBatchedMesh(e,t){if(this._tileToInstanceId.has(t))return;const a=[];e.traverse(i=>{i.isMesh&&a.push(i)});let s=!0;a.forEach(i=>{if(this.batchedMesh&&s){const o=i.geometry.attributes,c=this.batchedMesh.geometry.attributes;for(const h in c)if(!(h in o)){s=!1;return}}});const r=!this.batchedMesh||this.batchedMesh.instanceCount+a.length<=this.maxInstanceCount;if(s&&r){e.updateMatrixWorld();const i=[];this._tileToInstanceId.set(t,i),a.forEach(o=>{this.initBatchedMesh(o),this.initTextureArray(o);const{geometry:c,material:h}=o,{batchedMesh:m,expandPercent:p}=this;m.expandPercent=p;const f=m.addGeometry(c,this.vertexCount,this.indexCount),g=m.addInstance(f);i.push(g),m.setMatrixAt(g,o.matrixWorld),m.setVisibleAt(g,!1),ye(h.color)||(h.color.setHSL(Math.random(),.5,.5),m.setColorAt(g,h.color));const x=h.map;x?this.assignTextureToLayer(x,g):this.assignTextureToLayer(D,g)}),this.discardOriginalContent&&(t.engineData.textures.forEach(o=>{o.image instanceof ImageBitmap&&o.image.close()}),t.engineData.scene=null,t.engineData.materials=[],t.engineData.geometries=[],t.engineData.textures=[])}}raycastTile(e,t,a,s){return this._tileToInstanceId.has(e)?(this._tileToInstanceId.get(e).forEach(i=>{this.batchedMesh.raycastInstance(i,a,s)}),!0):!1}dispose(){const{arrayTarget:e,tiles:t,batchedMesh:a}=this;e&&e.dispose(),a&&(a.material.dispose(),a.geometry.dispose(),a.dispose(),a.removeFromParent()),t.removeEventListener("dispose-model",this._onDisposeModel)}getTileBatchIds(e){return this._tileToInstanceId.get(e)}}let b,I,y,n,d,S,_;const u={orthographic:!1,optimizedLoadStrategy:!1,loadSiblings:!0,enableCacheDisplay:!1,enableRendererStats:!1,useBatchedMesh:!!new URLSearchParams(window.location.hash.replace(/^#/,"")).get("batched"),useFadePlugin:!0,displayTopoLines:!1,errorTarget:20,reload:O};be();k();function O(){n&&(I.remove(n.group),n.dispose(),n=null),n=new W,n.lruCache.minSize=0,n.registerPlugin(new H({apiToken:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI3MGNiODVmZS1hNzliLTQ5NWYtOTdhOS02ZmIzMmZlYWRlMzAiLCJpZCI6MjY3NzgzLCJpYXQiOjE3MzY0Mjg0MTJ9.o7EtbJyQ6yNAgfHFal1RS1BKKM-RmZNusqBCeiowNZo",assetId:"2275207",autoRefreshToken:!0})),n.registerPlugin(new he),n.registerPlugin(new ue),n.registerPlugin(new pe),n.registerPlugin(new oe({projection:"ellipsoid"})),n.registerPlugin(new de({dracoLoader:new se().setDecoderPath("https://unpkg.com/three@0.153.0/examples/jsm/libs/draco/gltf/")})),n.optimizedLoadStrategy=u.optimizedLoadStrategy,n.loadSiblings=u.loadSiblings,u.useFadePlugin&&n.registerPlugin(new me),u.useBatchedMesh&&n.registerPlugin(new Te({renderer:y,discardOriginalContent:!1,instanceCount:250})),n.group.rotation.x=-Math.PI/2,I.add(n.group),n.setResolutionFromRenderer(d.camera,y),n.setCamera(d.camera),b.setEllipsoid(n.ellipsoid,n.group)}function be(){y=new ee({antialias:!0}),y.setClearColor(1383455),document.body.appendChild(y.domElement),I=new te,d=new j(new ae(60,window.innerWidth/window.innerHeight,1,16e7),new ie(-1,1,1,-1,1,16e7)),d.perspectiveCamera.position.set(48e5,257e4,1472e4),d.perspectiveCamera.lookAt(0,0,0),d.autoSync=!1,d.addEventListener("camera-change",({camera:a,prevCamera:s})=>{n.deleteCamera(s),n.setCamera(a),b.setCamera(a)}),d.orthographicPositionalZoom=!1,b=new V(I,d.camera,y.domElement,null),b.enableDamping=!0,O(),G(),window.addEventListener("resize",G,!1),window.addEventListener("hashchange",U);const l=new ne;l.width=300,l.add(u,"orthographic").onChange(a=>{b.getPivotPoint(d.fixedPoint),d.animating||(d.syncCameras(),b.adjustCamera(d.perspectiveCamera),b.adjustCamera(d.orthographicCamera)),d.toggle()});const e=l.addFolder("Google Photorealistic Tiles");new URLSearchParams(window.location.search).has("showOptimizedSettings")&&(u.optimizedLoadStrategy=!0,n.optimizedLoadStrategy=!0,e.add(u,"optimizedLoadStrategy").listen(),e.add(u,"loadSiblings").listen()),e.add(u,"useBatchedMesh").listen(),e.add(u,"useFadePlugin").listen(),e.add(u,"reload");const t=l.addFolder("Example Options");t.add(u,"displayTopoLines").listen(),t.add(u,"enableCacheDisplay"),t.add(u,"enableRendererStats"),t.add(u,"errorTarget",5,100,1).onChange(()=>{n.getPluginByName("UPDATE_ON_CHANGE_PLUGIN").needsUpdate=!0}),S=document.createElement("div"),document.getElementById("info").appendChild(S),_=new re,_.showPanel(0),document.body.appendChild(_.dom),U(),setInterval(Me,100)}function G(){const{perspectiveCamera:l,orthographicCamera:e}=d,t=window.innerWidth/window.innerHeight;l.aspect=t,l.updateProjectionMatrix(),e.left=-e.top*t,e.right=-e.left,e.updateProjectionMatrix(),y.setSize(window.innerWidth,window.innerHeight),y.setPixelRatio(window.devicePixelRatio)}function Me(){if(!n)return;d.mode!=="perspective"&&!d.animating&&(b.getPivotPoint(d.fixedPoint),d.syncCameras());const l=d.perspectiveCamera,e={},t=n.group.matrixWorld.clone().invert(),a=l.matrixWorld.clone().premultiply(t);P.getCartographicFromObjectFrame(a,e,z),e.azimuth*=T.RAD2DEG,e.elevation*=T.RAD2DEG,e.roll*=T.RAD2DEG,e.lat*=T.RAD2DEG,e.lon*=T.RAD2DEG;const s=new URLSearchParams;s.set("lat",e.lat.toFixed(4)),s.set("lon",e.lon.toFixed(4)),s.set("height",e.height.toFixed(2)),s.set("az",e.azimuth.toFixed(2)),s.set("el",e.elevation.toFixed(2)),s.set("roll",e.roll.toFixed(2)),u.useBatchedMesh&&s.set("batched",1),window.history.replaceState(void 0,void 0,`#${s}`)}function U(){const l=window.location.hash.replace(/^#/,""),e=new URLSearchParams(l);if(e.has("batched")&&(u.useBatchedMesh=!!e.get("batched")),!e.has("lat")&&!e.has("lon"))return;n.group.updateMatrixWorld();const t=d.perspectiveCamera,a=parseFloat(e.get("lat")),s=parseFloat(e.get("lon")),r=parseFloat(e.get("height"))||1e3;if(e.has("az")&&e.has("el")){const i=parseFloat(e.get("az")),o=parseFloat(e.get("el")),c=parseFloat(e.get("roll"))||0;P.getObjectFrame(a*T.DEG2RAD,s*T.DEG2RAD,r,i*T.DEG2RAD,o*T.DEG2RAD,c*T.DEG2RAD,t.matrixWorld,z),t.matrixWorld.premultiply(n.group.matrixWorld),t.matrixWorld.decompose(t.position,t.quaternion,t.scale)}else P.getCartographicToPosition(a*T.DEG2RAD,s*T.DEG2RAD,r,t.position),t.position.applyMatrix4(n.group.matrixWorld),t.lookAt(0,0,0);if(d.mode!=="perspective"){const i=d.mode;d.mode="perspective",d.syncCameras(),d.mode=i}}function k(){if(requestAnimationFrame(k),!n)return;I.updateMatrixWorld(),b.enabled=!d.animating,b.update(),d.update();const l=d.camera;n.setResolutionFromRenderer(l,y),n.setCamera(l);const e=n.getPluginByName("TOPO_LINES_PLUGIN");e.topoOpacity=u.displayTopoLines?.5:0,e.cartoOpacity=u.displayTopoLines?.5:0,l.updateMatrixWorld(),n.errorTarget=u.errorTarget,n.update(),y.render(I,l),_.update(),Ie()}function Ie(){var r,i,o;let l="";if(u.enableCacheDisplay){const c=n.lruCache,h=c.cachedBytes/c.maxBytesSize;l+=`Queued: ${n.stats.queued} Downloading: ${n.stats.downloading} Parsing: ${n.stats.parsing} Loaded: ${n.stats.loaded}<br/>Visible: ${n.visibleTiles.size} Active: ${n.activeTiles.size}<br/>`,l+=`Cache: ${(100*h).toFixed(2)}% ~${(c.cachedBytes/1e3/1e3).toFixed(2)}mb<br/>`}if(u.enableRendererStats){const c=y.info.memory,h=y.info.render,m=y.info.programs.length;l+=`Geometries: ${c.geometries} Textures: ${c.textures} Programs: ${m} Draw Calls: ${h.calls}`;const p=n.getPluginByName("BATCHED_TILES_PLUGIN"),f=n.getPluginByName("FADE_TILES_PLUGIN");if(p){let g=0;(r=p.batchedMesh)==null||r._instanceInfo.forEach(x=>{x.visible&&x.active&&g++}),(i=f==null?void 0:f.batchedMesh)==null||i._instanceInfo.forEach(x=>{x.visible&&x.active&&g++}),l+=", Batched: "+g}}S.innerHTML!==l&&(S.innerHTML=l);const e=n.group.matrixWorld.clone().invert(),t=d.camera.position.clone().applyMatrix4(e),a={};P.getPositionToCartographic(t,a);const s=((o=n.getAttributions()[0])==null?void 0:o.value)||"";document.getElementById("credits").innerText=N(a.lat,a.lon)+`
`+s}
//# sourceMappingURL=googleMapsExample-hR_MLlaW.js.map
