{"version":3,"file":"TiledImageSource-DmD64Gn9.js","sources":["../../../src/three/plugins/images/utils/ProjectionScheme.js","../../../src/three/plugins/images/utils/DataCache.js","../../../src/three/plugins/images/utils/TilingScheme.js","../../../src/three/plugins/images/sources/TiledImageSource.js"],"sourcesContent":["import { MathUtils } from 'three';\n\n// Class for storing and querying a certain projection scheme for an image and converting\n// between the [0, 1] image range to cartographic longitude / latitude values.\nexport class ProjectionScheme {\n\n\tget isMercator() {\n\n\t\treturn this.scheme === 'EPSG:3857';\n\n\t}\n\n\tconstructor( scheme = 'EPSG:4326' ) {\n\n\t\tthis.scheme = scheme;\n\t\tthis.tileCountX = 1;\n\t\tthis.tileCountY = 1;\n\n\t\tthis.setScheme( scheme );\n\n\t}\n\n\tsetScheme( scheme ) {\n\n\t\tthis.scheme = scheme;\n\t\tswitch ( scheme ) {\n\n\t\t\t// equirect\n\t\t\tcase 'CRS:84':\n\t\t\tcase 'EPSG:4326':\n\t\t\t\tthis.tileCountX = 2;\n\t\t\t\tthis.tileCountY = 1;\n\t\t\t\tbreak;\n\n\t\t\t// mercator\n\t\t\tcase 'EPSG:3857':\n\t\t\t\tthis.tileCountX = 1;\n\t\t\t\tthis.tileCountY = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'none':\n\t\t\t\tthis.tileCountX = 1;\n\t\t\t\tthis.tileCountY = 1;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( `ProjectionScheme: Unknown projection scheme \"${ scheme }\"` );\n\n\t\t}\n\n\t}\n\n\tconvertNormalizedToLatitude( v ) {\n\n\t\tif ( this.scheme === 'none' ) {\n\n\t\t\treturn v;\n\n\t\t} else if ( this.isMercator ) {\n\n\t\t\t// https://gis.stackexchange.com/questions/447421/convert-a-point-on-a-flat-2d-web-mercator-map-image-to-a-coordinate\n\t\t\tconst ratio = MathUtils.mapLinear( v, 0, 1, - 1, 1 );\n\t\t\treturn 2 * Math.atan( Math.exp( ratio * Math.PI ) ) - Math.PI / 2;\n\n\t\t} else {\n\n\t\t\treturn MathUtils.mapLinear( v, 0, 1, - Math.PI / 2, Math.PI / 2 );\n\n\t\t}\n\n\t}\n\n\tconvertNormalizedToLongitude( v ) {\n\n\t\tif ( this.scheme === 'none' ) {\n\n\t\t\treturn v;\n\n\t\t} else {\n\n\t\t\treturn MathUtils.mapLinear( v, 0, 1, - Math.PI, Math.PI );\n\n\t\t}\n\n\t}\n\n\tconvertLatitudeToNormalized( lat ) {\n\n\t\tif ( this.scheme === 'none' ) {\n\n\t\t\treturn lat;\n\n\t\t} else if ( this.isMercator ) {\n\n\t\t\t// https://stackoverflow.com/questions/14329691/convert-latitude-longitude-point-to-a-pixels-x-y-on-mercator-projection\n\t\t\tconst mercatorN = Math.log( Math.tan( ( Math.PI / 4 ) + ( lat / 2 ) ) );\n\t\t\treturn ( 1 / 2 ) + ( 1 * mercatorN / ( 2 * Math.PI ) );\n\n\t\t} else {\n\n\t\t\treturn MathUtils.mapLinear( lat, - Math.PI / 2, Math.PI / 2, 0, 1 );\n\n\t\t}\n\n\t}\n\n\tconvertLongitudeToNormalized( lon ) {\n\n\t\tif ( this.scheme === 'none' ) {\n\n\t\t\treturn lon;\n\n\t\t} else {\n\n\t\t\treturn ( lon + Math.PI ) / ( 2 * Math.PI );\n\n\t\t}\n\n\t}\n\n\tgetLongitudeDerivativeAtNormalized( value ) {\n\n\t\tif ( this.scheme === 'none' ) {\n\n\t\t\treturn 1;\n\n\t\t} else {\n\n\t\t\treturn 2 * Math.PI;\n\n\t\t}\n\n\t}\n\n\tgetLatitudeDerivativeAtNormalized( value ) {\n\n\t\tif ( this.scheme === 'none' ) {\n\n\t\t\treturn 1;\n\n\t\t} else {\n\n\t\t\tconst EPS = 1e-5;\n\t\t\tlet yp = value - EPS;\n\t\t\tif ( yp < 0 ) {\n\n\t\t\t\typ = value + EPS;\n\n\t\t\t}\n\n\t\t\tif ( this.isMercator ) {\n\n\t\t\t\t// TODO: why is this 2 * Math.PI rather than Math.PI?\n\t\t\t\treturn Math.abs( this.convertNormalizedToLatitude( value ) - this.convertNormalizedToLatitude( yp ) ) / EPS;\n\n\t\t\t} else {\n\n\t\t\t\treturn Math.PI;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tgetBounds() {\n\n\t\tif ( this.scheme === 'none' ) {\n\n\t\t\treturn [ 0, 0, 1, 1 ];\n\n\t\t} else {\n\n\t\t\treturn [\n\t\t\t\tthis.convertNormalizedToLongitude( 0 ), this.convertNormalizedToLatitude( 0 ),\n\t\t\t\tthis.convertNormalizedToLongitude( 1 ), this.convertNormalizedToLatitude( 1 ),\n\t\t\t];\n\n\t\t}\n\n\t}\n\n\ttoNormalizedPoint( x, y ) {\n\n\t\tconst result = [ x, y ];\n\t\tresult[ 0 ] = this.convertLongitudeToNormalized( result[ 0 ] );\n\t\tresult[ 1 ] = this.convertLatitudeToNormalized( result[ 1 ] );\n\n\t\treturn result;\n\n\t}\n\n\ttoNormalizedRange( range ) {\n\n\t\treturn [\n\t\t\t...this.toNormalizedPoint( range[ 0 ], range[ 1 ] ),\n\t\t\t...this.toNormalizedPoint( range[ 2 ], range[ 3 ] ),\n\t\t];\n\n\t}\n\n\ttoCartographicPoint( x, y ) {\n\n\t\tconst result = [ x, y ];\n\t\tresult[ 0 ] = this.convertNormalizedToLongitude( result[ 0 ] );\n\t\tresult[ 1 ] = this.convertNormalizedToLatitude( result[ 1 ] );\n\n\t\treturn result;\n\n\t}\n\n\ttoCartographicRange( range ) {\n\n\t\treturn [\n\t\t\t...this.toCartographicPoint( range[ 0 ], range[ 1 ] ),\n\t\t\t...this.toCartographicPoint( range[ 2 ], range[ 3 ] ),\n\t\t];\n\n\t}\n\n\tclampToBounds( range, normalized = false ) {\n\n\t\tconst result = [ ...range ];\n\t\tlet clampBounds;\n\n\t\tif ( normalized ) {\n\n\t\t\tclampBounds = [ 0, 0, 1, 1 ];\n\n\t\t} else {\n\n\t\t\tclampBounds = this.getBounds();\n\n\t\t}\n\n\t\tconst [ minX, minY, maxX, maxY ] = clampBounds;\n\t\tresult[ 0 ] = MathUtils.clamp( result[ 0 ], minX, maxX );\n\t\tresult[ 1 ] = MathUtils.clamp( result[ 1 ], minY, maxY );\n\t\tresult[ 2 ] = MathUtils.clamp( result[ 2 ], minX, maxX );\n\t\tresult[ 3 ] = MathUtils.clamp( result[ 3 ], minY, maxY );\n\n\t\treturn result;\n\n\t}\n\n}\n","function hash( ...args ) {\n\n\treturn args.join( '_' );\n\n}\n\n// class for retrieving and locking data being requested\n// \"fetchItem\" and \"disposeItem\" should be implemented\nexport class DataCache {\n\n\tconstructor() {\n\n\t\tthis.cache = {};\n\t\tthis.count = 0;\n\t\tthis.cachedBytes = 0;\n\t\tthis.active = 0;\n\n\t}\n\n\t// overridable\n\tfetchItem() {}\n\tdisposeItem() {}\n\tgetMemoryUsage( item ) {\n\n\t\treturn 0;\n\n\t}\n\n\t// sets the data in the cache explicitly without need to load\n\tsetData( ...args ) {\n\n\t\tconst { cache } = this;\n\t\tconst data = args.pop();\n\t\tconst key = hash( ...args );\n\t\tif ( key in cache ) {\n\n\t\t\tthrow new Error( `DataCache: \"${ key }\" is already present.` );\n\n\t\t} else {\n\n\t\t\tthis.cache[ key ] = {\n\t\t\t\tabortController: new AbortController(),\n\t\t\t\tresult: data,\n\t\t\t\tcount: 1,\n\t\t\t\tbytes: this.getMemoryUsage( data ),\n\t\t\t};\n\t\t\tthis.count ++;\n\t\t\tthis.cachedBytes += this.cache[ key ].bytes;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\t// fetches the associated data if it doesn't exist and increments the lock counter\n\tlock( ...args ) {\n\n\t\tconst { cache } = this;\n\t\tconst key = hash( ...args );\n\t\tif ( key in cache ) {\n\n\t\t\tcache[ key ].count ++;\n\n\t\t} else {\n\n\t\t\tconst abortController = new AbortController();\n\t\t\tconst info = {\n\t\t\t\tabortController,\n\t\t\t\tresult: null,\n\t\t\t\tcount: 1,\n\t\t\t\tbytes: 0,\n\t\t\t\targs,\n\t\t\t};\n\n\t\t\tthis.active ++;\n\t\t\tinfo.result = this.fetchItem( args, abortController.signal );\n\t\t\tif ( info.result instanceof Promise ) {\n\n\t\t\t\tinfo.result.then( res => {\n\n\t\t\t\t\tinfo.result = res;\n\t\t\t\t\tinfo.bytes = this.getMemoryUsage( res );\n\t\t\t\t\tthis.cachedBytes += info.bytes;\n\t\t\t\t\treturn res;\n\n\t\t\t\t} ).finally( () => {\n\n\t\t\t\t\tthis.active --;\n\n\t\t\t\t} ).catch( e => {\n\n\t\t\t\t\t// error logging and handling can be handled elsewhere\n\n\t\t\t\t} );\n\n\t\t\t} else {\n\n\t\t\t\tthis.active --;\n\t\t\t\tinfo.bytes = this.getMemoryUsage( info.result );\n\t\t\t\tthis.cachedBytes += info.bytes;\n\n\t\t\t}\n\n\t\t\tthis.cache[ key ] = info;\n\t\t\tthis.count ++;\n\n\t\t}\n\n\t\treturn cache[ key ].result;\n\n\t}\n\n\t// decrements the lock counter for the item and deletes the item if it has reached zero\n\trelease( ...args ) {\n\n\t\tconst key = hash( ...args );\n\t\tthis.releaseViaFullKey( key );\n\n\t}\n\n\t// get the loaded item\n\tget( ...args ) {\n\n\t\tconst { cache } = this;\n\t\tconst key = hash( ...args );\n\t\tif ( key in cache && cache[ key ].count > 0 ) {\n\n\t\t\treturn cache[ key ].result;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\thas( ...args ) {\n\n\t\tconst { cache } = this;\n\t\tconst key = hash( ...args );\n\t\treturn key in cache;\n\n\t}\n\n\tforEachItem( cb ) {\n\n\t\tconst { cache } = this;\n\t\tfor ( const key in cache ) {\n\n\t\t\tconst info = cache[ key ];\n\t\t\tif ( ! ( info.result instanceof Promise ) ) {\n\n\t\t\t\tcb( info.result, info.args );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// dispose all items\n\tdispose() {\n\n\t\tconst { cache } = this;\n\t\tfor ( const key in cache ) {\n\n\t\t\tconst { abortController } = cache[ key ];\n\t\t\tabortController.abort();\n\n\t\t\tthis.releaseViaFullKey( key, true );\n\n\t\t}\n\n\t\tthis.cache = {};\n\n\t}\n\n\t// releases an item with an optional force flag\n\treleaseViaFullKey( key, force = false ) {\n\n\t\tconst { cache } = this;\n\t\tif ( key in cache && cache[ key ].count > 0 ) {\n\n\t\t\t// decrement the lock\n\t\t\tconst info = cache[ key ];\n\t\t\tinfo.count --;\n\n\t\t\t// if the item is no longer being used\n\t\t\tif ( info.count === 0 || force ) {\n\n\t\t\t\tconst disposeCallback = () => {\n\n\t\t\t\t\t// if the object isn't in the cache anymore then exit early because it's been disposed elsewhere\n\t\t\t\t\tif ( cache[ key ] !== info ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// abort any loads\n\t\t\t\t\tconst { result, abortController } = info;\n\t\t\t\t\tabortController.abort();\n\n\t\t\t\t\t// dispose of the object even if it still is in progress\n\t\t\t\t\tif ( result instanceof Promise ) {\n\n\t\t\t\t\t\t// \"disposeItem\" will throw potentially if fetch, etc are cancelled using the abort signal\n\t\t\t\t\t\tresult.then( item => {\n\n\t\t\t\t\t\t\tthis.disposeItem( item );\n\t\t\t\t\t\t\tthis.count --;\n\t\t\t\t\t\t\tthis.cachedBytes -= info.bytes;\n\n\t\t\t\t\t\t} ).catch( () => {} );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.disposeItem( result );\n\t\t\t\t\t\tthis.count --;\n\t\t\t\t\t\tthis.cachedBytes -= info.bytes;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete cache[ key ];\n\n\t\t\t\t};\n\n\t\t\t\tif ( force ) {\n\n\t\t\t\t\t// if we're forcing disposal then dispose immediately\n\t\t\t\t\tdisposeCallback();\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// queue for disposal in a frame here - we need to make sure we're not disposing of something twice\n\t\t\t\t\t// this can get called multiple times in a row to increment then decrement again.\n\t\t\t\t\tqueueMicrotask( () => {\n\n\t\t\t\t\t\tif ( info.count === 0 ) {\n\n\t\t\t\t\t\t\tdisposeCallback();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tthrow new Error( 'DataCache: Attempting to release key that does not exist' );\n\n\t}\n\n}\n","import { MathUtils } from 'three';\nimport { ProjectionScheme } from './ProjectionScheme.js';\n\nfunction doBoundsIntersect( a, b ) {\n\n\tconst [ aMinX, aMinY, aMaxX, aMaxY ] = a;\n\tconst [ bMinX, bMinY, bMaxX, bMaxY ] = b;\n\n\treturn ! ( aMinX >= bMaxX || aMaxX <= bMinX || aMinY >= bMaxY || aMaxY <= bMinY );\n\n}\n\n// Class for storing and querying a tiling scheme including a bounds, origin, and negative tile indices.\n// Assumes that tiles are split into four child tiles at each level.\n\n// Projection Bounds: The full extent of content representable by the projection.\n// Content Bounds: The range within the content bounds contains relevant, loadable, and renderable data.\n// Tile Bounds: The per-layer extent covered by the tiles to be loaded. This range may be larger than\n// both the projection and content bounds.\nexport class TilingScheme {\n\n\tget levelCount() {\n\n\t\treturn this._levels.length;\n\n\t}\n\n\tget maxLevel() {\n\n\t\treturn this.levelCount - 1;\n\n\t}\n\n\tget minLevel() {\n\n\t\tconst levels = this._levels;\n\t\tfor ( let i = 0; i < levels.length; i ++ ) {\n\n\t\t\tif ( levels[ i ] !== null ) {\n\n\t\t\t\treturn i;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn - 1;\n\n\t}\n\n\t// prioritize user-set bounds over projection bounds if present\n\tget contentBounds() {\n\n\t\treturn this._contentBounds ?? this.projection.getBounds();\n\n\t}\n\n\tget aspectRatio() {\n\n\t\tconst { pixelWidth, pixelHeight } = this.getLevel( this.maxLevel );\n\t\treturn pixelWidth / pixelHeight;\n\n\t}\n\n\tconstructor() {\n\n\t\tthis.flipY = false;\n\t\tthis.pixelOverlap = 0;\n\n\t\t// The origin and bounds\n\t\tthis._contentBounds = null;\n\t\tthis.projection = new ProjectionScheme( 'none' );\n\n\t\tthis._levels = [];\n\n\t}\n\n\t// build the zoom levels\n\tsetLevel( level, options = {} ) {\n\n\t\tconst levels = this._levels;\n\t\twhile ( levels.length < level ) {\n\n\t\t\tlevels.push( null );\n\n\t\t}\n\n\t\tconst {\n\t\t\ttileSplitX = 2,\n\t\t\ttileSplitY = 2,\n\t\t} = options;\n\n\t\tconst {\n\t\t\ttilePixelWidth = 256,\n\t\t\ttilePixelHeight = 256,\n\t\t\ttileCountX = tileSplitX ** level,\n\t\t\ttileCountY = tileSplitY ** level,\n\t\t\ttileBounds = null,\n\t\t} = options;\n\n\t\tconst {\n\t\t\tpixelWidth = tilePixelWidth * tileCountX,\n\t\t\tpixelHeight = tilePixelHeight * tileCountY,\n\t\t} = options;\n\n\t\tlevels[ level ] = {\n\t\t\t// The pixel resolution of each tile.\n\t\t\ttilePixelWidth,\n\t\t\ttilePixelHeight,\n\n\t\t\t// The total pixel resolution of the final image at this level. These numbers\n\t\t\t// may not be a round multiple of the tile width.\n\t\t\tpixelWidth,\n\t\t\tpixelHeight,\n\n\t\t\t// Or the total number of tiles that can be loaded at this level.\n\t\t\ttileCountX,\n\t\t\ttileCountY,\n\n\t\t\t// The number of tiles that the tiles at this layer split in to\n\t\t\ttileSplitX,\n\t\t\ttileSplitY,\n\n\t\t\t// The bounds covered by the extent of the tiles at this loaded. The actual content covered by the overall tileset\n\t\t\t// may be a subset of this range (eg there may be unused space).\n\t\t\ttileBounds,\n\t\t};\n\n\t}\n\n\tgenerateLevels( levels, rootTileX, rootTileY, options = {} ) {\n\n\t\tconst {\n\t\t\tminLevel = 0,\n\t\t\ttilePixelWidth = 256,\n\t\t\ttilePixelHeight = 256,\n\t\t} = options;\n\n\t\tconst maxLevel = levels - 1;\n\t\tconst {\n\t\t\tpixelWidth = tilePixelWidth * rootTileX * ( 2 ** maxLevel ),\n\t\t\tpixelHeight = tilePixelHeight * rootTileY * ( 2 ** maxLevel ),\n\t\t} = options;\n\t\tfor ( let level = minLevel; level < levels; level ++ ) {\n\n\t\t\tconst invLevel = levels - level - 1;\n\t\t\tconst levelPixelWidth = Math.ceil( pixelWidth * ( 2 ** - invLevel ) );\n\t\t\tconst levelPixelHeight = Math.ceil( pixelHeight * ( 2 ** - invLevel ) );\n\t\t\tconst tileCountX = Math.ceil( levelPixelWidth / tilePixelWidth );\n\t\t\tconst tileCountY = Math.ceil( levelPixelHeight / tilePixelHeight );\n\n\t\t\tthis.setLevel( level, {\n\t\t\t\ttilePixelWidth,\n\t\t\t\ttilePixelHeight,\n\t\t\t\tpixelWidth: levelPixelWidth,\n\t\t\t\tpixelHeight: levelPixelHeight,\n\t\t\t\ttileCountX,\n\t\t\t\ttileCountY,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\tgetLevel( level ) {\n\n\t\treturn this._levels[ level ];\n\n\t}\n\n\t// bounds representing the contentful region of the image\n\tsetContentBounds( minX, minY, maxX, maxY ) {\n\n\t\tthis._contentBounds = [ minX, minY, maxX, maxY ];\n\n\t}\n\n\tsetProjection( projection ) {\n\n\t\tthis.projection = projection;\n\n\t}\n\n\t// query functions\n\tgetTileAtPoint( bx, by, level, normalized = false ) {\n\n\t\tconst { flipY } = this;\n\t\tconst { tileCountX, tileCountY, tileBounds } = this.getLevel( level );\n\t\tconst xStride = 1 / tileCountX;\n\t\tconst yStride = 1 / tileCountY;\n\n\t\tif ( ! normalized ) {\n\n\t\t\t[ bx, by ] = this.toNormalizedPoint( bx, by );\n\n\t\t}\n\n\t\tif ( tileBounds ) {\n\n\t\t\tconst normalizedBounds = this.toNormalizedRange( tileBounds );\n\t\t\tbx = MathUtils.mapLinear( bx, normalizedBounds[ 0 ], normalizedBounds[ 2 ], 0, 1 );\n\t\t\tby = MathUtils.mapLinear( by, normalizedBounds[ 1 ], normalizedBounds[ 3 ], 0, 1 );\n\n\t\t}\n\n\t\tconst tx = Math.floor( bx / xStride );\n\t\tlet ty = Math.floor( by / yStride );\n\n\t\tif ( flipY ) {\n\n\t\t\tty = tileCountY - 1 - ty;\n\n\t\t}\n\n\t\treturn [ tx, ty ];\n\n\t}\n\n\tgetTilesInRange( minX, minY, maxX, maxY, level, normalized = false ) {\n\n\t\t// check if the range is outside the content bounds\n\t\tconst range = [ minX, minY, maxX, maxY ];\n\t\tconst contentBounds = this.getContentBounds( normalized );\n\t\tlet tileBounds = this.getLevel( level ).tileBounds;\n\t\tif ( ! doBoundsIntersect( range, contentBounds ) ) {\n\n\t\t\treturn [ 0, 0, - 1, - 1 ];\n\n\t\t}\n\n\t\t// check if the range is outside the tile bounds\n\t\tif ( tileBounds ) {\n\n\t\t\tif ( normalized ) {\n\n\t\t\t\ttileBounds = this.toNormalizedRange( tileBounds );\n\n\t\t\t}\n\n\t\t\tif ( ! doBoundsIntersect( range, contentBounds ) ) {\n\n\t\t\t\treturn [ 0, 0, - 1, - 1 ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst [ clampedMinX, clampedMinY, clampedMaxX, clampedMaxY ] = this.clampToContentBounds( range, normalized );\n\t\tconst minTile = this.getTileAtPoint( clampedMinX, clampedMinY, level, normalized );\n\t\tconst maxTile = this.getTileAtPoint( clampedMaxX, clampedMaxY, level, normalized );\n\n\t\tif ( this.flipY ) {\n\n\t\t\t[ minTile[ 1 ], maxTile[ 1 ] ] = [ maxTile[ 1 ], minTile[ 1 ] ];\n\n\t\t}\n\n\t\tconst { tileCountX, tileCountY } = this.getLevel( level );\n\t\tconst [ minTileX, minTileY ] = minTile;\n\t\tconst [ maxTileX, maxTileY ] = maxTile;\n\n\t\tif ( maxTileX < 0 || maxTileY < 0 || minTileX >= tileCountX || minTileY >= tileCountY ) {\n\n\t\t\treturn [ 0, 0, - 1, - 1 ];\n\n\t\t}\n\n\t\treturn [\n\t\t\tMathUtils.clamp( minTileX, 0, tileCountX - 1 ),\n\t\t\tMathUtils.clamp( minTileY, 0, tileCountY - 1 ),\n\t\t\tMathUtils.clamp( maxTileX, 0, tileCountX - 1 ),\n\t\t\tMathUtils.clamp( maxTileY, 0, tileCountY - 1 ),\n\t\t];\n\n\t}\n\n\tgetTileExists( x, y, level ) {\n\n\t\tconst [ rminx, rminy, rmaxx, rmaxy ] = this.contentBounds;\n\t\tconst [ tminx, tminy, tmaxx, tmaxy ] = this.getTileBounds( x, y, level );\n\t\tconst isDegenerate = tminx >= tmaxx || tminy >= tmaxy;\n\n\t\t// TODO: is supporting \"just touch\" correct?\n\t\treturn ! isDegenerate && tminx <= rmaxx && tminy <= rmaxy && tmaxx >= rminx && tmaxy >= rminy;\n\n\t}\n\n\tgetContentBounds( normalized = false ) {\n\n\t\tconst { projection } = this;\n\t\tconst bounds = [ ...this.contentBounds ];\n\t\tif ( normalized ) {\n\n\t\t\tbounds[ 0 ] = projection.convertLongitudeToNormalized( bounds[ 0 ] );\n\t\t\tbounds[ 1 ] = projection.convertLatitudeToNormalized( bounds[ 1 ] );\n\t\t\tbounds[ 2 ] = projection.convertLongitudeToNormalized( bounds[ 2 ] );\n\t\t\tbounds[ 3 ] = projection.convertLatitudeToNormalized( bounds[ 3 ] );\n\n\t\t}\n\n\t\treturn bounds;\n\n\t}\n\n\t// returns the UV range associated with the content in the given tile\n\tgetTileContentUVBounds( x, y, level ) {\n\n\t\tconst [ minU, minV, maxU, maxV ] = this.getTileBounds( x, y, level, true, true );\n\t\tconst [ fullMinU, fullMinV, fullMaxU, fullMaxV ] = this.getTileBounds( x, y, level, true, false );\n\t\treturn [\n\t\t\tMathUtils.mapLinear( minU, fullMinU, fullMaxU, 0, 1 ),\n\t\t\tMathUtils.mapLinear( minV, fullMinV, fullMaxV, 0, 1 ),\n\t\t\tMathUtils.mapLinear( maxU, fullMinU, fullMaxU, 0, 1 ),\n\t\t\tMathUtils.mapLinear( maxV, fullMinV, fullMaxV, 0, 1 ),\n\t\t];\n\n\t}\n\n\tgetTileBounds( x, y, level, normalized = false, clamp = true ) {\n\n\t\tconst { flipY, pixelOverlap, projection } = this;\n\t\tconst { tilePixelWidth, tilePixelHeight, pixelWidth, pixelHeight, tileBounds } = this.getLevel( level );\n\n\t\tlet tileLeft = tilePixelWidth * x - pixelOverlap;\n\t\tlet tileTop = tilePixelHeight * y - pixelOverlap;\n\t\tlet tileRight = tileLeft + tilePixelWidth + pixelOverlap * 2;\n\t\tlet tileBottom = tileTop + tilePixelHeight + pixelOverlap * 2;\n\n\t\t// clamp\n\t\ttileLeft = Math.max( tileLeft, 0 );\n\t\ttileTop = Math.max( tileTop, 0 );\n\t\ttileRight = Math.min( tileRight, pixelWidth );\n\t\ttileBottom = Math.min( tileBottom, pixelHeight );\n\n\t\t// normalized\n\t\ttileLeft = tileLeft / pixelWidth;\n\t\ttileRight = tileRight / pixelWidth;\n\t\ttileTop = tileTop / pixelHeight;\n\t\ttileBottom = tileBottom / pixelHeight;\n\n\t\t// invert y\n\t\tif ( flipY ) {\n\n\t\t\tconst extents = ( tileBottom - tileTop ) / 2;\n\t\t\tconst centerY = ( tileTop + tileBottom ) / 2;\n\t\t\tconst invCenterY = 1.0 - centerY;\n\n\t\t\ttileTop = invCenterY - extents;\n\t\t\ttileBottom = invCenterY + extents;\n\n\t\t}\n\n\t\tlet bounds = [ tileLeft, tileTop, tileRight, tileBottom ];\n\t\tif ( tileBounds ) {\n\n\t\t\tconst normBounds = this.toNormalizedRange( tileBounds );\n\t\t\tbounds[ 0 ] = MathUtils.mapLinear( bounds[ 0 ], 0, 1, normBounds[ 0 ], normBounds[ 2 ] );\n\t\t\tbounds[ 2 ] = MathUtils.mapLinear( bounds[ 2 ], 0, 1, normBounds[ 0 ], normBounds[ 2 ] );\n\t\t\tbounds[ 1 ] = MathUtils.mapLinear( bounds[ 1 ], 0, 1, normBounds[ 1 ], normBounds[ 3 ] );\n\t\t\tbounds[ 3 ] = MathUtils.mapLinear( bounds[ 3 ], 0, 1, normBounds[ 1 ], normBounds[ 3 ] );\n\n\t\t}\n\n\t\tif ( clamp ) {\n\n\t\t\tbounds = this.clampToBounds( bounds, true );\n\n\t\t}\n\n\t\tif ( ! normalized ) {\n\n\t\t\tbounds[ 0 ] = projection.convertNormalizedToLongitude( bounds[ 0 ] );\n\t\t\tbounds[ 1 ] = projection.convertNormalizedToLatitude( bounds[ 1 ] );\n\t\t\tbounds[ 2 ] = projection.convertNormalizedToLongitude( bounds[ 2 ] );\n\t\t\tbounds[ 3 ] = projection.convertNormalizedToLatitude( bounds[ 3 ] );\n\n\t\t}\n\n\t\treturn bounds;\n\n\t}\n\n\ttoNormalizedPoint( x, y ) {\n\n\t\treturn this.projection.toNormalizedPoint( x, y );\n\n\t}\n\n\ttoNormalizedRange( range ) {\n\n\t\treturn this.projection.toNormalizedRange( range );\n\n\t}\n\n\ttoCartographicPoint( x, y ) {\n\n\t\treturn this.projection.toCartographicPoint( x, y );\n\n\t}\n\n\ttoCartographicRange( range ) {\n\n\t\treturn this.projection.toCartographicRange( range );\n\n\t}\n\n\tclampToContentBounds( range, normalized = false ) {\n\n\t\tconst result = [ ...range ];\n\t\tconst [ minX, minY, maxX, maxY ] = this.getContentBounds( normalized );\n\t\tresult[ 0 ] = MathUtils.clamp( result[ 0 ], minX, maxX );\n\t\tresult[ 1 ] = MathUtils.clamp( result[ 1 ], minY, maxY );\n\t\tresult[ 2 ] = MathUtils.clamp( result[ 2 ], minX, maxX );\n\t\tresult[ 3 ] = MathUtils.clamp( result[ 3 ], minY, maxY );\n\n\t\treturn result;\n\n\t}\n\n\tclampToBounds( range, normalized = false ) {\n\n\t\treturn this.projection.clampToBounds( range, normalized );\n\n\t}\n\n}\n\n","import { DataCache } from '../utils/DataCache.js';\nimport { TilingScheme } from '../utils/TilingScheme.js';\nimport { SRGBColorSpace, Texture, TextureUtils } from 'three';\n\n// TODO: support queries for detail at level - ie projected pixel size for geometric error mapping\n// Goes here or in \"TilingScheme\"?\nexport class TiledImageSource extends DataCache {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper();\n\n\t\tconst {\n\t\t\tfetchOptions = {}\n\t\t} = options;\n\n\t\tthis.tiling = new TilingScheme();\n\t\tthis.fetchOptions = fetchOptions;\n\t\tthis.fetchData = ( ...args ) => fetch( ...args );\n\n\t}\n\n\t// async function for initializing the tiled image set\n\tinit() {}\n\n\t// helper for processing the buffer into a texture\n\tasync processBufferToTexture( buffer ) {\n\n\t\t// pre-flip the y axis\n\t\tconst blob = new Blob( [ buffer ] );\n\t\tconst imageBitmap = await createImageBitmap( blob, {\n\t\t\tpremultiplyAlpha: 'none',\n\t\t\tcolorSpaceConversion: 'none',\n\t\t\timageOrientation: 'flipY',\n\t\t} );\n\t\tconst texture = new Texture( imageBitmap );\n\t\ttexture.generateMipmaps = false;\n\t\ttexture.colorSpace = SRGBColorSpace;\n\t\ttexture.needsUpdate = true;\n\n\t\treturn texture;\n\n\t}\n\n\tgetMemoryUsage( tex ) {\n\n\t\tconst { format, type, image, generateMipmaps } = tex;\n\t\tconst { width, height } = image;\n\t\tconst bytes = TextureUtils.getByteLength( width, height, format, type );\n\t\treturn generateMipmaps ? bytes * 4 / 3 : bytes;\n\n\t}\n\n\t// fetch the item with the given key fields\n\tfetchItem( tokens, signal ) {\n\n\t\tconst fetchOptions = {\n\t\t\t...this.fetchOptions,\n\t\t\tsignal,\n\t\t};\n\t\tconst url = this.getUrl( ...tokens );\n\t\treturn this\n\t\t\t.fetchData( url, fetchOptions )\n\t\t\t.then( res => res.arrayBuffer() )\n\t\t\t.then( buffer => this.processBufferToTexture( buffer ) );\n\n\t}\n\n\t// dispose of the item that was fetched\n\tdisposeItem( texture ) {\n\n\t\ttexture.dispose();\n\t\tif ( texture.image instanceof ImageBitmap ) {\n\n\t\t\ttexture.image.close();\n\n\t\t}\n\n\t}\n\n\tgetUrl( ...args ) {\n\n\t}\n\n}\n"],"names":["ProjectionScheme","scheme","v","ratio","MathUtils","lat","mercatorN","lon","value","yp","x","y","result","range","normalized","clampBounds","minX","minY","maxX","maxY","hash","args","DataCache","item","cache","data","key","abortController","info","res","e","cb","force","disposeCallback","doBoundsIntersect","a","b","aMinX","aMinY","aMaxX","aMaxY","bMinX","bMinY","bMaxX","bMaxY","TilingScheme","levels","pixelWidth","pixelHeight","level","options","tileSplitX","tileSplitY","tilePixelWidth","tilePixelHeight","tileCountX","tileCountY","tileBounds","rootTileX","rootTileY","minLevel","maxLevel","invLevel","levelPixelWidth","levelPixelHeight","projection","bx","by","flipY","xStride","yStride","normalizedBounds","tx","ty","contentBounds","clampedMinX","clampedMinY","clampedMaxX","clampedMaxY","minTile","maxTile","minTileX","minTileY","maxTileX","maxTileY","rminx","rminy","rmaxx","rmaxy","tminx","tminy","tmaxx","tmaxy","bounds","minU","minV","maxU","maxV","fullMinU","fullMinV","fullMaxU","fullMaxV","clamp","pixelOverlap","tileLeft","tileTop","tileRight","tileBottom","extents","invCenterY","normBounds","TiledImageSource","fetchOptions","buffer","blob","imageBitmap","texture","Texture","SRGBColorSpace","tex","format","type","image","generateMipmaps","width","height","bytes","TextureUtils","tokens","signal","url"],"mappings":"gEAIO,MAAMA,CAAiB,CAE7B,IAAI,YAAa,CAEhB,OAAO,KAAK,SAAW,WAExB,CAEA,YAAaC,EAAS,YAAc,CAEnC,KAAK,OAASA,EACd,KAAK,WAAa,EAClB,KAAK,WAAa,EAElB,KAAK,UAAWA,CAAM,CAEvB,CAEA,UAAWA,EAAS,CAGnB,OADA,KAAK,OAASA,EACLA,EAAM,CAGd,IAAK,SACL,IAAK,YACJ,KAAK,WAAa,EAClB,KAAK,WAAa,EAClB,MAGD,IAAK,YACJ,KAAK,WAAa,EAClB,KAAK,WAAa,EAClB,MAED,IAAK,OACJ,KAAK,WAAa,EAClB,KAAK,WAAa,EAClB,MAED,QACC,MAAM,IAAI,MAAO,gDAAiDA,CAAM,GAAI,CAEhF,CAEC,CAEA,4BAA6BC,EAAI,CAEhC,GAAK,KAAK,SAAW,OAEpB,OAAOA,EAED,GAAK,KAAK,WAAa,CAG7B,MAAMC,EAAQC,EAAU,UAAWF,EAAG,EAAG,EAAG,GAAK,CAAC,EAClD,MAAO,GAAI,KAAK,KAAM,KAAK,IAAKC,EAAQ,KAAK,EAAE,CAAE,EAAK,KAAK,GAAK,CAEjE,KAEC,QAAOC,EAAU,UAAWF,EAAG,EAAG,EAAG,CAAE,KAAK,GAAK,EAAG,KAAK,GAAK,CAAC,CAIjE,CAEA,6BAA8BA,EAAI,CAEjC,OAAK,KAAK,SAAW,OAEbA,EAIAE,EAAU,UAAWF,EAAG,EAAG,EAAG,CAAE,KAAK,GAAI,KAAK,EAAE,CAIzD,CAEA,4BAA6BG,EAAM,CAElC,GAAK,KAAK,SAAW,OAEpB,OAAOA,EAED,GAAK,KAAK,WAAa,CAG7B,MAAMC,EAAY,KAAK,IAAK,KAAK,IAAO,KAAK,GAAK,EAAQD,EAAM,CAAG,CAAE,EACrE,MAAS,GAAI,EAAQ,EAAIC,GAAc,EAAI,KAAK,GAEjD,KAEC,QAAOF,EAAU,UAAWC,EAAK,CAAE,KAAK,GAAK,EAAG,KAAK,GAAK,EAAG,EAAG,CAAC,CAInE,CAEA,6BAA8BE,EAAM,CAEnC,OAAK,KAAK,SAAW,OAEbA,GAIEA,EAAM,KAAK,KAAS,EAAI,KAAK,GAIxC,CAEA,mCAAoCC,EAAQ,CAE3C,OAAK,KAAK,SAAW,OAEb,EAIA,EAAI,KAAK,EAIlB,CAEA,kCAAmCA,EAAQ,CAE1C,GAAK,KAAK,SAAW,OAEpB,MAAO,GAED,CAGN,IAAIC,EAAKD,EAAQ,KAOjB,OANKC,EAAK,IAETA,EAAKD,EAAQ,MAIT,KAAK,WAGF,KAAK,IAAK,KAAK,4BAA6BA,GAAU,KAAK,4BAA6BC,CAAE,CAAE,EAAK,KAIjG,KAAK,EAId,CAED,CAEA,WAAY,CAEX,OAAK,KAAK,SAAW,OAEb,CAAE,EAAG,EAAG,EAAG,CAAC,EAIZ,CACN,KAAK,6BAA8B,CAAC,EAAI,KAAK,4BAA6B,CAAC,EAC3E,KAAK,6BAA8B,CAAC,EAAI,KAAK,4BAA6B,CAAC,CAC/E,CAIC,CAEA,kBAAmBC,EAAGC,EAAI,CAEzB,MAAMC,EAAS,CAAEF,EAAGC,CAAC,EACrB,OAAAC,EAAQ,CAAC,EAAK,KAAK,6BAA8BA,EAAQ,EAAG,EAC5DA,EAAQ,CAAC,EAAK,KAAK,4BAA6BA,EAAQ,EAAG,EAEpDA,CAER,CAEA,kBAAmBC,EAAQ,CAE1B,MAAO,CACN,GAAG,KAAK,kBAAmBA,EAAO,CAAC,EAAIA,EAAO,EAAG,EACjD,GAAG,KAAK,kBAAmBA,EAAO,CAAC,EAAIA,EAAO,EAAG,CACpD,CAEC,CAEA,oBAAqBH,EAAGC,EAAI,CAE3B,MAAMC,EAAS,CAAEF,EAAGC,CAAC,EACrB,OAAAC,EAAQ,CAAC,EAAK,KAAK,6BAA8BA,EAAQ,EAAG,EAC5DA,EAAQ,CAAC,EAAK,KAAK,4BAA6BA,EAAQ,EAAG,EAEpDA,CAER,CAEA,oBAAqBC,EAAQ,CAE5B,MAAO,CACN,GAAG,KAAK,oBAAqBA,EAAO,CAAC,EAAIA,EAAO,EAAG,EACnD,GAAG,KAAK,oBAAqBA,EAAO,CAAC,EAAIA,EAAO,EAAG,CACtD,CAEC,CAEA,cAAeA,EAAOC,EAAa,GAAQ,CAE1C,MAAMF,EAAS,CAAE,GAAGC,CAAK,EACzB,IAAIE,EAECD,EAEJC,EAAc,CAAE,EAAG,EAAG,EAAG,CAAC,EAI1BA,EAAc,KAAK,UAAS,EAI7B,KAAM,CAAEC,EAAMC,EAAMC,EAAMC,CAAI,EAAKJ,EACnC,OAAAH,EAAQ,CAAC,EAAKR,EAAU,MAAOQ,EAAQ,CAAC,EAAII,EAAME,CAAI,EACtDN,EAAQ,CAAC,EAAKR,EAAU,MAAOQ,EAAQ,CAAC,EAAIK,EAAME,CAAI,EACtDP,EAAQ,CAAC,EAAKR,EAAU,MAAOQ,EAAQ,CAAC,EAAII,EAAME,CAAI,EACtDN,EAAQ,CAAC,EAAKR,EAAU,MAAOQ,EAAQ,CAAC,EAAIK,EAAME,CAAI,EAE/CP,CAER,CAED,CCrPA,SAASQ,KAASC,EAAO,CAExB,OAAOA,EAAK,KAAM,GAAG,CAEtB,CAIO,MAAMC,CAAU,CAEtB,aAAc,CAEb,KAAK,MAAQ,CAAA,EACb,KAAK,MAAQ,EACb,KAAK,YAAc,EACnB,KAAK,OAAS,CAEf,CAGA,WAAY,CAAC,CACb,aAAc,CAAC,CACf,eAAgBC,EAAO,CAEtB,MAAO,EAER,CAGA,WAAYF,EAAO,CAElB,KAAM,CAAE,MAAAG,CAAK,EAAK,KACZC,EAAOJ,EAAK,IAAG,EACfK,EAAMN,EAAM,GAAGC,CAAI,EACzB,GAAKK,KAAOF,EAEX,MAAM,IAAI,MAAO,eAAgBE,CAAG,uBAAwB,EAI5D,YAAK,MAAOA,GAAQ,CACnB,gBAAiB,IAAI,gBACrB,OAAQD,EACR,MAAO,EACP,MAAO,KAAK,eAAgBA,CAAI,CACpC,EACG,KAAK,QACL,KAAK,aAAe,KAAK,MAAOC,CAAG,EAAG,MAIhCD,CAER,CAGA,QAASJ,EAAO,CAEf,KAAM,CAAE,MAAAG,CAAK,EAAK,KACZE,EAAMN,EAAM,GAAGC,CAAI,EACzB,GAAKK,KAAOF,EAEXA,EAAOE,CAAG,EAAG,YAEP,CAEN,MAAMC,EAAkB,IAAI,gBACtBC,EAAO,CACZ,gBAAAD,EACA,OAAQ,KACR,MAAO,EACP,MAAO,EACP,KAAAN,CACJ,EAEG,KAAK,SACLO,EAAK,OAAS,KAAK,UAAWP,EAAMM,EAAgB,MAAM,EACrDC,EAAK,kBAAkB,QAE3BA,EAAK,OAAO,KAAMC,IAEjBD,EAAK,OAASC,EACdD,EAAK,MAAQ,KAAK,eAAgBC,CAAG,EACrC,KAAK,aAAeD,EAAK,MAClBC,EAEP,EAAG,QAAS,IAAM,CAElB,KAAK,QAEN,CAAC,EAAG,MAAOC,GAAK,CAIhB,CAAC,GAID,KAAK,SACLF,EAAK,MAAQ,KAAK,eAAgBA,EAAK,MAAM,EAC7C,KAAK,aAAeA,EAAK,OAI1B,KAAK,MAAOF,CAAG,EAAKE,EACpB,KAAK,OAEN,CAEA,OAAOJ,EAAOE,CAAG,EAAG,MAErB,CAGA,WAAYL,EAAO,CAElB,MAAMK,EAAMN,EAAM,GAAGC,CAAI,EACzB,KAAK,kBAAmBK,CAAG,CAE5B,CAGA,OAAQL,EAAO,CAEd,KAAM,CAAE,MAAAG,CAAK,EAAK,KACZE,EAAMN,EAAM,GAAGC,CAAI,EACzB,OAAKK,KAAOF,GAASA,EAAOE,CAAG,EAAG,MAAQ,EAElCF,EAAOE,CAAG,EAAG,OAIb,IAIT,CAEA,OAAQL,EAAO,CAEd,KAAM,CAAE,MAAAG,CAAK,EAAK,KAElB,OADYJ,EAAM,GAAGC,CAAI,IACXG,CAEf,CAEA,YAAaO,EAAK,CAEjB,KAAM,CAAE,MAAAP,CAAK,EAAK,KAClB,UAAYE,KAAOF,EAAQ,CAE1B,MAAMI,EAAOJ,EAAOE,CAAG,EACdE,EAAK,kBAAkB,SAE/BG,EAAIH,EAAK,OAAQA,EAAK,IAAI,CAI5B,CAED,CAGA,SAAU,CAET,KAAM,CAAE,MAAAJ,CAAK,EAAK,KAClB,UAAYE,KAAOF,EAAQ,CAE1B,KAAM,CAAE,gBAAAG,CAAe,EAAKH,EAAOE,CAAG,EACtCC,EAAgB,MAAK,EAErB,KAAK,kBAAmBD,EAAK,EAAI,CAElC,CAEA,KAAK,MAAQ,CAAA,CAEd,CAGA,kBAAmBA,EAAKM,EAAQ,GAAQ,CAEvC,KAAM,CAAE,MAAAR,CAAK,EAAK,KAClB,GAAKE,KAAOF,GAASA,EAAOE,CAAG,EAAG,MAAQ,EAAI,CAG7C,MAAME,EAAOJ,EAAOE,CAAG,EAIvB,GAHAE,EAAK,QAGAA,EAAK,QAAU,GAAKI,EAAQ,CAEhC,MAAMC,EAAkB,IAAM,CAG7B,GAAKT,EAAOE,CAAG,IAAOE,EAErB,OAKD,KAAM,CAAE,OAAAhB,EAAQ,gBAAAe,CAAe,EAAKC,EACpCD,EAAgB,MAAK,EAGhBf,aAAkB,QAGtBA,EAAO,KAAMW,GAAQ,CAEpB,KAAK,YAAaA,CAAI,EACtB,KAAK,QACL,KAAK,aAAeK,EAAK,KAE1B,GAAI,MAAO,IAAM,CAAC,CAAC,GAInB,KAAK,YAAahB,CAAM,EACxB,KAAK,QACL,KAAK,aAAegB,EAAK,OAI1B,OAAOJ,EAAOE,CAAG,CAElB,EAEKM,EAGJC,EAAe,EAMf,eAAgB,IAAM,CAEhBL,EAAK,QAAU,GAEnBK,EAAe,CAIjB,CAAC,CAIH,CAEA,MAAO,EAER,CAEA,MAAM,IAAI,MAAO,0DAA0D,CAE5E,CAED,CCjQA,SAASC,EAAmBC,EAAGC,EAAI,CAElC,KAAM,CAAEC,EAAOC,EAAOC,EAAOC,CAAK,EAAKL,EACjC,CAAEM,EAAOC,EAAOC,EAAOC,CAAK,EAAKR,EAEvC,MAAO,EAAIC,GAASM,GAASJ,GAASE,GAASH,GAASM,GAASJ,GAASE,EAE3E,CASO,MAAMG,CAAa,CAEzB,IAAI,YAAa,CAEhB,OAAO,KAAK,QAAQ,MAErB,CAEA,IAAI,UAAW,CAEd,OAAO,KAAK,WAAa,CAE1B,CAEA,IAAI,UAAW,CAEd,MAAMC,EAAS,KAAK,QACpB,QAAU,EAAI,EAAG,EAAIA,EAAO,OAAQ,IAEnC,GAAKA,EAAQ,CAAC,IAAO,KAEpB,OAAO,EAMT,MAAO,EAER,CAGA,IAAI,eAAgB,CAEnB,OAAO,KAAK,gBAAkB,KAAK,WAAW,UAAS,CAExD,CAEA,IAAI,aAAc,CAEjB,KAAM,CAAE,WAAAC,EAAY,YAAAC,CAAW,EAAK,KAAK,SAAU,KAAK,QAAQ,EAChE,OAAOD,EAAaC,CAErB,CAEA,aAAc,CAEb,KAAK,MAAQ,GACb,KAAK,aAAe,EAGpB,KAAK,eAAiB,KACtB,KAAK,WAAa,IAAIhD,EAAkB,MAAM,EAE9C,KAAK,QAAU,CAAA,CAEhB,CAGA,SAAUiD,EAAOC,EAAU,GAAK,CAE/B,MAAMJ,EAAS,KAAK,QACpB,KAAQA,EAAO,OAASG,GAEvBH,EAAO,KAAM,IAAI,EAIlB,KAAM,CACL,WAAAK,EAAa,EACb,WAAAC,EAAa,CAChB,EAAMF,EAEE,CACL,eAAAG,EAAiB,IACjB,gBAAAC,EAAkB,IAClB,WAAAC,EAAaJ,GAAcF,EAC3B,WAAAO,EAAaJ,GAAcH,EAC3B,WAAAQ,EAAa,IAChB,EAAMP,EAEE,CACL,WAAAH,EAAaM,EAAiBE,EAC9B,YAAAP,EAAcM,EAAkBE,CACnC,EAAMN,EAEJJ,EAAQG,CAAK,EAAK,CAEjB,eAAAI,EACA,gBAAAC,EAIA,WAAAP,EACA,YAAAC,EAGA,WAAAO,EACA,WAAAC,EAGA,WAAAL,EACA,WAAAC,EAIA,WAAAK,CACH,CAEC,CAEA,eAAgBX,EAAQY,EAAWC,EAAWT,EAAU,CAAA,EAAK,CAE5D,KAAM,CACL,SAAAU,EAAW,EACX,eAAAP,EAAiB,IACjB,gBAAAC,EAAkB,GACrB,EAAMJ,EAEEW,EAAWf,EAAS,EACpB,CACL,WAAAC,EAAaM,EAAiBK,EAAc,GAAKG,EACjD,YAAAb,EAAcM,EAAkBK,EAAc,GAAKE,CACtD,EAAMX,EACJ,QAAUD,EAAQW,EAAUX,EAAQH,EAAQG,IAAW,CAEtD,MAAMa,EAAWhB,EAASG,EAAQ,EAC5Bc,EAAkB,KAAK,KAAMhB,EAAe,GAAK,CAAEe,CAAU,EAC7DE,EAAmB,KAAK,KAAMhB,EAAgB,GAAK,CAAEc,CAAU,EAC/DP,EAAa,KAAK,KAAMQ,EAAkBV,CAAc,EACxDG,EAAa,KAAK,KAAMQ,EAAmBV,CAAe,EAEhE,KAAK,SAAUL,EAAO,CACrB,eAAAI,EACA,gBAAAC,EACA,WAAYS,EACZ,YAAaC,EACb,WAAAT,EACA,WAAAC,CACJ,CAAI,CAEF,CAED,CAEA,SAAUP,EAAQ,CAEjB,OAAO,KAAK,QAASA,CAAK,CAE3B,CAGA,iBAAkBjC,EAAMC,EAAMC,EAAMC,EAAO,CAE1C,KAAK,eAAiB,CAAEH,EAAMC,EAAMC,EAAMC,CAAI,CAE/C,CAEA,cAAe8C,EAAa,CAE3B,KAAK,WAAaA,CAEnB,CAGA,eAAgBC,EAAIC,EAAIlB,EAAOnC,EAAa,GAAQ,CAEnD,KAAM,CAAE,MAAAsD,CAAK,EAAK,KACZ,CAAE,WAAAb,EAAY,WAAAC,EAAY,WAAAC,CAAU,EAAK,KAAK,SAAUR,CAAK,EAC7DoB,EAAU,EAAId,EACde,EAAU,EAAId,EAQpB,GANO1C,IAEN,CAAEoD,EAAIC,CAAE,EAAK,KAAK,kBAAmBD,EAAIC,CAAE,GAIvCV,EAAa,CAEjB,MAAMc,EAAmB,KAAK,kBAAmBd,CAAU,EAC3DS,EAAK9D,EAAU,UAAW8D,EAAIK,EAAkB,CAAC,EAAIA,EAAkB,GAAK,EAAG,CAAC,EAChFJ,EAAK/D,EAAU,UAAW+D,EAAII,EAAkB,CAAC,EAAIA,EAAkB,GAAK,EAAG,CAAC,CAEjF,CAEA,MAAMC,EAAK,KAAK,MAAON,EAAKG,CAAO,EACnC,IAAII,EAAK,KAAK,MAAON,EAAKG,CAAO,EAEjC,OAAKF,IAEJK,EAAKjB,EAAa,EAAIiB,GAIhB,CAAED,EAAIC,CAAE,CAEhB,CAEA,gBAAiBzD,EAAMC,EAAMC,EAAMC,EAAM8B,EAAOnC,EAAa,GAAQ,CAGpE,MAAMD,EAAQ,CAAEG,EAAMC,EAAMC,EAAMC,CAAI,EAChCuD,EAAgB,KAAK,iBAAkB5D,CAAU,EACvD,IAAI2C,EAAa,KAAK,SAAUR,CAAK,EAAG,WACxC,GAAK,CAAEf,EAAmBrB,EAAO6D,GAEhC,MAAO,CAAE,EAAG,EAAG,GAAK,EAAG,EAKxB,GAAKjB,IAEC3C,IAEJ2C,EAAa,KAAK,kBAAmBA,CAAU,GAI3C,CAAEvB,EAAmBrB,EAAO6D,IAEhC,MAAO,CAAE,EAAG,EAAG,GAAK,EAAG,EAMzB,KAAM,CAAEC,EAAaC,EAAaC,EAAaC,CAAW,EAAK,KAAK,qBAAsBjE,EAAOC,CAAU,EACrGiE,EAAU,KAAK,eAAgBJ,EAAaC,EAAa3B,EAAOnC,CAAU,EAC1EkE,EAAU,KAAK,eAAgBH,EAAaC,EAAa7B,EAAOnC,CAAU,EAE3E,KAAK,QAET,CAAEiE,EAAS,GAAKC,EAAS,CAAC,CAAE,EAAK,CAAEA,EAAS,CAAC,EAAID,EAAS,CAAC,CAAE,GAI9D,KAAM,CAAE,WAAAxB,EAAY,WAAAC,CAAU,EAAK,KAAK,SAAUP,CAAK,EACjD,CAAEgC,EAAUC,CAAQ,EAAKH,EACzB,CAAEI,EAAUC,CAAQ,EAAKJ,EAE/B,OAAKG,EAAW,GAAKC,EAAW,GAAKH,GAAY1B,GAAc2B,GAAY1B,EAEnE,CAAE,EAAG,EAAG,GAAK,EAAG,EAIjB,CACNpD,EAAU,MAAO6E,EAAU,EAAG1B,EAAa,CAAC,EAC5CnD,EAAU,MAAO8E,EAAU,EAAG1B,EAAa,CAAC,EAC5CpD,EAAU,MAAO+E,EAAU,EAAG5B,EAAa,CAAC,EAC5CnD,EAAU,MAAOgF,EAAU,EAAG5B,EAAa,CAAC,CAC/C,CAEC,CAEA,cAAe9C,EAAGC,EAAGsC,EAAQ,CAE5B,KAAM,CAAEoC,EAAOC,EAAOC,EAAOC,CAAK,EAAK,KAAK,cACtC,CAAEC,EAAOC,EAAOC,EAAOC,CAAK,EAAK,KAAK,cAAelF,EAAGC,EAAGsC,CAAK,EAItE,MAAO,EAHcwC,GAASE,GAASD,GAASE,IAGvBH,GAASF,GAASG,GAASF,GAASG,GAASN,GAASO,GAASN,CAEzF,CAEA,iBAAkBxE,EAAa,GAAQ,CAEtC,KAAM,CAAE,WAAAmD,CAAU,EAAK,KACjB4B,EAAS,CAAE,GAAG,KAAK,aAAa,EACtC,OAAK/E,IAEJ+E,EAAQ,CAAC,EAAK5B,EAAW,6BAA8B4B,EAAQ,EAAG,EAClEA,EAAQ,CAAC,EAAK5B,EAAW,4BAA6B4B,EAAQ,EAAG,EACjEA,EAAQ,CAAC,EAAK5B,EAAW,6BAA8B4B,EAAQ,EAAG,EAClEA,EAAQ,CAAC,EAAK5B,EAAW,4BAA6B4B,EAAQ,EAAG,GAI3DA,CAER,CAGA,uBAAwBnF,EAAGC,EAAGsC,EAAQ,CAErC,KAAM,CAAE6C,EAAMC,EAAMC,EAAMC,CAAI,EAAK,KAAK,cAAevF,EAAGC,EAAGsC,EAAO,GAAM,EAAI,EACxE,CAAEiD,EAAUC,EAAUC,EAAUC,CAAQ,EAAK,KAAK,cAAe3F,EAAGC,EAAGsC,EAAO,GAAM,EAAK,EAC/F,MAAO,CACN7C,EAAU,UAAW0F,EAAMI,EAAUE,EAAU,EAAG,CAAC,EACnDhG,EAAU,UAAW2F,EAAMI,EAAUE,EAAU,EAAG,CAAC,EACnDjG,EAAU,UAAW4F,EAAME,EAAUE,EAAU,EAAG,CAAC,EACnDhG,EAAU,UAAW6F,EAAME,EAAUE,EAAU,EAAG,CAAC,CACtD,CAEC,CAEA,cAAe3F,EAAGC,EAAGsC,EAAOnC,EAAa,GAAOwF,EAAQ,GAAO,CAE9D,KAAM,CAAE,MAAAlC,EAAO,aAAAmC,EAAc,WAAAtC,CAAU,EAAK,KACtC,CAAE,eAAAZ,EAAgB,gBAAAC,EAAiB,WAAAP,EAAY,YAAAC,EAAa,WAAAS,GAAe,KAAK,SAAUR,CAAK,EAErG,IAAIuD,EAAWnD,EAAiB3C,EAAI6F,EAChCE,EAAUnD,EAAkB3C,EAAI4F,EAChCG,EAAYF,EAAWnD,EAAiBkD,EAAe,EACvDI,EAAaF,EAAUnD,EAAkBiD,EAAe,EAe5D,GAZAC,EAAW,KAAK,IAAKA,EAAU,CAAC,EAChCC,EAAU,KAAK,IAAKA,EAAS,CAAC,EAC9BC,EAAY,KAAK,IAAKA,EAAW3D,CAAU,EAC3C4D,EAAa,KAAK,IAAKA,EAAY3D,CAAW,EAG9CwD,EAAWA,EAAWzD,EACtB2D,EAAYA,EAAY3D,EACxB0D,EAAUA,EAAUzD,EACpB2D,EAAaA,EAAa3D,EAGrBoB,EAAQ,CAEZ,MAAMwC,GAAYD,EAAaF,GAAY,EAErCI,EAAa,GADDJ,EAAUE,GAAe,EAG3CF,EAAUI,EAAaD,EACvBD,EAAaE,EAAaD,CAE3B,CAEA,IAAIf,EAAS,CAAEW,EAAUC,EAASC,EAAWC,CAAU,EACvD,GAAKlD,EAAa,CAEjB,MAAMqD,EAAa,KAAK,kBAAmBrD,CAAU,EACrDoC,EAAQ,CAAC,EAAKzF,EAAU,UAAWyF,EAAQ,CAAC,EAAI,EAAG,EAAGiB,EAAY,CAAC,EAAIA,EAAY,CAAC,CAAE,EACtFjB,EAAQ,CAAC,EAAKzF,EAAU,UAAWyF,EAAQ,CAAC,EAAI,EAAG,EAAGiB,EAAY,CAAC,EAAIA,EAAY,CAAC,CAAE,EACtFjB,EAAQ,CAAC,EAAKzF,EAAU,UAAWyF,EAAQ,CAAC,EAAI,EAAG,EAAGiB,EAAY,CAAC,EAAIA,EAAY,CAAC,CAAE,EACtFjB,EAAQ,CAAC,EAAKzF,EAAU,UAAWyF,EAAQ,CAAC,EAAI,EAAG,EAAGiB,EAAY,CAAC,EAAIA,EAAY,CAAC,CAAE,CAEvF,CAEA,OAAKR,IAEJT,EAAS,KAAK,cAAeA,EAAQ,EAAI,GAInC/E,IAEN+E,EAAQ,CAAC,EAAK5B,EAAW,6BAA8B4B,EAAQ,EAAG,EAClEA,EAAQ,CAAC,EAAK5B,EAAW,4BAA6B4B,EAAQ,EAAG,EACjEA,EAAQ,CAAC,EAAK5B,EAAW,6BAA8B4B,EAAQ,EAAG,EAClEA,EAAQ,CAAC,EAAK5B,EAAW,4BAA6B4B,EAAQ,EAAG,GAI3DA,CAER,CAEA,kBAAmBnF,EAAGC,EAAI,CAEzB,OAAO,KAAK,WAAW,kBAAmBD,EAAGC,CAAC,CAE/C,CAEA,kBAAmBE,EAAQ,CAE1B,OAAO,KAAK,WAAW,kBAAmBA,CAAK,CAEhD,CAEA,oBAAqBH,EAAGC,EAAI,CAE3B,OAAO,KAAK,WAAW,oBAAqBD,EAAGC,CAAC,CAEjD,CAEA,oBAAqBE,EAAQ,CAE5B,OAAO,KAAK,WAAW,oBAAqBA,CAAK,CAElD,CAEA,qBAAsBA,EAAOC,EAAa,GAAQ,CAEjD,MAAMF,EAAS,CAAE,GAAGC,CAAK,EACnB,CAAEG,EAAMC,EAAMC,EAAMC,CAAI,EAAK,KAAK,iBAAkBL,CAAU,EACpE,OAAAF,EAAQ,CAAC,EAAKR,EAAU,MAAOQ,EAAQ,CAAC,EAAII,EAAME,CAAI,EACtDN,EAAQ,CAAC,EAAKR,EAAU,MAAOQ,EAAQ,CAAC,EAAIK,EAAME,CAAI,EACtDP,EAAQ,CAAC,EAAKR,EAAU,MAAOQ,EAAQ,CAAC,EAAII,EAAME,CAAI,EACtDN,EAAQ,CAAC,EAAKR,EAAU,MAAOQ,EAAQ,CAAC,EAAIK,EAAME,CAAI,EAE/CP,CAER,CAEA,cAAeC,EAAOC,EAAa,GAAQ,CAE1C,OAAO,KAAK,WAAW,cAAeD,EAAOC,CAAU,CAExD,CAED,CCnaO,MAAMiG,UAAyBzF,CAAU,CAE/C,YAAa4B,EAAU,GAAK,CAE3B,MAAK,EAEL,KAAM,CACL,aAAA8D,EAAe,CAAA,CAClB,EAAM9D,EAEJ,KAAK,OAAS,IAAIL,EAClB,KAAK,aAAemE,EACpB,KAAK,UAAY,IAAK3F,IAAU,MAAO,GAAGA,CAAI,CAE/C,CAGA,MAAO,CAAC,CAGR,MAAM,uBAAwB4F,EAAS,CAGtC,MAAMC,EAAO,IAAI,KAAM,CAAED,CAAM,CAAE,EAC3BE,EAAc,MAAM,kBAAmBD,EAAM,CAClD,iBAAkB,OAClB,qBAAsB,OACtB,iBAAkB,OACrB,CAAG,EACKE,EAAU,IAAIC,EAASF,CAAW,EACxC,OAAAC,EAAQ,gBAAkB,GAC1BA,EAAQ,WAAaE,EACrBF,EAAQ,YAAc,GAEfA,CAER,CAEA,eAAgBG,EAAM,CAErB,KAAM,CAAE,OAAAC,EAAQ,KAAAC,EAAM,MAAAC,EAAO,gBAAAC,CAAe,EAAKJ,EAC3C,CAAE,MAAAK,EAAO,OAAAC,CAAM,EAAKH,EACpBI,EAAQC,EAAa,cAAeH,EAAOC,EAAQL,EAAQC,CAAI,EACrE,OAAOE,EAAkBG,EAAQ,EAAI,EAAIA,CAE1C,CAGA,UAAWE,EAAQC,EAAS,CAE3B,MAAMjB,EAAe,CACpB,GAAG,KAAK,aACR,OAAAiB,CACH,EACQC,EAAM,KAAK,OAAQ,GAAGF,CAAM,EAClC,OAAO,KACL,UAAWE,EAAKlB,CAAY,EAC5B,KAAMnF,GAAOA,EAAI,YAAW,CAAE,EAC9B,KAAMoF,GAAU,KAAK,uBAAwBA,CAAM,CAAE,CAExD,CAGA,YAAaG,EAAU,CAEtBA,EAAQ,QAAO,EACVA,EAAQ,iBAAiB,aAE7BA,EAAQ,MAAM,MAAK,CAIrB,CAEA,UAAW/F,EAAO,CAElB,CAED"}