{"version":3,"file":"TopoLinesPlugin-S7dTYZuX.js","sources":["../../three/src/plugins/topolines/wrapTopoLineMaterial.js","../../three/src/plugins/topolines/TopoLinesPlugin.js"],"sourcesContent":["// Adjusts the provided material to support fading in and out using a bayer pattern. Providing a \"previous\"\n\nimport { Color, Matrix4, Vector2, Vector3 } from 'three';\n\nconst TOPO_PARAMS = Symbol( 'TOPO_PARAMS' );\n\nconst ELLIPSOID_FUNC = /* glsl */`\n\n\tvec3 getPositionToSurfacePoint( vec3 radius, vec3 pos ) {\n\n\t\tfloat EPSILON12 = 1e-12;\n\t\tfloat CENTER_EPS = 0.1;\n\n\t\t// From Cesium function Ellipsoid.scaleToGeodeticSurface\n\t\t// https://github.com/CesiumGS/cesium/blob/d11b746e5809ac115fcff65b7b0c6bdfe81dcf1c/packages/engine/Source/Core/scaleToGeodeticSurface.js#L25\n\t\tvec3 invRadiusSq = 1.0 / pow( radius, vec3( 2.0 ) );\n\t\tvec3 pos2 = pos * pos * invRadiusSq;\n\n\t\t// Compute the squared ellipsoid norm.\n\t\tfloat squaredNorm = pos2.x + pos2.y + pos2.z;\n\t\tfloat ratio = sqrt( 1.0 / squaredNorm );\n\n\t\t// As an initial approximation, assume that the radial intersection is the projection point.\n\t\tvec3 intersection = pos * ratio;\n\t\tif ( squaredNorm < CENTER_EPS ) {\n\n\t\t\treturn ratio > EPSILON12 ? vec3( 0.0 ) : intersection;\n\n\t\t}\n\n\t\t// Use the gradient at the intersection point in place of the true unit normal.\n\t\t// The difference in magnitude will be absorbed in the multiplier.\n\t\tvec3 gradient = intersection * invRadiusSq * 2.0;\n\n\t\t// Compute the initial guess at the normal vector multiplier, lambda.\n\t\tfloat lambda = ( 1.0 - ratio ) * length( pos ) / ( 0.5 * length( gradient ) );\n\t\tfloat correction = 0.0;\n\n\t\tfloat func, denominator;\n\t\tfloat xMultiplier, yMultiplier, zMultiplier;\n\t\tfloat xMultiplier2, yMultiplier2, zMultiplier2;\n\t\tfloat xMultiplier3, yMultiplier3, zMultiplier3;\n\n\t\tfor ( int i = 0; i < 2; i ++ ) {\n\n\t\t\tlambda -= correction;\n\n\t\t\txMultiplier = 1.0 / ( 1.0 + lambda * invRadiusSq.x );\n\t\t\tyMultiplier = 1.0 / ( 1.0 + lambda * invRadiusSq.y );\n\t\t\tzMultiplier = 1.0 / ( 1.0 + lambda * invRadiusSq.z );\n\n\t\t\txMultiplier2 = xMultiplier * xMultiplier;\n\t\t\tyMultiplier2 = yMultiplier * yMultiplier;\n\t\t\tzMultiplier2 = zMultiplier * zMultiplier;\n\n\t\t\txMultiplier3 = xMultiplier2 * xMultiplier;\n\t\t\tyMultiplier3 = yMultiplier2 * yMultiplier;\n\t\t\tzMultiplier3 = zMultiplier2 * zMultiplier;\n\n\t\t\tfunc = pos2.x * xMultiplier2 + pos2.y * yMultiplier2 + pos2.z * zMultiplier2 - 1.0;\n\n\t\t\t// \"denominator\" here refers to the use of this expression in the velocity and acceleration\n\t\t\t// computations in the sections to follow.\n\t\t\tdenominator =\n\t\t\t\tpos2.x * xMultiplier3 * invRadiusSq.x +\n\t\t\t\tpos2.y * yMultiplier3 * invRadiusSq.y +\n\t\t\t\tpos2.z * zMultiplier3 * invRadiusSq.z;\n\n\t\t\tfloat derivative = - 2.0 * denominator;\n\t\t\tcorrection = func / derivative;\n\n\t\t}\n\n\t\treturn vec3(\n\t\t\tpos.x * xMultiplier,\n\t\t\tpos.y * yMultiplier,\n\t\t\tpos.z * zMultiplier\n\t\t);\n\n\t}\n\n\tvec3 getPositionToNormal( vec3 radius, vec3 pos ) {\n\n\t\tvec3 radius2 = pow( radius, vec3( 2.0 ) );\n\t\treturn normalize( pos / radius2 );\n\n\t}\n`;\n\nconst MATH_FUNC = /* glsl */`\n\tfloat log10( float v ) {\n\n\t\treturn log( v ) / log( 10.0 );\n\n\t}\n\n\tfloat fwidth2( float v ) {\n\n\t\tfloat vdy = dFdy( v );\n\t\tfloat vdx = dFdx( v );\n\t\treturn length( vec2( vdy, vdx ) );\n\n\t}\n\n\tvec3 fwidth2( vec3 v ) {\n\n\t\tvec3 vdy = dFdy( v );\n\t\tvec3 vdx = dFdx( v );\n\t\treturn sqrt( vdy * vdy + vdx * vdx );\n\n\t}\n`;\n\n// before compile can be used to chain shader adjustments. Returns the added uniforms used for fading.\nexport function wrapTopoLineMaterial( material, previousOnBeforeCompile ) {\n\n\t// if the material has already been wrapped then return the params\n\tif ( material[ TOPO_PARAMS ] ) {\n\n\t\treturn material[ TOPO_PARAMS ];\n\n\t}\n\n\tconst params = {\n\t\tresolution: { value: new Vector2() },\n\t\tpixelRatio: { value: 1 },\n\n\t\tellipsoid: { value: new Vector3() },\n\t\tframe: { value: new Matrix4() },\n\n\t\ttopoColor: { value: new Color() },\n\t\ttopoOpacity: { value: 0.5 },\n\t\ttopoLimit: { value: new Vector2( 0, 1e10 ) },\n\t\ttopoFadeLimit: { value: new Vector2( 0, 1e10 ) },\n\n\t\tcartoColor: { value: new Color() },\n\t\tcartoOpacity: { value: 0.5 },\n\t\tcartoLimit: { value: new Vector2( 0, 1e10 ) },\n\t\tcartoFadeLimit: { value: new Vector2( 0, 1e10 ) },\n\n\t\tthickness: { value: 1.0 },\n\t};\n\n\tmaterial[ TOPO_PARAMS ] = params;\n\n\tmaterial.defines = {\n\t\t...( material.defines || {} ),\n\t\tUSE_TOPO_ELLIPSOID: 0,\n\t\tUSE_TOPO_LINES: 0,\n\t};\n\n\tmaterial.onBeforeCompile = shader => {\n\n\t\taddWorldPosition( shader );\n\n\t\tif ( previousOnBeforeCompile ) {\n\n\t\t\tpreviousOnBeforeCompile( shader );\n\n\t\t}\n\n\t\tshader.uniforms = {\n\t\t\t...shader.uniforms,\n\t\t\t...params,\n\t\t};\n\n\t\tshader.vertexShader = shader\n\t\t\t.vertexShader\n\t\t\t.replace( /void main\\(/, value => /* glsl */`\n\n\t\t\t\t${ ELLIPSOID_FUNC }\n\n\t\t\t\t#if USE_TOPO_ELLIPSOID && USE_TOPO_LINES\n\n\t\t\t\t\tuniform vec3 ellipsoid;\n\t\t\t\t\tuniform mat4 frame;\n\t\t\t\t\tvarying vec4 vCartographic;\n\n\t\t\t\t#endif\n\n\t\t\t\t${ value }\n\n\t\t\t` )\n\t\t\t.replace( /wPosition[^\\n]+;/, value => /* glsl */`\n\n\t\t\t\t${ value }\n\n\t\t\t\t#if USE_TOPO_ELLIPSOID && USE_TOPO_LINES\n\t\t\t\t{\n\n\t\t\t\t\tmat4 invFrame = inverse( frame );\n\t\t\t\t\tvec3 localPosition = ( invFrame * vec4( wPosition, 1 ) ).xyz;\n\n\t\t\t\t\t// From Cesium function Ellipsoid.cartesianToCartographic\n\t\t\t\t\t// https://github.com/CesiumGS/cesium/blob/665ec32e813d5d6fe906ec3e87187f6c38ed5e49/packages/engine/Source/Core/Ellipsoid.js#L463\n\t\t\t\t\tvec3 surfacePoint = getPositionToSurfacePoint( ellipsoid, localPosition );\n\t\t\t\t\tvec3 surfaceNormal = getPositionToNormal( ellipsoid, localPosition );\n\t\t\t\t\tvec3 heightDelta = localPosition - surfacePoint;\n\t\t\t\t\tfloat height = sign( dot( heightDelta, localPosition ) ) * length( heightDelta );\n\n\t\t\t\t\tvCartographic.xyz = surfaceNormal;\n\t\t\t\t\tvCartographic.w = height;\n\n\t\t\t\t}\n\t\t\t\t#endif\n\n\t\t\t` );\n\n\n\t\tshader.fragmentShader = shader\n\t\t\t.fragmentShader\n\t\t\t.replace( /void main\\(/, value => /* glsl */`\n\n\t\t\t\t#if USE_TOPO_ELLIPSOID && USE_TOPO_LINES\n\n\t\t\t\t\tuniform vec3 ellipsoid;\n\t\t\t\t\tvarying vec4 vCartographic;\n\n\t\t\t\t#endif\n\n\t\t\t\t#if USE_TOPO_LINES\n\n\t\t\t\t\tuniform vec2 resolution;\n\t\t\t\t\tuniform float pixelRatio;\n\n\t\t\t\t\tuniform mat4 frame;\n\t\t\t\t\tuniform float thickness;\n\n\t\t\t\t\tuniform vec3 topoColor;\n\t\t\t\t\tuniform float topoOpacity;\n\t\t\t\t\tuniform vec2 topoLimit;\n\t\t\t\t\tuniform vec2 topoFadeLimit;\n\n\t\t\t\t\tuniform vec3 cartoColor;\n\t\t\t\t\tuniform float cartoOpacity;\n\t\t\t\t\tuniform vec2 cartoLimit;\n\t\t\t\t\tuniform vec2 cartoFadeLimit;\n\n\t\t\t\t\tuniform mat4 projectionMatrix;\n\n\t\t\t\t\t${ MATH_FUNC }\n\n\t\t\t\t#endif\n\n\t\t\t\tvec3 calculateTopoLines( vec3 value, vec3 delta, vec3 topoStep, vec2 thickness, vec3 emphasisStride ) {\n\n\t\t\t\t\tvec3 halfTopoStep = topoStep * 0.5;\n\t\t\t\t\tvec3 lineIndex = mod( value, topoStep * emphasisStride );\n\t\t\t\t\tlineIndex = abs( lineIndex );\n\t\t\t\t\tlineIndex = step( lineIndex, topoStep * 0.5 );\n\n\t\t\t\t\t// calculate the topography lines\n\t\t\t\t\tvec3 topoThickness = vec3(\n\t\t\t\t\t\tlineIndex.x == 0.0 ? thickness[ 0 ] : thickness[ 1 ],\n\t\t\t\t\t\tlineIndex.y == 0.0 ? thickness[ 0 ] : thickness[ 1 ],\n\t\t\t\t\t\tlineIndex.z == 0.0 ? thickness[ 0 ] : thickness[ 1 ]\n\t\t\t\t\t);\n\t\t\t\t\tvec3 stride = 2.0 * abs( mod( value + halfTopoStep, topoStep ) - halfTopoStep );\n\t\t\t\t\tvec3 topo = smoothstep( delta * 0.5, delta * - 0.5, stride - delta * topoThickness );\n\n\t\t\t\t\t// handle steep surfaces that cover multiple bands\n\t\t\t\t\t// TODO: handle this calculation so it better reflects the tint of multiple lines converging for the given stride\n\t\t\t\t\tvec3 subPixelColor = delta / topoStep;\n\t\t\t\t\tvec3 subPixelAlpha = smoothstep( 0.4 * topoStep, 0.5 * topoStep, delta );\n\t\t\t\t\tvec3 fadedTopo = mix( topo, topoStep / delta * 0.2, subPixelAlpha );\n\n\t\t\t\t\treturn vec3(\n\t\t\t\t\t\tlineIndex.x == 0.0 ? 0.5 : 1.0,\n\t\t\t\t\t\tlineIndex.y == 0.0 ? 0.5 : 1.0,\n\t\t\t\t\t\tlineIndex.z == 0.0 ? 0.5 : 1.0\n\t\t\t\t\t) * fadedTopo;\n\n\t\t\t\t}\n\n\t\t\t\t${ value }\n\t\t\t` )\n\t\t\t.replace( /#include <color_fragment>/, value => /* glsl */`\n\n\t\t\t\t${ value }\n\n\t\t\t\t#if USE_TOPO_LINES\n\t\t\t\t{\n\n\t\t\t\t\tfloat FADE_SIZE = 0.25;\n\t\t\t\t\tfloat FADE_SIZE_HALF = FADE_SIZE * 0.5;\n\t\t\t\t\tfloat targetPixelsPerStep = pixelRatio * 1.75;\n\n\t\t\t\t\t// calculate projected screen points\n\t\t\t\t\tfloat distanceFromCamera = ( viewMatrix * vec4( wPosition, 1.0 ) ).z;\n\t\t\t\t\tvec4 p0 = projectionMatrix * vec4( 0, 0, distanceFromCamera, 1 );\n\t\t\t\t\tvec4 p1 = projectionMatrix * vec4( 1.0, 1.0, distanceFromCamera, 1 );\n\n\t\t\t\t\t// amount of pixel change per meter in screen space\n\t\t\t\t\t// multiple by 0.5 since the NDC value range is between [-1, 1]\n\t\t\t\t\tvec2 clipSpaceDelta = 0.5 * ( ( p1 / p1.w ).xy - ( p0 / p0.w ).xy );\n\t\t\t\t\tvec2 pixelDelta = abs( clipSpaceDelta * resolution );\n\n\t\t\t\t\t// amount of meter change per pixel\n\t\t\t\t\tfloat pixelsPerMeter = max( pixelDelta.x, pixelDelta.y );\n\t\t\t\t\tfloat metersPerPixel = 1.0 / pixelsPerMeter;\n\t\t\t\t\tfloat targetMeters = targetPixelsPerStep * metersPerPixel;\n\n\t\t\t\t\t// calculate the nearest power of 10 that the meters\n\t\t\t\t\tfloat nearestPow10 = log10( targetMeters );\n\t\t\t\t\tfloat topoAlpha = smoothstep( 1.0, 1.0 - FADE_SIZE, mod( nearestPow10, 1.0 ) );\n\t\t\t\t\tfloat topoStep = pow( 10.0, ceil( nearestPow10 ) );\n\n\t\t\t\t\t// get the height value to use for topo lines\n\t\t\t\t\tvec3 pos;\n\t\t\t\t\t#if USE_TOPO_ELLIPSOID\n\n\t\t\t\t\t\tvec3 surfaceNormal = vCartographic.xyz;\n\t\t\t\t\t\tpos.x = atan( surfaceNormal.y, surfaceNormal.x );\n\t\t\t\t\t\tpos.y = asin( surfaceNormal.z );\n\t\t\t\t\t\tpos.z = vCartographic.w;\n\n\t\t\t\t\t\t// TODO: why is multiplying by 1000 needed here?\n\t\t\t\t\t\tpos.xy *= 180.0 / PI;\n\t\t\t\t\t\tpos.x += 180.0;\n\t\t\t\t\t\tpos.xy *= 1000.0;\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tmat4 invFrame = inverse( frame );\n\t\t\t\t\t\tvec3 localPosition = ( invFrame * vec4( wPosition, 1 ) ).xyz;\n\t\t\t\t\t\tpos = vec3( localPosition.xy * 0.1, localPosition.z );\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t// calculate the step for the narrow and thick lines, limiting the minimum stride\n\t\t\t\t\tvec3 step0 = max( vec3( cartoLimit.xx, topoLimit.x ), vec3( topoStep ) );\n\t\t\t\t\tstep0 = min( vec3( cartoLimit.yy, topoLimit.y ), step0 );\n\n\t\t\t\t\tvec3 step1 = max( vec3( cartoLimit.xx, topoLimit.x ), vec3( topoStep * 10.0 ) );\n\t\t\t\t\tstep1 = min( vec3( cartoLimit.yy, topoLimit.y ), step1 );\n\n\t\t\t\t\t// thickness and emphasis of lines\n\t\t\t\t\tvec2 thickness0 = vec2( 1.0, 2.0 );\n\t\t\t\t\tvec2 thickness1 = vec2( 1.0, 2.0 );\n\t\t\t\t\tvec3 emphasisStride0 = vec3( 10.0 );\n\t\t\t\t\tvec3 emphasisStride1 = vec3( 10.0 );\n\t\t\t\t\t#if USE_TOPO_ELLIPSOID\n\n\t\t\t\t\t\t// If our stride is at the root level then adjust the lines and emphasis so it\n\t\t\t\t\t\t// lies on the quadrant axes\n\t\t\t\t\t\tif ( step0.x > 1e4 ) {\n\n\t\t\t\t\t\t\temphasisStride0.x = 3.0;\n\t\t\t\t\t\t\tstep0.x = 30.0 * 1000.0;\n\t\t\t\t\t\t\tstep0.y = 30.0 * 1000.0;\n\n\t\t\t\t\t\t} else if ( step0.x > 1e3 ) {\n\n\t\t\t\t\t\t\temphasisStride0.x = 9.0;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( step1.x > 1e4 ) {\n\n\t\t\t\t\t\t\temphasisStride1.x = 3.0;\n\t\t\t\t\t\t\tstep1.y = 30.0 * 1000.0;\n\t\t\t\t\t\t\tstep1.x = 30.0 * 1000.0;\n\n\n\t\t\t\t\t\t} else if ( step1.x > 1e3 ) {\n\n\t\t\t\t\t\t\temphasisStride1.x = 9.0;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tthickness0 *= thickness * pixelRatio;\n\t\t\t\t\tthickness1 *= thickness * pixelRatio;\n\n\t\t\t\t\t// calculate the topo line value\n\t\t\t\t\tvec3 posDelta = max( fwidth2( pos ), 1e-7 );\n\t\t\t\t\tvec3 topo0 = calculateTopoLines( pos, posDelta, step0, thickness0, emphasisStride0 );\n\t\t\t\t\tvec3 topo1 = calculateTopoLines( pos, posDelta, step1, thickness1, emphasisStride1 );\n\n\t\t\t\t\t// calculate the point to fade out the topographic lines based on the unclamped step\n\t\t\t\t\tvec3 maxFadeLimit = vec3( cartoFadeLimit.yy, topoFadeLimit.y );\n\t\t\t\t\tvec3 minFadeLimit = vec3( cartoFadeLimit.xx, topoFadeLimit.x );\n\t\t\t\t\tvec3 maxFadeLimitAlpha = 1.0 - smoothstep( maxFadeLimit * ( 1.0 - FADE_SIZE_HALF ), maxFadeLimit * ( 1.0 + FADE_SIZE_HALF ), vec3( pow( 10.0, nearestPow10 + 1.0 ) ) );\n\t\t\t\t\tvec3 minFadeLimitAlpha = smoothstep( minFadeLimit * ( 1.0 - FADE_SIZE_HALF ), minFadeLimit * ( 1.0 + FADE_SIZE_HALF ), vec3( pow( 10.0, nearestPow10 + 1.0 ) ) );\n\n\t\t\t\t\t// blend the small and large topo lines\n\t\t\t\t\tvec3 topo = mix( topo1, topo0, topoAlpha ) * maxFadeLimitAlpha * minFadeLimitAlpha;\n\n\t\t\t\t\t// blend with the base color\n\t\t\t\t\tdiffuseColor.rgb = mix( diffuseColor.rgb, cartoColor, max( topo.x * cartoOpacity, topo.y * cartoOpacity ) );\n\t\t\t\t\tdiffuseColor.rgb = mix( diffuseColor.rgb, topoColor, topo.z * topoOpacity );\n\n\t\t\t\t}\n\t\t\t\t#endif\n\n\t\t\t` );\n\n\t};\n\n\treturn params;\n\n}\n\nfunction addWorldPosition( shader ) {\n\n\tif ( /varying\\s+vec3\\s+wPosition/.test( shader.vertexShader ) ) {\n\n\t\treturn;\n\n\t}\n\n\tshader.vertexShader = /* glsl */`\n\t\t\tvarying vec3 wPosition;\n\t\t\t${ shader.vertexShader }\n\t\t`\n\t\t.replace(\n\t\t\t/#include <project_vertex>/,\n\t\t\tv => /* glsl */`\n\t\t\t\t${ v }\n\t\t\t\twPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;\n\t\t\t`,\n\t\t);\n\n\tshader.fragmentShader = /* glsl */`\n\t\tvarying vec3 wPosition;\n\t\t${ shader.fragmentShader }\n\t`;\n\n\treturn shader;\n\n}\n","import { Color, MathUtils, Matrix4, Mesh, Vector2, Vector3 } from 'three';\nimport { wrapTopoLineMaterial } from './wrapTopoLineMaterial.js';\n\nconst _vec = /* @__PURE__ */ new Vector3();\nconst _vec2 = /* @__PURE__ */ new Vector2();\nconst _pos = /* @__PURE__ */ new Vector3();\nconst _norm = /* @__PURE__ */ new Vector3();\nconst _surfacePoint = /* @__PURE__ */ new Vector3();\nconst _p0 = /* @__PURE__ */ new Vector3();\nconst _p1 = /* @__PURE__ */ new Vector3();\nconst _invFrame = /* @__PURE__ */ new Matrix4();\nconst _viewMatrix = /* @__PURE__ */ new Matrix4();\nconst _step0 = /* @__PURE__ */ new Vector3();\nconst _step1 = /* @__PURE__ */ new Vector3();\n\nclass ResolutionSampler extends Mesh {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.removeFromParent();\n\t\tthis.material.dispose();\n\t\tthis.geometry.dispose();\n\n\t}\n\n}\n\nexport class TopoLinesPlugin {\n\n\tget resolution() {\n\n\t\treturn this._resolution;\n\n\t}\n\n\tget topoOpacity() {\n\n\t\treturn this.topoOpacityUniform.value;\n\n\t}\n\n\tset topoOpacity( v ) {\n\n\t\tif ( this.topoOpacityUniform.value !== v ) {\n\n\t\t\tthis.topoOpacityUniform.value = v;\n\t\t\tthis.updateDefines();\n\n\t\t}\n\n\t}\n\n\tget cartoOpacity() {\n\n\t\treturn this.cartoOpacityUniform.value;\n\n\t}\n\n\tset cartoOpacity( v ) {\n\n\t\tif ( this.cartoOpacityUniform.value !== v ) {\n\n\t\t\tthis.cartoOpacityUniform.value = v;\n\t\t\tthis.updateDefines();\n\n\t\t}\n\n\t}\n\n\tget projection() {\n\n\t\treturn this._projection;\n\n\t}\n\n\tset projection( v ) {\n\n\t\tif ( v !== this._projection ) {\n\n\t\t\tthis._projection = v;\n\t\t\tthis.updateDefines();\n\n\t\t}\n\n\t}\n\n\tget thickness() {\n\n\t\treturn this.thicknessUniform.value;\n\n\t}\n\n\tset thickness( v ) {\n\n\t\tthis.thicknessUniform.value = v;\n\n\t}\n\n\tconstructor( options = {} ) {\n\n\t\tconst isPlanar = 'projection' in options ? options.projection === 'planar' : true;\n\n\t\tconst {\n\t\t\tprojection = 'planar',\n\n\t\t\tthickness = \t\t1,\n\n\t\t\t// options for topographic lines\n\t\t\t// \"topoLimit\" refers to the min and max distances between each topo line\n\t\t\t// \"topoFadeLimit\" refers to the fade in and out point of the topo lines as a whole\n\t\t\ttopoColor = \t\tnew Color( 0xffffff ),\n\t\t\ttopoOpacity = \t\t0.5,\n\t\t\ttopoLimit = \t\tisPlanar ? new Vector2( 0.1, 1e10 ) : new Vector2( 1, 1e10 ),\n\t\t\ttopoFadeLimit = \tisPlanar ? new Vector2( 0, 1e10 ) : new Vector2( 0, 4.25 * 1e3 ),\n\n\t\t\t// options for cartesian and cartographic lines when in planar and ellipsoid mode respectively\n\t\t\tcartoColor = \t\tnew Color( 0xffffff ),\n\t\t\tcartoOpacity = \t\tisPlanar ? 0 : 0.5,\n\t\t\tcartoLimit = \t\tnew Vector2( 0.1, 1e10 ),\n\t\t\tcartoFadeLimit = \tisPlanar ? new Vector2( 0, 1e10 ) : new Vector2( 4.5 * 1e3, 1e6 ),\n\t\t} = options;\n\n\t\tthis.name = 'TOPO_LINES_PLUGIN';\n\t\tthis.tiles = null;\n\n\t\tthis.thicknessUniform = { value: thickness };\n\n\t\tthis.topoColor = new Color().set( topoColor );\n\t\tthis.topoOpacityUniform = { value: topoOpacity };\n\t\tthis.topoLimit = new Vector2( ...topoLimit );\n\t\tthis.topoFadeLimit = new Vector2( ...topoFadeLimit );\n\n\t\tthis.cartoColor = new Color().set( cartoColor );\n\t\tthis.cartoOpacityUniform = { value: cartoOpacity };\n\t\tthis.cartoLimit = new Vector2( ...cartoLimit );\n\t\tthis.cartoFadeLimit = new Vector2( ...cartoFadeLimit );\n\n\t\tthis._projection = projection;\n\t\tthis._pixelRatioUniform = { value: 1 };\n\t\tthis._resolution = new Vector2( 1, 1 );\n\n\t\tthis._resolutionSampleObject = null;\n\n\t}\n\n\t// function for calculating the positioning of topographic lines at a given world position\n\tcomputeTopographicLineInfo( camera, worldPos, target = {} ) {\n\n\t\t// initialize the target\n\t\ttarget.alpha = 0;\n\t\ttarget.value = 0;\n\t\ttarget.fade = 0;\n\t\ttarget.emphasisStride = 0;\n\n\t\ttarget.min = target.min || {\n\t\t\tstep: 0,\n\t\t\tstepInPixels: 0,\n\t\t};\n\n\t\ttarget.max = target.max || {\n\t\t\tstep: 0,\n\t\t\tstepInPixels: 0,\n\t\t};\n\n\t\t// retrieve local variables\n\t\tconst { cartoLimit, cartoFadeLimit, topoLimit, topoFadeLimit } = this;\n\t\tconst pixelRatio = this._pixelRatioUniform.value;\n\t\tconst resolution = this._resolution;\n\t\tconst projection = this._projection;\n\t\tconst invFrame = _invFrame.copy( this.tiles.group.matrixWorld ).invert();\n\t\tconst viewMatrix = _viewMatrix.copy( camera.matrixWorld ).invert();\n\n\t\tconst FADE_SIZE = 0.25;\n\t\tconst FADE_SIZE_HALF = FADE_SIZE * 0.5;\n\n\t\t// port of calculation of topographic line stride\n\t\tconst targetPixelsPerStep = pixelRatio * 1.75;\n\n\t\t// calculate projected screen points\n\t\tconst distanceFromCamera = _vec.copy( worldPos ).applyMatrix4( viewMatrix ).z;\n\t\tconst p0 = _p0.set( 0, 0, distanceFromCamera ).applyMatrix4( camera.projectionMatrix );\n\t\tconst p1 = _p1.set( 1, 1, distanceFromCamera ).applyMatrix4( camera.projectionMatrix );\n\n\t\t// amount of pixel change per meter in screen space\n\t\t// multiple by 0.5 since the NDC value range is between [-1, 1]\n\t\tconst pixelDelta = _vec2.subVectors( p1, p0 ).multiply( resolution ).multiplyScalar( 0.5 );\n\n\t\t// amount of meter change per pixel\n\t\tconst pixelsPerMeter = Math.max( Math.abs( pixelDelta.x ), Math.abs( pixelDelta.y ) );\n\t\tconst metersPerPixel = 1.0 / pixelsPerMeter;\n\t\tconst targetMeters = targetPixelsPerStep * metersPerPixel;\n\n\t\t// calculate the nearest power of 10 that the meters\n\t\t// TODO: this pixel size target / topo step calculation is too much of an estimation\n\t\tconst nearestPow10 = Math.log10( targetMeters );\n\t\tconst topoAlpha = 1.0 - MathUtils.smoothstep( 1.0 - Math.abs( nearestPow10 % 1 ), 1.0 - FADE_SIZE, 1.0 );\n\t\tconst topoStep = Math.pow( 10.0, Math.ceil( nearestPow10 ) );\n\n\t\tif ( projection === 'ellipsoid' ) {\n\n\t\t\t_pos.copy( worldPos ).applyMatrix4( invFrame );\n\n\t\t\tconst ellipsoid = this.tiles.ellipsoid;\n\t\t\tellipsoid.getPositionToSurfacePoint( _pos, _surfacePoint );\n\t\t\tellipsoid.getPositionToNormal( _pos, _norm );\n\n\t\t\tconst height = _pos.distanceTo( _surfacePoint );\n\n\t\t\t_pos.x = Math.atan( _norm.y, _norm.x );\n\t\t\t_pos.y = Math.asin( _norm.z );\n\t\t\t_pos.z = height;\n\n\t\t\t_pos.x = _pos.x * MathUtils.RAD2DEG;\n\t\t\t_pos.y = _pos.x * MathUtils.RAD2DEG;\n\n\t\t\t_pos.x += 180;\n\n\t\t\t_pos.x *= 1000.0;\n\t\t\t_pos.y *= 1000.0;\n\n\t\t} else {\n\n\t\t\t_pos.copy( worldPos ).applyMatrix4( invFrame );\n\t\t\t_pos.x *= 0.1;\n\t\t\t_pos.y *= 0.1;\n\n\t\t}\n\n\t\t_step0.x = MathUtils.clamp( topoStep, cartoLimit.x, cartoLimit.y );\n\t\t_step0.y = MathUtils.clamp( topoStep, cartoLimit.x, cartoLimit.y );\n\t\t_step0.z = MathUtils.clamp( topoStep, topoLimit.x, topoLimit.y );\n\n\t\t_step1.x = MathUtils.clamp( topoStep * 10.0, cartoLimit.x, cartoLimit.y );\n\t\t_step1.y = MathUtils.clamp( topoStep * 10.0, cartoLimit.x, cartoLimit.y );\n\t\t_step1.z = MathUtils.clamp( topoStep * 10.0, topoLimit.x, topoLimit.y );\n\n\t\t// const maxFadeLimitAlphaCarto = 1.0 - MathUtils.smoothstep( cartoFadeLimit.y * ( 1.0 - FADE_SIZE_HALF ), cartoFadeLimit.y * ( 1.0 + FADE_SIZE_HALF ), Math.pow( 10.0, nearestPow10 + 1.0 ) );\n\t\t// const minFadeLimitAlphaCarto = MathUtils.smoothstep( cartoFadeLimit.x * 0.75, cartoFadeLimit.x * 1.25, Math.pow( 10.0, nearestPow10 + 1.0 ) );\n\t\tconst maxFadeLimitAlphaTopo = 1.0 - MathUtils.smoothstep( topoFadeLimit.y * ( 1.0 - FADE_SIZE_HALF ), topoFadeLimit.y * ( 1.0 + FADE_SIZE_HALF ), Math.pow( 10.0, nearestPow10 + 1.0 ) );\n\t\tconst minFadeLimitAlphaTopo = MathUtils.smoothstep( cartoFadeLimit.y * ( 1.0 - FADE_SIZE_HALF ), cartoFadeLimit.y * ( 1.0 + FADE_SIZE_HALF ), Math.pow( 10.0, nearestPow10 + 1.0 ) );\n\n\t\t// result\n\t\ttarget.alpha = topoAlpha;\n\t\ttarget.fade = maxFadeLimitAlphaTopo * minFadeLimitAlphaTopo;\n\t\ttarget.value = _pos.z;\n\n\t\ttarget.min.step = _step0.z;\n\t\ttarget.min.stepInPixels = _step0.z * pixelsPerMeter;\n\t\ttarget.max.step = _step1.z;\n\t\ttarget.max.stepInPixels = _step1.z * pixelsPerMeter;\n\n\t\treturn target;\n\n\t}\n\n\tinit( tiles ) {\n\n\t\tthis.tiles = tiles;\n\n\t\t// Create an empty\n\t\tconst resolutionSampleObject = new ResolutionSampler();\n\t\tresolutionSampleObject.frustumCulled = false;\n\t\tresolutionSampleObject.onBeforeRender = renderer => {\n\n\t\t\tconst renderTarget = renderer.getRenderTarget();\n\t\t\tif ( renderTarget ) {\n\n\t\t\t\tthis._resolution.width = renderTarget.width;\n\t\t\t\tthis._resolution.height = renderTarget.height;\n\t\t\t\tthis._pixelRatioUniform.value = 1;\n\n\t\t\t} else {\n\n\t\t\t\trenderer.getDrawingBufferSize( this._resolution );\n\t\t\t\tthis._pixelRatioUniform.value = renderer.getPixelRatio();\n\n\t\t\t}\n\n\t\t};\n\n\t\ttiles.group.add( resolutionSampleObject );\n\t\tthis._resolutionSampleObject = resolutionSampleObject;\n\n\t\ttiles.forEachLoadedModel( scene => {\n\n\t\t\tthis.processTileModel( scene );\n\n\t\t} );\n\n\t}\n\n\tupdateDefines( scene = null ) {\n\n\t\tconst USE_TOPO_ELLIPSOID = Number( this.projection === 'ellipsoid' );\n\t\tconst USE_TOPO_LINES = Number( ! ! ( this.topoOpacity + this.cartoOpacity ) );\n\t\tconst update = scene => {\n\n\t\t\tscene.traverse( c => {\n\n\t\t\t\tif ( c.material ) {\n\n\t\t\t\t\tconst { defines } = c.material;\n\t\t\t\t\tif ( defines.USE_TOPO_ELLIPSOID !== USE_TOPO_ELLIPSOID ) {\n\n\t\t\t\t\t\tdefines.USE_TOPO_ELLIPSOID = USE_TOPO_ELLIPSOID;\n\t\t\t\t\t\tc.material.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( defines.USE_TOPO_LINES !== USE_TOPO_LINES ) {\n\n\t\t\t\t\t\tdefines.USE_TOPO_LINES = USE_TOPO_LINES;\n\t\t\t\t\t\tc.material.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t};\n\n\t\tif ( scene !== null ) {\n\n\t\t\tupdate( scene );\n\n\t\t} else {\n\n\t\t\tthis.tiles.forEachLoadedModel( update );\n\n\t\t}\n\n\t}\n\n\tprocessTileModel( scene, tile ) {\n\n\t\tconst { tiles } = this;\n\t\tscene.traverse( c => {\n\n\t\t\tif ( c.material ) {\n\n\t\t\t\tconst params = wrapTopoLineMaterial( c.material, c.material.onBeforeCompile );\n\t\t\t\tparams.ellipsoid.value = tiles.ellipsoid.radius;\n\t\t\t\tparams.frame.value = tiles.group.matrixWorld;\n\n\t\t\t\tparams.thickness = this.thicknessUniform;\n\n\t\t\t\tparams.topoColor.value = this.topoColor;\n\t\t\t\tparams.topoOpacity = this.topoOpacityUniform;\n\t\t\t\tparams.topoLimit.value = this.topoLimit;\n\t\t\t\tparams.topoFadeLimit.value = this.topoFadeLimit;\n\n\t\t\t\tparams.cartoColor.value = this.cartoColor;\n\t\t\t\tparams.cartoOpacity = this.cartoOpacityUniform;\n\t\t\t\tparams.cartoLimit.value = this.cartoLimit;\n\t\t\t\tparams.cartoFadeLimit.value = this.cartoFadeLimit;\n\n\t\t\t\tparams.resolution.value = this._resolution;\n\t\t\t\tparams.pixelRatio = this._pixelRatioUniform;\n\n\t\t\t\tc.material.defines.USE_TOPO_ELLIPSOID = Number( this.projection === 'ellipsoid' );\n\t\t\t\tc.material.needsUpdate = true;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tthis.updateDefines( scene );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.cartoOpacity = 0;\n\t\tthis.topoOpacity = 0;\n\n\t\tthis.updateDefines();\n\n\t\tthis._resolutionSampleObject.dispose();\n\n\t\t// dispose of all the materials to force a shader rebuild of the shader since the behavior relies on\n\t\t// assigning uniforms parameters\n\t\tthis.tiles.forEachLoadedModel( scene => {\n\n\t\t\tscene.traverse( c => {\n\n\t\t\t\tif ( c.material ) {\n\n\t\t\t\t\tc.material.dispose();\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n}\n"],"names":["TOPO_PARAMS","ELLIPSOID_FUNC","MATH_FUNC","wrapTopoLineMaterial","material","previousOnBeforeCompile","params","Vector2","Vector3","Matrix4","Color","shader","addWorldPosition","value","v","_vec","_vec2","_pos","_norm","_surfacePoint","_p0","_p1","_invFrame","_viewMatrix","_step0","_step1","ResolutionSampler","Mesh","TopoLinesPlugin","options","isPlanar","projection","thickness","topoColor","topoOpacity","topoLimit","topoFadeLimit","cartoColor","cartoOpacity","cartoLimit","cartoFadeLimit","camera","worldPos","target","pixelRatio","resolution","invFrame","viewMatrix","FADE_SIZE","FADE_SIZE_HALF","targetPixelsPerStep","distanceFromCamera","p0","p1","pixelDelta","pixelsPerMeter","metersPerPixel","targetMeters","nearestPow10","topoAlpha","MathUtils","topoStep","ellipsoid","height","maxFadeLimitAlphaTopo","minFadeLimitAlphaTopo","tiles","resolutionSampleObject","renderer","renderTarget","scene","USE_TOPO_ELLIPSOID","USE_TOPO_LINES","update","c","defines","tile"],"mappings":"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"}