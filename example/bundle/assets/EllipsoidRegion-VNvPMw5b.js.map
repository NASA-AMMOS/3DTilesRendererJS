{"version":3,"file":"EllipsoidRegion-VNvPMw5b.js","sources":["../../../src/three/renderer/math/EllipsoidRegion.js"],"sourcesContent":["import { Matrix4, Vector3, Box3 } from 'three';\nimport { Ellipsoid } from './Ellipsoid.js';\n\n// bounds are lightly inflated to account for floating point error\nconst INFLATE_EPSILON = 1e-13;\nconst PI = Math.PI;\nconst HALF_PI = PI / 2;\n\nconst _orthoX = /* @__PURE__*/ new Vector3();\nconst _orthoY = /* @__PURE__*/ new Vector3();\nconst _orthoZ = /* @__PURE__*/ new Vector3();\nconst _vec = /* @__PURE__*/ new Vector3();\nconst _invMatrix = /* @__PURE__*/ new Matrix4();\nconst _box = /* @__PURE__*/ new Box3();\nconst _matrix = /* @__PURE__*/ new Matrix4();\n\nfunction expandSphereRadiusSquared( vec, target ) {\n\n\ttarget.radius = Math.max( target.radius, vec.distanceToSquared( target.center ) );\n\n}\n\nfunction isTriaxial( radii ) {\n\n\treturn radii.x !== radii.y;\n\n}\n\nexport class EllipsoidRegion extends Ellipsoid {\n\n\tconstructor(\n\t\tx = 1, y = 1, z = 1,\n\t\tlatStart = - HALF_PI, latEnd = HALF_PI,\n\t\tlonStart = 0, lonEnd = 2 * PI,\n\t\theightStart = 0, heightEnd = 0\n\t) {\n\n\t\tsuper( x, y, z );\n\t\tthis.latStart = latStart;\n\t\tthis.latEnd = latEnd;\n\t\tthis.lonStart = lonStart;\n\t\tthis.lonEnd = lonEnd;\n\t\tthis.heightStart = heightStart;\n\t\tthis.heightEnd = heightEnd;\n\n\t}\n\n\tgetBoundingBox( box, matrix ) {\n\n\t\tif ( isTriaxial( this.radius ) ) {\n\n\t\t\tconsole.warn( 'EllipsoidRegion: Triaxial ellipsoids are not supported.' );\n\n\t\t}\n\n\t\tconst {\n\t\t\tlatStart, latEnd,\n\t\t\tlonStart, lonEnd,\n\t\t\theightStart, heightEnd,\n\t\t} = this;\n\n\t\tconst latMid = ( latStart + latEnd ) * 0.5;\n\t\tconst lonMid = ( lonStart + lonEnd ) * 0.5;\n\t\tconst allAboveEquator = latStart > 0.0;\n\t\tconst allBelowEquator = latEnd < 0.0;\n\n\t\tlet nearEquatorLat;\n\t\tif ( allAboveEquator ) {\n\n\t\t\tnearEquatorLat = latStart;\n\n\t\t} else if ( allBelowEquator ) {\n\n\t\t\tnearEquatorLat = latEnd;\n\n\t\t} else {\n\n\t\t\tnearEquatorLat = 0;\n\n\t\t}\n\n\t\t// measure the extents\n\t\tconst { min, max } = box;\n\t\tmin.setScalar( Infinity );\n\t\tmax.setScalar( - Infinity );\n\t\tif ( lonEnd - lonStart <= PI ) {\n\n\t\t\t// extract the axes\n\t\t\tthis.getCartographicToNormal( latMid, lonMid, _orthoZ );\n\t\t\t_orthoY.set( 0, 0, 1 );\n\t\t\t_orthoX.crossVectors( _orthoY, _orthoZ ).normalize();\n\t\t\t_orthoY.crossVectors( _orthoZ, _orthoX ).normalize();\n\n\t\t\t// construct the frame\n\t\t\tmatrix.makeBasis( _orthoX, _orthoY, _orthoZ );\n\t\t\t_invMatrix.copy( matrix ).invert();\n\n\t\t\t// extract x\n\t\t\t// check the most bowing point near the equator relative to the frame\n\t\t\tthis.getCartographicToPosition( nearEquatorLat, lonStart, heightEnd, _vec ).applyMatrix4( _invMatrix );\n\t\t\tmax.x = Math.abs( _vec.x );\n\t\t\tmin.x = - max.x;\n\n\t\t\t// extract y\n\t\t\t// check corners and mid points for the top\n\t\t\tthis.getCartographicToPosition( latEnd, lonStart, heightEnd, _vec ).applyMatrix4( _invMatrix );\n\t\t\tmax.y = _vec.y;\n\n\t\t\tthis.getCartographicToPosition( latEnd, lonMid, heightEnd, _vec ).applyMatrix4( _invMatrix );\n\t\t\tmax.y = Math.max( _vec.y, max.y );\n\n\t\t\t// check corners and mid points for the bottom\n\t\t\tthis.getCartographicToPosition( latStart, lonStart, heightEnd, _vec ).applyMatrix4( _invMatrix );\n\t\t\tmin.y = _vec.y;\n\n\t\t\tthis.getCartographicToPosition( latStart, lonMid, heightEnd, _vec ).applyMatrix4( _invMatrix );\n\t\t\tmin.y = Math.min( _vec.y, min.y );\n\n\t\t\t// extract z\n\t\t\t// check center point\n\t\t\tthis.getCartographicToPosition( latMid, lonMid, heightEnd, _vec ).applyMatrix4( _invMatrix );\n\t\t\tmax.z = _vec.z;\n\n\t\t\t// check top and bottom reverse points\n\t\t\tthis.getCartographicToPosition( latStart, lonStart, heightStart, _vec ).applyMatrix4( _invMatrix );\n\t\t\tmin.z = _vec.z;\n\n\t\t\tthis.getCartographicToPosition( latEnd, lonStart, heightStart, _vec ).applyMatrix4( _invMatrix );\n\t\t\tmin.z = Math.min( _vec.z, min.z );\n\n\t\t} else {\n\n\t\t\t// extract a vector towards the middle of the region\n\t\t\tthis.getCartographicToPosition( nearEquatorLat, lonMid, heightEnd, _orthoZ );\n\t\t\t_orthoZ.z = 0;\n\t\t\tif ( _orthoZ.length() < 1e-10 ) {\n\n\t\t\t\t_orthoZ.set( 1, 0, 0 );\n\n\t\t\t} else {\n\n\t\t\t\t_orthoZ.normalize();\n\n\t\t\t}\n\n\t\t\t_orthoY.set( 0, 0, 1 );\n\t\t\t_orthoX.crossVectors( _orthoZ, _orthoY ).normalize();\n\n\t\t\t// construct the OBB frame\n\t\t\tmatrix.makeBasis( _orthoX, _orthoY, _orthoZ );\n\t\t\t_invMatrix.copy( matrix ).invert();\n\n\t\t\t// x extents\n\t\t\t// find the furthest point rotated 90 degrees from the center of the region\n\t\t\tthis.getCartographicToPosition( nearEquatorLat, lonMid + HALF_PI, heightEnd, _vec ).applyMatrix4( _invMatrix );\n\t\t\tmax.x = Math.abs( _vec.x );\n\t\t\tmin.x = - max.x;\n\n\t\t\t// y extents\n\t\t\t// measure the top of the region, accounting for the diagonal tilt of the edge\n\t\t\tthis.getCartographicToPosition( latEnd, 0, allBelowEquator ? heightStart : heightEnd, _vec ).applyMatrix4( _invMatrix );\n\t\t\tmax.y = _vec.y;\n\n\t\t\t// measure the bottom of the region, accounting for the diagonal tilt of the edge\n\t\t\tthis.getCartographicToPosition( latStart, 0, allAboveEquator ? heightStart : heightEnd, _vec ).applyMatrix4( _invMatrix );\n\t\t\tmin.y = _vec.y;\n\n\t\t\t// z extends\n\t\t\t// measure the furthest point at the center of the region\n\t\t\tthis.getCartographicToPosition( nearEquatorLat, lonMid, heightEnd, _vec ).applyMatrix4( _invMatrix );\n\t\t\tmax.z = _vec.z;\n\n\t\t\t// measure the opposite end, which is guaranteed to be at the furthest extents since this lon region extents is > PI\n\t\t\tthis.getCartographicToPosition( nearEquatorLat, lonEnd, heightEnd, _vec ).applyMatrix4( _invMatrix );\n\t\t\tmin.z = _vec.z;\n\n\t\t}\n\n\t\t// center the frame\n\t\tbox.getCenter( _vec );\n\t\tbox.min.sub( _vec ).multiplyScalar( 1 + INFLATE_EPSILON );\n\t\tbox.max.sub( _vec ).multiplyScalar( 1 + INFLATE_EPSILON );\n\n\t\t_vec.applyMatrix4( matrix );\n\t\tmatrix.setPosition( _vec );\n\n\t}\n\n\tgetBoundingSphere( sphere ) {\n\n\t\tif ( isTriaxial( this.radius ) ) {\n\n\t\t\tconsole.warn( 'EllipsoidRegion: Triaxial ellipsoids are not supported.' );\n\n\t\t}\n\n\t\t// TODO: this could be optimized or the OBB could be generated at the same time since\n\t\t// a lot of the the points are reused\n\n\t\t// use the OBB function to get a reasonable center\n\t\tthis.getBoundingBox( _box, _matrix );\n\t\tsphere.center.setFromMatrixPosition( _matrix );\n\t\tsphere.radius = 0;\n\n\t\tconst {\n\t\t\tlatStart, latEnd,\n\t\t\tlonStart, lonEnd,\n\t\t\theightStart, heightEnd,\n\t\t} = this;\n\n\t\tconst latMid = ( latStart + latEnd ) * 0.5;\n\t\tconst lonMid = ( lonStart + lonEnd ) * 0.5;\n\t\tconst allAboveEquator = latStart > 0.0;\n\t\tconst allBelowEquator = latEnd < 0.0;\n\n\t\tlet nearEquatorLat;\n\t\tif ( allAboveEquator ) {\n\n\t\t\tnearEquatorLat = latStart;\n\n\t\t} else if ( allBelowEquator ) {\n\n\t\t\tnearEquatorLat = latEnd;\n\n\t\t} else {\n\n\t\t\tnearEquatorLat = 0;\n\n\t\t}\n\n\t\t// lon start extremity\n\t\tthis.getCartographicToPosition( nearEquatorLat, lonStart, heightEnd, _vec );\n\t\texpandSphereRadiusSquared( _vec, sphere );\n\n\t\t// check corners and mid points for the top\n\t\tthis.getCartographicToPosition( latEnd, lonStart, heightEnd, _vec );\n\t\texpandSphereRadiusSquared( _vec, sphere );\n\n\t\tthis.getCartographicToPosition( latEnd, lonMid, heightEnd, _vec );\n\t\texpandSphereRadiusSquared( _vec, sphere );\n\n\t\t// check corners and mid points for the bottom\n\t\tthis.getCartographicToPosition( latStart, lonStart, heightEnd, _vec );\n\t\texpandSphereRadiusSquared( _vec, sphere );\n\n\t\tthis.getCartographicToPosition( latStart, lonMid, heightEnd, _vec );\n\t\texpandSphereRadiusSquared( _vec, sphere );\n\n\t\t// check center extremity\n\t\tthis.getCartographicToPosition( latMid, lonMid, heightEnd, _vec );\n\t\texpandSphereRadiusSquared( _vec, sphere );\n\n\t\t// check lower height extremity\n\t\tthis.getCartographicToPosition( latStart, lonStart, heightStart, _vec );\n\t\texpandSphereRadiusSquared( _vec, sphere );\n\n\t\t// check 90 degree offset if range is larger than PI\n\t\tif ( lonEnd - lonStart > PI ) {\n\n\t\t\tthis.getCartographicToPosition( nearEquatorLat, lonMid + PI, heightEnd, _vec );\n\t\t\texpandSphereRadiusSquared( _vec, sphere );\n\n\t\t}\n\n\t\tsphere.radius = Math.sqrt( sphere.radius ) * ( 1 + INFLATE_EPSILON );\n\n\t}\n\n}\n"],"names":["INFLATE_EPSILON","PI","HALF_PI","_orthoX","Vector3","_orthoY","_orthoZ","_vec","_invMatrix","Matrix4","_box","Box3","_matrix","expandSphereRadiusSquared","vec","target","isTriaxial","radii","EllipsoidRegion","Ellipsoid","x","y","z","latStart","latEnd","lonStart","lonEnd","heightStart","heightEnd","box","matrix","latMid","lonMid","allAboveEquator","allBelowEquator","nearEquatorLat","min","max","sphere"],"mappings":"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"}