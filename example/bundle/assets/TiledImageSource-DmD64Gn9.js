import{M as c,b4 as y,N,T as z}from"./three.module-D-uF--xd.js";class Y{get isMercator(){return this.scheme==="EPSG:3857"}constructor(t="EPSG:4326"){this.scheme=t,this.tileCountX=1,this.tileCountY=1,this.setScheme(t)}setScheme(t){switch(this.scheme=t,t){case"CRS:84":case"EPSG:4326":this.tileCountX=2,this.tileCountY=1;break;case"EPSG:3857":this.tileCountX=1,this.tileCountY=1;break;case"none":this.tileCountX=1,this.tileCountY=1;break;default:throw new Error(`ProjectionScheme: Unknown projection scheme "${t}"`)}}convertNormalizedToLatitude(t){if(this.scheme==="none")return t;if(this.isMercator){const i=c.mapLinear(t,0,1,-1,1);return 2*Math.atan(Math.exp(i*Math.PI))-Math.PI/2}else return c.mapLinear(t,0,1,-Math.PI/2,Math.PI/2)}convertNormalizedToLongitude(t){return this.scheme==="none"?t:c.mapLinear(t,0,1,-Math.PI,Math.PI)}convertLatitudeToNormalized(t){if(this.scheme==="none")return t;if(this.isMercator){const i=Math.log(Math.tan(Math.PI/4+t/2));return 1/2+1*i/(2*Math.PI)}else return c.mapLinear(t,-Math.PI/2,Math.PI/2,0,1)}convertLongitudeToNormalized(t){return this.scheme==="none"?t:(t+Math.PI)/(2*Math.PI)}getLongitudeDerivativeAtNormalized(t){return this.scheme==="none"?1:2*Math.PI}getLatitudeDerivativeAtNormalized(t){if(this.scheme==="none")return 1;{let e=t-1e-5;return e<0&&(e=t+1e-5),this.isMercator?Math.abs(this.convertNormalizedToLatitude(t)-this.convertNormalizedToLatitude(e))/1e-5:Math.PI}}getBounds(){return this.scheme==="none"?[0,0,1,1]:[this.convertNormalizedToLongitude(0),this.convertNormalizedToLatitude(0),this.convertNormalizedToLongitude(1),this.convertNormalizedToLatitude(1)]}toNormalizedPoint(t,i){const e=[t,i];return e[0]=this.convertLongitudeToNormalized(e[0]),e[1]=this.convertLatitudeToNormalized(e[1]),e}toNormalizedRange(t){return[...this.toNormalizedPoint(t[0],t[1]),...this.toNormalizedPoint(t[2],t[3])]}toCartographicPoint(t,i){const e=[t,i];return e[0]=this.convertNormalizedToLongitude(e[0]),e[1]=this.convertNormalizedToLatitude(e[1]),e}toCartographicRange(t){return[...this.toCartographicPoint(t[0],t[1]),...this.toCartographicPoint(t[2],t[3])]}clampToBounds(t,i=!1){const e=[...t];let n;i?n=[0,0,1,1]:n=this.getBounds();const[o,s,r,a]=n;return e[0]=c.clamp(e[0],o,r),e[1]=c.clamp(e[1],s,a),e[2]=c.clamp(e[2],o,r),e[3]=c.clamp(e[3],s,a),e}}function B(...T){return T.join("_")}class I{constructor(){this.cache={},this.count=0,this.cachedBytes=0,this.active=0}fetchItem(){}disposeItem(){}getMemoryUsage(t){return 0}setData(...t){const{cache:i}=this,e=t.pop(),n=B(...t);if(n in i)throw new Error(`DataCache: "${n}" is already present.`);return this.cache[n]={abortController:new AbortController,result:e,count:1,bytes:this.getMemoryUsage(e)},this.count++,this.cachedBytes+=this.cache[n].bytes,e}lock(...t){const{cache:i}=this,e=B(...t);if(e in i)i[e].count++;else{const n=new AbortController,o={abortController:n,result:null,count:1,bytes:0,args:t};this.active++,o.result=this.fetchItem(t,n.signal),o.result instanceof Promise?o.result.then(s=>(o.result=s,o.bytes=this.getMemoryUsage(s),this.cachedBytes+=o.bytes,s)).finally(()=>{this.active--}).catch(s=>{}):(this.active--,o.bytes=this.getMemoryUsage(o.result),this.cachedBytes+=o.bytes),this.cache[e]=o,this.count++}return i[e].result}release(...t){const i=B(...t);this.releaseViaFullKey(i)}get(...t){const{cache:i}=this,e=B(...t);return e in i&&i[e].count>0?i[e].result:null}has(...t){const{cache:i}=this;return B(...t)in i}forEachItem(t){const{cache:i}=this;for(const e in i){const n=i[e];n.result instanceof Promise||t(n.result,n.args)}}dispose(){const{cache:t}=this;for(const i in t){const{abortController:e}=t[i];e.abort(),this.releaseViaFullKey(i,!0)}this.cache={}}releaseViaFullKey(t,i=!1){const{cache:e}=this;if(t in e&&e[t].count>0){const n=e[t];if(n.count--,n.count===0||i){const o=()=>{if(e[t]!==n)return;const{result:s,abortController:r}=n;r.abort(),s instanceof Promise?s.then(a=>{this.disposeItem(a),this.count--,this.cachedBytes-=n.bytes}).catch(()=>{}):(this.disposeItem(s),this.count--,this.cachedBytes-=n.bytes),delete e[t]};i?o():queueMicrotask(()=>{n.count===0&&o()})}return!0}throw new Error("DataCache: Attempting to release key that does not exist")}}function C(T,t){const[i,e,n,o]=T,[s,r,a,h]=t;return!(i>=a||n<=s||e>=h||o<=r)}class b{get levelCount(){return this._levels.length}get maxLevel(){return this.levelCount-1}get minLevel(){const t=this._levels;for(let i=0;i<t.length;i++)if(t[i]!==null)return i;return-1}get contentBounds(){return this._contentBounds??this.projection.getBounds()}get aspectRatio(){const{pixelWidth:t,pixelHeight:i}=this.getLevel(this.maxLevel);return t/i}constructor(){this.flipY=!1,this.pixelOverlap=0,this._contentBounds=null,this.projection=new Y("none"),this._levels=[]}setLevel(t,i={}){const e=this._levels;for(;e.length<t;)e.push(null);const{tileSplitX:n=2,tileSplitY:o=2}=i,{tilePixelWidth:s=256,tilePixelHeight:r=256,tileCountX:a=n**t,tileCountY:h=o**t,tileBounds:m=null}=i,{pixelWidth:u=s*a,pixelHeight:d=r*h}=i;e[t]={tilePixelWidth:s,tilePixelHeight:r,pixelWidth:u,pixelHeight:d,tileCountX:a,tileCountY:h,tileSplitX:n,tileSplitY:o,tileBounds:m}}generateLevels(t,i,e,n={}){const{minLevel:o=0,tilePixelWidth:s=256,tilePixelHeight:r=256}=n,a=t-1,{pixelWidth:h=s*i*2**a,pixelHeight:m=r*e*2**a}=n;for(let u=o;u<t;u++){const d=t-u-1,M=Math.ceil(h*2**-d),f=Math.ceil(m*2**-d),p=Math.ceil(M/s),L=Math.ceil(f/r);this.setLevel(u,{tilePixelWidth:s,tilePixelHeight:r,pixelWidth:M,pixelHeight:f,tileCountX:p,tileCountY:L})}}getLevel(t){return this._levels[t]}setContentBounds(t,i,e,n){this._contentBounds=[t,i,e,n]}setProjection(t){this.projection=t}getTileAtPoint(t,i,e,n=!1){const{flipY:o}=this,{tileCountX:s,tileCountY:r,tileBounds:a}=this.getLevel(e),h=1/s,m=1/r;if(n||([t,i]=this.toNormalizedPoint(t,i)),a){const M=this.toNormalizedRange(a);t=c.mapLinear(t,M[0],M[2],0,1),i=c.mapLinear(i,M[1],M[3],0,1)}const u=Math.floor(t/h);let d=Math.floor(i/m);return o&&(d=r-1-d),[u,d]}getTilesInRange(t,i,e,n,o,s=!1){const r=[t,i,e,n],a=this.getContentBounds(s);let h=this.getLevel(o).tileBounds;if(!C(r,a))return[0,0,-1,-1];if(h&&(s&&(h=this.toNormalizedRange(h)),!C(r,a)))return[0,0,-1,-1];const[m,u,d,M]=this.clampToContentBounds(r,s),f=this.getTileAtPoint(m,u,o,s),p=this.getTileAtPoint(d,M,o,s);this.flipY&&([f[1],p[1]]=[p[1],f[1]]);const{tileCountX:L,tileCountY:x}=this.getLevel(o),[l,g]=f,[v,P]=p;return v<0||P<0||l>=L||g>=x?[0,0,-1,-1]:[c.clamp(l,0,L-1),c.clamp(g,0,x-1),c.clamp(v,0,L-1),c.clamp(P,0,x-1)]}getTileExists(t,i,e){const[n,o,s,r]=this.contentBounds,[a,h,m,u]=this.getTileBounds(t,i,e);return!(a>=m||h>=u)&&a<=s&&h<=r&&m>=n&&u>=o}getContentBounds(t=!1){const{projection:i}=this,e=[...this.contentBounds];return t&&(e[0]=i.convertLongitudeToNormalized(e[0]),e[1]=i.convertLatitudeToNormalized(e[1]),e[2]=i.convertLongitudeToNormalized(e[2]),e[3]=i.convertLatitudeToNormalized(e[3])),e}getTileContentUVBounds(t,i,e){const[n,o,s,r]=this.getTileBounds(t,i,e,!0,!0),[a,h,m,u]=this.getTileBounds(t,i,e,!0,!1);return[c.mapLinear(n,a,m,0,1),c.mapLinear(o,h,u,0,1),c.mapLinear(s,a,m,0,1),c.mapLinear(r,h,u,0,1)]}getTileBounds(t,i,e,n=!1,o=!0){const{flipY:s,pixelOverlap:r,projection:a}=this,{tilePixelWidth:h,tilePixelHeight:m,pixelWidth:u,pixelHeight:d,tileBounds:M}=this.getLevel(e);let f=h*t-r,p=m*i-r,L=f+h+r*2,x=p+m+r*2;if(f=Math.max(f,0),p=Math.max(p,0),L=Math.min(L,u),x=Math.min(x,d),f=f/u,L=L/u,p=p/d,x=x/d,s){const g=(x-p)/2,P=1-(p+x)/2;p=P-g,x=P+g}let l=[f,p,L,x];if(M){const g=this.toNormalizedRange(M);l[0]=c.mapLinear(l[0],0,1,g[0],g[2]),l[2]=c.mapLinear(l[2],0,1,g[0],g[2]),l[1]=c.mapLinear(l[1],0,1,g[1],g[3]),l[3]=c.mapLinear(l[3],0,1,g[1],g[3])}return o&&(l=this.clampToBounds(l,!0)),n||(l[0]=a.convertNormalizedToLongitude(l[0]),l[1]=a.convertNormalizedToLatitude(l[1]),l[2]=a.convertNormalizedToLongitude(l[2]),l[3]=a.convertNormalizedToLatitude(l[3])),l}toNormalizedPoint(t,i){return this.projection.toNormalizedPoint(t,i)}toNormalizedRange(t){return this.projection.toNormalizedRange(t)}toCartographicPoint(t,i){return this.projection.toCartographicPoint(t,i)}toCartographicRange(t){return this.projection.toCartographicRange(t)}clampToContentBounds(t,i=!1){const e=[...t],[n,o,s,r]=this.getContentBounds(i);return e[0]=c.clamp(e[0],n,s),e[1]=c.clamp(e[1],o,r),e[2]=c.clamp(e[2],n,s),e[3]=c.clamp(e[3],o,r),e}clampToBounds(t,i=!1){return this.projection.clampToBounds(t,i)}}class X extends I{constructor(t={}){super();const{fetchOptions:i={}}=t;this.tiling=new b,this.fetchOptions=i,this.fetchData=(...e)=>fetch(...e)}init(){}async processBufferToTexture(t){const i=new Blob([t]),e=await createImageBitmap(i,{premultiplyAlpha:"none",colorSpaceConversion:"none",imageOrientation:"flipY"}),n=new y(e);return n.generateMipmaps=!1,n.colorSpace=N,n.needsUpdate=!0,n}getMemoryUsage(t){const{format:i,type:e,image:n,generateMipmaps:o}=t,{width:s,height:r}=n,a=z.getByteLength(s,r,i,e);return o?a*4/3:a}fetchItem(t,i){const e={...this.fetchOptions,signal:i},n=this.getUrl(...t);return this.fetchData(n,e).then(o=>o.arrayBuffer()).then(o=>this.processBufferToTexture(o))}disposeItem(t){t.dispose(),t.image instanceof ImageBitmap&&t.image.close()}getUrl(...t){}}export{I as D,Y as P,X as T,b as a};
//# sourceMappingURL=TiledImageSource-DmD64Gn9.js.map
