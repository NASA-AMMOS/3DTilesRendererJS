import{a_ as C,h as U,s as V,V as B,M as b}from"./three.module-D-uF--xd.js";const p=new B,f=Symbol("TILE_X"),L=Symbol("TILE_Y"),x=Symbol("TILE_LEVEL");class M{get tiling(){return this.imageSource.tiling}constructor(t={}){const{pixelSize:e=null,center:i=!1,useRecommendedSettings:s=!0,imageSource:n=null}=t;this.priority=-10,this.tiles=null,this.imageSource=n,this.pixelSize=e,this.center=i,this.useRecommendedSettings=s,e!==null&&console.warn('ImageFormatPlugin: "pixelSize" has been deprecated in favor of scaling the tiles root.')}init(t){this.useRecommendedSettings&&(t.errorTarget=1),this.tiles=t,this.imageSource.fetchOptions=t.fetchOptions,this.imageSource.fetchData=(e,i)=>(t.invokeAllPlugins(s=>e=s.preprocessURL?s.preprocessURL(e,null):e),t.invokeOnePlugin(s=>s!==this&&s.fetchData&&s.fetchData(e,i)))}async loadRootTileset(){const{tiles:t,imageSource:e}=this;return e.url=e.url||t.rootURL,t.invokeAllPlugins(i=>e.url=i.preprocessURL?i.preprocessURL(e.url,null):e.url),await e.init(),t.rootURL=e.url,this.getTileset(e.url)}async parseToMesh(t,e,i,s,n){if(n.aborted)return null;const{imageSource:o}=this,c=e[f],r=e[L],l=e[x],a=await o.processBufferToTexture(t);if(n.aborted)return a.dispose(),a.image.close(),null;o.setData(c,r,l,a);let h=1,S=1,g=0,d=0,m=0;const u=e.boundingVolume.box;u&&([g,d,m]=u,h=u[3],S=u[7]);const R=new C(2*h,2*S),y=new U(R,new V({map:a,transparent:!0}));y.position.set(g,d,m);const v=o.tiling.getTileContentUVBounds(c,r,l),{uv:T}=R.attributes;for(let E=0;E<T.count;E++)p.fromBufferAttribute(T,E),p.x=b.mapLinear(p.x,0,1,v[0],v[2]),p.y=b.mapLinear(p.y,0,1,v[1],v[3]),T.setXY(E,p.x,p.y);return y}preprocessNode(t){const{tiling:e}=this,i=e.maxLevel;t[x]<i&&t.parent!==null&&this.expandChildren(t)}disposeTile(t){const e=t[f],i=t[L],s=t[x],{imageSource:n}=this;n.has(e,i,s)&&n.release(e,i,s)}getTileset(t){const{tiling:e,tiles:i}=this,s=e.minLevel,{tileCountX:n,tileCountY:o}=e.getLevel(s),c=[];for(let l=0;l<n;l++)for(let a=0;a<o;a++){const h=this.createChild(l,a,s);h!==null&&c.push(h)}const r={asset:{version:"1.1"},geometricError:1e5,root:{refine:"REPLACE",geometricError:1e5,boundingVolume:this.createBoundingVolume(0,0,-1),children:c,[x]:-1,[f]:0,[L]:0}};return i.preprocessTileset(r,t),r}getUrl(t,e,i){return this.imageSource.getUrl(t,e,i)}createBoundingVolume(t,e,i){const{center:s,pixelSize:n,tiling:o}=this,{pixelWidth:c,pixelHeight:r}=o.getLevel(o.maxLevel),[l,a,h,S]=i===-1?o.getContentBounds(!0):o.getTileBounds(t,e,i,!0);let g=(h-l)/2,d=(S-a)/2,m=l+g,u=a+d;return s&&(m-=.5,u-=.5),n?(m*=c*n,g*=c*n,u*=r*n,d*=r*n):(m*=o.aspectRatio,g*=o.aspectRatio),{box:[m,u,0,g,0,0,0,d,0,0,0,0]}}createChild(t,e,i){const{pixelSize:s,tiling:n}=this;if(!n.getTileExists(t,e,i))return null;const{pixelWidth:o,pixelHeight:c}=n.getLevel(i);let r=Math.max(n.aspectRatio/o,1/c);if(s){const l=n.getLevel(n.maxLevel);r*=s*Math.max(l.pixelWidth,l.pixelHeight)}return{refine:"REPLACE",geometricError:r,boundingVolume:this.createBoundingVolume(t,e,i),content:{uri:this.getUrl(t,e,i)},children:[],[f]:t,[L]:e,[x]:i}}expandChildren(t){const e=t[x],i=t[f],s=t[L],{tileSplitX:n,tileSplitY:o}=this.tiling.getLevel(e);for(let c=0;c<n;c++)for(let r=0;r<o;r++){const l=this.createChild(n*i+c,o*s+r,e+1);l&&t.children.push(l)}}}export{M as I,x as T,f as a,L as b};
//# sourceMappingURL=ImageFormatPlugin-DGN9sc3I.js.map
