{"version":3,"file":"plugins-DBdp9Zs1.js","sources":["../../../src/core/plugins/loaders/QuantizedMeshLoaderBase.js","../../../src/three/plugins/loaders/QuantizedMeshLoader.js","../../../src/three/plugins/utilities/QuantizedMeshClipper.js","../../../src/three/plugins/QuantizedMeshPlugin.js","../../../src/three/plugins/CesiumIonAuthPlugin.js","../../../src/plugins.js"],"sourcesContent":["import { LoaderBase } from '3d-tiles-renderer/core';\n\nexport function zigZagDecode( value ) {\n\n\treturn ( value >> 1 ) ^ ( - ( value & 1 ) );\n\n}\n\nexport class QuantizedMeshLoaderBase extends LoaderBase {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.fetchOptions.header = {\n\t\t\tAccept: 'application/vnd.quantized-mesh,application/octet-stream;q=0.9',\n\t\t};\n\n\t}\n\n\tloadAsync( ...args ) {\n\n\t\tconst { fetchOptions } = this;\n\t\tfetchOptions.header = fetchOptions.header || {};\n\t\tfetchOptions.header[ 'Accept' ] = 'application/vnd.quantized-mesh,application/octet-stream;q=0.9';\n\t\tfetchOptions.header[ 'Accept' ] += ';extensions=octvertexnormals-watermask-metadata';\n\n\t\treturn super.loadAsync( ...args );\n\n\t}\n\n\tparse( buffer ) {\n\n\t\tlet pointer = 0;\n\t\tconst view = new DataView( buffer );\n\t\tconst readFloat64 = () => {\n\n\t\t\tconst result = view.getFloat64( pointer, true );\n\t\t\tpointer += 8;\n\t\t\treturn result;\n\n\t\t};\n\n\t\tconst readFloat32 = () => {\n\n\t\t\tconst result = view.getFloat32( pointer, true );\n\t\t\tpointer += 4;\n\t\t\treturn result;\n\n\t\t};\n\n\t\tconst readInt = () => {\n\n\t\t\tconst result = view.getUint32( pointer, true );\n\t\t\tpointer += 4;\n\t\t\treturn result;\n\n\t\t};\n\n\t\tconst readByte = () => {\n\n\t\t\tconst result = view.getUint8( pointer );\n\t\t\tpointer += 1;\n\t\t\treturn result;\n\n\t\t};\n\n\t\tconst readBuffer = ( count, type ) => {\n\n\t\t\tconst result = new type( buffer, pointer, count );\n\t\t\tpointer += count * type.BYTES_PER_ELEMENT;\n\t\t\treturn result;\n\n\t\t};\n\n\t\t// extract header\n\t\tconst header = {\n\t\t\tcenter: [ readFloat64(), readFloat64(), readFloat64() ],\n\t\t\tminHeight: readFloat32(),\n\t\t\tmaxHeight: readFloat32(),\n\t\t\tsphereCenter: [ readFloat64(), readFloat64(), readFloat64() ],\n\t\t\tsphereRadius: readFloat64(),\n\t\t\thorizonOcclusionPoint: [ readFloat64(), readFloat64(), readFloat64() ],\n\t\t};\n\n\t\t// extract vertex data\n\t\tconst vertexCount = readInt();\n\t\tconst uBuffer = readBuffer( vertexCount, Uint16Array );\n\t\tconst vBuffer = readBuffer( vertexCount, Uint16Array );\n\t\tconst hBuffer = readBuffer( vertexCount, Uint16Array );\n\n\t\tconst uResult = new Float32Array( vertexCount );\n\t\tconst vResult = new Float32Array( vertexCount );\n\t\tconst hResult = new Float32Array( vertexCount );\n\n\t\t// decode vertex data\n\t\tlet u = 0;\n\t\tlet v = 0;\n\t\tlet h = 0;\n\t\tconst MAX_VALUE = 32767;\n\t\tfor ( let i = 0; i < vertexCount; ++ i ) {\n\n\t\t\tu += zigZagDecode( uBuffer[ i ] );\n\t\t\tv += zigZagDecode( vBuffer[ i ] );\n\t\t\th += zigZagDecode( hBuffer[ i ] );\n\n\t\t\tuResult[ i ] = u / MAX_VALUE;\n\t\t\tvResult[ i ] = v / MAX_VALUE;\n\t\t\thResult[ i ] = h / MAX_VALUE;\n\n\t\t}\n\n\t\t// align pointer for index data\n\t\tconst is32 = vertexCount > 65536;\n\t\tconst bufferType = is32 ? Uint32Array : Uint16Array;\n\t\tif ( is32 ) {\n\n\t\t\tpointer = Math.ceil( pointer / 4 ) * 4;\n\n\t\t} else {\n\n\t\t\tpointer = Math.ceil( pointer / 2 ) * 2;\n\n\t\t}\n\n\t\t// extract index data\n\t\tconst triangleCount = readInt();\n\t\tconst indices = readBuffer( triangleCount * 3, bufferType );\n\n\t\t// decode the index data\n\t\tlet highest = 0;\n\t\tfor ( var i = 0; i < indices.length; ++ i ) {\n\n\t\t\tconst code = indices[ i ];\n\t\t\tindices[ i ] = highest - code;\n\t\t\tif ( code === 0 ) {\n\n\t\t\t\t++ highest;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// sort functions for the edges since they are not pre-sorted\n\t\tconst vSort = ( a, b ) => vResult[ b ] - vResult[ a ];\n\t\tconst vSortReverse = ( a, b ) => - vSort( a, b );\n\n\t\tconst uSort = ( a, b ) => uResult[ a ] - uResult[ b ];\n\t\tconst uSortReverse = ( a, b ) => - uSort( a, b );\n\n\t\t// get edge indices\n\t\tconst westVertexCount = readInt();\n\t\tconst westIndices = readBuffer( westVertexCount, bufferType );\n\t\twestIndices.sort( vSort );\n\n\t\tconst southVertexCount = readInt();\n\t\tconst southIndices = readBuffer( southVertexCount, bufferType );\n\t\tsouthIndices.sort( uSort );\n\n\t\tconst eastVertexCount = readInt();\n\t\tconst eastIndices = readBuffer( eastVertexCount, bufferType );\n\t\teastIndices.sort( vSortReverse );\n\n\t\tconst northVertexCount = readInt();\n\t\tconst northIndices = readBuffer( northVertexCount, bufferType );\n\t\tnorthIndices.sort( uSortReverse );\n\n\t\tconst edgeIndices = {\n\t\t\twestIndices,\n\t\t\tsouthIndices,\n\t\t\teastIndices,\n\t\t\tnorthIndices,\n\t\t};\n\n\t\t// parse extensions\n\t\tconst extensions = {};\n\t\twhile ( pointer < view.byteLength ) {\n\n\t\t\tconst extensionId = readByte();\n\t\t\tconst extensionLength = readInt();\n\n\t\t\tif ( extensionId === 1 ) {\n\n\t\t\t\t// oct encoded normals\n\t\t\t\tconst xy = readBuffer( vertexCount * 2, Uint8Array );\n\t\t\t\tconst normals = new Float32Array( vertexCount * 3 );\n\n\t\t\t\t// https://github.com/CesiumGS/cesium/blob/baaabaa49058067c855ad050be73a9cdfe9b6ac7/packages/engine/Source/Core/AttributeCompression.js#L119-L140\n\t\t\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\t\t\tlet x = ( xy[ 2 * i + 0 ] / 255 ) * 2 - 1;\n\t\t\t\t\tlet y = ( xy[ 2 * i + 1 ] / 255 ) * 2 - 1;\n\t\t\t\t\tconst z = 1.0 - ( Math.abs( x ) + Math.abs( y ) );\n\n\t\t\t\t\tif ( z < 0.0 ) {\n\n\t\t\t\t\t\tconst oldVX = x;\n\t\t\t\t\t\tx = ( 1.0 - Math.abs( y ) ) * signNotZero( oldVX );\n\t\t\t\t\t\ty = ( 1.0 - Math.abs( oldVX ) ) * signNotZero( y );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst len = Math.sqrt( x * x + y * y + z * z );\n\t\t\t\t\tnormals[ 3 * i + 0 ] = x / len;\n\t\t\t\t\tnormals[ 3 * i + 1 ] = y / len;\n\t\t\t\t\tnormals[ 3 * i + 2 ] = z / len;\n\n\t\t\t\t}\n\n\t\t\t\textensions[ 'octvertexnormals' ] = {\n\t\t\t\t\textensionId,\n\t\t\t\t\tnormals,\n\t\t\t\t};\n\n\t\t\t} else if ( extensionId === 2 ) {\n\n\t\t\t\t// water mask\n\t\t\t\tconst size = extensionLength === 1 ? 1 : 256;\n\t\t\t\tconst mask = readBuffer( size * size, Uint8Array );\n\t\t\t\textensions[ 'watermask' ] = {\n\t\t\t\t\textensionId,\n\t\t\t\t\tmask,\n\t\t\t\t\tsize,\n\t\t\t\t};\n\n\t\t\t} else if ( extensionId === 4 ) {\n\n\t\t\t\t// metadata\n\t\t\t\tconst jsonLength = readInt();\n\t\t\t\tconst jsonBuffer = readBuffer( jsonLength, Uint8Array );\n\t\t\t\tconst json = new TextDecoder().decode( jsonBuffer );\n\t\t\t\textensions[ 'metadata' ] = {\n\t\t\t\t\textensionId,\n\t\t\t\t\tjson: JSON.parse( json ),\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\theader,\n\t\t\tindices,\n\t\t\tvertexData: {\n\t\t\t\tu: uResult,\n\t\t\t\tv: vResult,\n\t\t\t\theight: hResult,\n\t\t\t},\n\t\t\tedgeIndices,\n\t\t\textensions,\n\t\t};\n\n\t}\n\n}\n\nfunction signNotZero( v ) {\n\n\treturn v < 0.0 ? - 1.0 : 1.0;\n\n}\n","import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tDataTexture,\n\tDefaultLoadingManager,\n\tLinearFilter,\n\tLinearMipMapLinearFilter,\n\tMathUtils,\n\tMesh,\n\tMeshStandardMaterial,\n\tRGFormat,\n\tTriangle,\n\tUnsignedByteType,\n\tVector3,\n} from 'three';\nimport { QuantizedMeshLoaderBase } from '3d-tiles-renderer/core/plugins';\nimport { Ellipsoid } from '3d-tiles-renderer/three';\n\nconst _norm = /* @__PURE__ */ new Vector3();\nconst _tri = /* @__PURE__ */ new Triangle();\nconst _uvh = /* @__PURE__ */ new Vector3();\nconst _pos = /* @__PURE__ */ new Vector3();\nexport class QuantizedMeshLoader extends QuantizedMeshLoaderBase {\n\n\tconstructor( manager = DefaultLoadingManager ) {\n\n\t\tsuper();\n\t\tthis.manager = manager;\n\t\tthis.ellipsoid = new Ellipsoid();\n\t\tthis.skirtLength = 1000;\n\t\tthis.smoothSkirtNormals = true;\n\t\tthis.generateNormals = true;\n\t\tthis.solid = false;\n\n\t\t// set the range of the tile\n\t\tthis.minLat = - Math.PI / 2;\n\t\tthis.maxLat = Math.PI / 2;\n\t\tthis.minLon = - Math.PI;\n\t\tthis.maxLon = Math.PI;\n\n\t}\n\n\tparse( buffer ) {\n\n\t\tconst {\n\t\t\tellipsoid,\n\t\t\tsolid,\n\t\t\tskirtLength,\n\t\t\tsmoothSkirtNormals,\n\t\t\tgenerateNormals,\n\n\t\t\tminLat,\n\t\t\tmaxLat,\n\t\t\tminLon,\n\t\t\tmaxLon,\n\t\t} = this;\n\n\t\tconst {\n\t\t\theader,\n\t\t\tindices,\n\t\t\tvertexData,\n\t\t\tedgeIndices,\n\t\t\textensions,\n\t\t} = super.parse( buffer );\n\n\t\tconst geometry = new BufferGeometry();\n\t\tconst material = new MeshStandardMaterial();\n\t\tconst mesh = new Mesh( geometry, material );\n\t\tmesh.position.set( ...header.center );\n\n\t\tconst hasNormalExtension = 'octvertexnormals' in extensions;\n\t\tconst includeNormals = hasNormalExtension || generateNormals;\n\t\tconst vertexCount = vertexData.u.length;\n\t\tconst positions = [];\n\t\tconst uvs = [];\n\t\tconst indexArr = [];\n\t\tconst normals = [];\n\t\tlet groupOffset = 0;\n\t\tlet materialIndex = 0;\n\n\t\t// construct terrain\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\treadUVHeight( i, _uvh );\n\t\t\treadPosition( _uvh.x, _uvh.y, _uvh.z, _pos );\n\n\t\t\tuvs.push( _uvh.x, _uvh.y );\n\t\t\tpositions.push( ..._pos );\n\n\t\t}\n\n\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\tindexArr.push( indices[ i ] );\n\n\t\t}\n\n\t\tif ( includeNormals ) {\n\n\t\t\tif ( hasNormalExtension ) {\n\n\t\t\t\tconst extNormals = extensions[ 'octvertexnormals' ].normals;\n\t\t\t\tfor ( let i = 0, l = extNormals.length; i < l; i ++ ) {\n\n\t\t\t\t\tnormals.push( extNormals[ i ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// generate normals using the positions we just created\n\t\t\t\tconst tempGeometry = new BufferGeometry();\n\t\t\t\tconst tempIndexBuffer = indices.length > 21845 ? new Uint32Array( indices ) : new Uint16Array( indices );\n\t\t\t\ttempGeometry.setIndex( new BufferAttribute( tempIndexBuffer, 1, false ) );\n\t\t\t\ttempGeometry.setAttribute( 'position', new BufferAttribute( new Float32Array( positions ), 3, false ) );\n\t\t\t\ttempGeometry.computeVertexNormals();\n\n\t\t\t\tconst normalAttr = tempGeometry.getAttribute( 'normal' );\n\t\t\t\tconst generatedNormals = normalAttr.array;\n\n\t\t\t\t// store in extensions format for consistency\n\t\t\t\textensions[ 'octvertexnormals' ] = { normals: generatedNormals };\n\n\t\t\t\t// copy to normals array\n\t\t\t\tfor ( let i = 0, l = generatedNormals.length; i < l; i ++ ) {\n\n\t\t\t\t\tnormals.push( generatedNormals[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// add material group\n\t\tgeometry.addGroup( groupOffset, indices.length, materialIndex );\n\t\tgroupOffset += indices.length;\n\t\tmaterialIndex ++;\n\n\t\t// create a lower cap\n\t\tif ( solid ) {\n\n\t\t\tconst indexOffset = positions.length / 3;\n\t\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\t\treadUVHeight( i, _uvh );\n\t\t\t\treadPosition( _uvh.x, _uvh.y, _uvh.z, _pos, - skirtLength );\n\n\t\t\t\tuvs.push( _uvh.x, _uvh.y );\n\t\t\t\tpositions.push( ..._pos );\n\n\t\t\t}\n\n\t\t\tfor ( let i = indices.length - 1; i >= 0; i -- ) {\n\n\t\t\t\tindexArr.push( indices[ i ] + indexOffset );\n\n\t\t\t}\n\n\t\t\tif ( includeNormals ) {\n\n\t\t\t\tconst extNormals = extensions[ 'octvertexnormals' ].normals;\n\t\t\t\tfor ( let i = 0, l = extNormals.length; i < l; i ++ ) {\n\n\t\t\t\t\tnormals.push( - extNormals[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// add material group\n\t\t\tgeometry.addGroup( groupOffset, indices.length, materialIndex );\n\t\t\tgroupOffset += indices.length;\n\t\t\tmaterialIndex ++;\n\n\t\t}\n\n\t\t// construct skirts\n\t\tif ( skirtLength > 0 ) {\n\n\t\t\tconst {\n\t\t\t\twestIndices,\n\t\t\t\teastIndices,\n\t\t\t\tsouthIndices,\n\t\t\t\tnorthIndices,\n\t\t\t} = edgeIndices;\n\n\t\t\t// construct the indices\n\t\t\tlet offset;\n\n\t\t\t// west\n\t\t\tconst westStrip = constructEdgeStrip( westIndices );\n\t\t\toffset = positions.length / 3;\n\t\t\tuvs.push( ...westStrip.uv );\n\t\t\tpositions.push( ...westStrip.positions );\n\t\t\tfor ( let i = 0, l = westStrip.indices.length; i < l; i ++ ) {\n\n\t\t\t\tindexArr.push( westStrip.indices[ i ] + offset );\n\n\t\t\t}\n\n\t\t\t// east\n\t\t\tconst eastStrip = constructEdgeStrip( eastIndices );\n\t\t\toffset = positions.length / 3;\n\t\t\tuvs.push( ...eastStrip.uv );\n\t\t\tpositions.push( ...eastStrip.positions );\n\t\t\tfor ( let i = 0, l = eastStrip.indices.length; i < l; i ++ ) {\n\n\t\t\t\tindexArr.push( eastStrip.indices[ i ] + offset );\n\n\t\t\t}\n\n\t\t\t// south\n\t\t\tconst southStrip = constructEdgeStrip( southIndices );\n\t\t\toffset = positions.length / 3;\n\t\t\tuvs.push( ...southStrip.uv );\n\t\t\tpositions.push( ...southStrip.positions );\n\t\t\tfor ( let i = 0, l = southStrip.indices.length; i < l; i ++ ) {\n\n\t\t\t\tindexArr.push( southStrip.indices[ i ] + offset );\n\n\t\t\t}\n\n\t\t\t// north\n\t\t\tconst northStrip = constructEdgeStrip( northIndices );\n\t\t\toffset = positions.length / 3;\n\t\t\tuvs.push( ...northStrip.uv );\n\t\t\tpositions.push( ...northStrip.positions );\n\t\t\tfor ( let i = 0, l = northStrip.indices.length; i < l; i ++ ) {\n\n\t\t\t\tindexArr.push( northStrip.indices[ i ] + offset );\n\n\t\t\t}\n\n\t\t\t// add the normals\n\t\t\tif ( includeNormals ) {\n\n\t\t\t\tnormals.push( ...westStrip.normals );\n\t\t\t\tnormals.push( ...eastStrip.normals );\n\t\t\t\tnormals.push( ...southStrip.normals );\n\t\t\t\tnormals.push( ...northStrip.normals );\n\n\t\t\t}\n\n\t\t\t// add material group\n\t\t\tgeometry.addGroup( groupOffset, indices.length, materialIndex );\n\t\t\tgroupOffset += indices.length;\n\t\t\tmaterialIndex ++;\n\n\t\t}\n\n\t\t// shift the positions by the center of the tile\n\t\tfor ( let i = 0, l = positions.length; i < l; i += 3 ) {\n\n\t\t\tpositions[ i + 0 ] -= header.center[ 0 ];\n\t\t\tpositions[ i + 1 ] -= header.center[ 1 ];\n\t\t\tpositions[ i + 2 ] -= header.center[ 2 ];\n\n\t\t}\n\n\t\t// generate geometry and mesh\n\t\tconst indexBuffer = positions.length / 3 > 65535 ? new Uint32Array( indexArr ) : new Uint16Array( indexArr );\n\t\tgeometry.setIndex( new BufferAttribute( indexBuffer, 1, false ) );\n\t\tgeometry.setAttribute( 'position', new BufferAttribute( new Float32Array( positions ), 3, false ) );\n\t\tgeometry.setAttribute( 'uv', new BufferAttribute( new Float32Array( uvs ), 2, false ) );\n\t\tif ( includeNormals ) {\n\n\t\t\tgeometry.setAttribute( 'normal', new BufferAttribute( new Float32Array( normals ), 3, false ) );\n\n\t\t}\n\n\t\t// generate the water texture\n\t\tif ( 'watermask' in extensions ) {\n\n\t\t\t// invert the mask data\n\t\t\t// TODO: this inversion step can be a bit slow\n\t\t\tconst { mask, size } = extensions[ 'watermask' ];\n\t\t\tconst maskBuffer = new Uint8Array( 2 * size * size );\n\t\t\tfor ( let i = 0, l = mask.length; i < l; i ++ ) {\n\n\t\t\t\tconst v = mask[ i ] === 255 ? 0 : 255;\n\t\t\t\tmaskBuffer[ 2 * i + 0 ] = v;\n\t\t\t\tmaskBuffer[ 2 * i + 1 ] = v;\n\n\t\t\t}\n\n\t\t\t// TODO: Luminance format is not supported - eventually node materials will\n\t\t\t// make it possible to map the texture to the appropriate buffer input.\n\t\t\tconst map = new DataTexture( maskBuffer, size, size, RGFormat, UnsignedByteType );\n\t\t\tmap.flipY = true;\n\t\t\tmap.minFilter = LinearMipMapLinearFilter;\n\t\t\tmap.magFilter = LinearFilter;\n\t\t\tmap.needsUpdate = true;\n\n\t\t\tmaterial.roughnessMap = map;\n\n\t\t}\n\n\t\t// set metadata\n\t\tmesh.userData.minHeight = header.minHeight;\n\t\tmesh.userData.maxHeight = header.maxHeight;\n\n\t\tif ( 'metadata' in extensions ) {\n\n\t\t\tmesh.userData.metadata = extensions[ 'metadata' ].json;\n\n\t\t}\n\n\t\treturn mesh;\n\n\t\tfunction readUVHeight( index, target ) {\n\n\t\t\ttarget.x = vertexData.u[ index ];\n\t\t\ttarget.y = vertexData.v[ index ];\n\t\t\ttarget.z = vertexData.height[ index ];\n\t\t\treturn target;\n\n\t\t}\n\n\t\tfunction readPosition( u, v, h, target, heightOffset = 0 ) {\n\n\t\t\tconst height = MathUtils.lerp( header.minHeight, header.maxHeight, h );\n\t\t\tconst lon = MathUtils.lerp( minLon, maxLon, u );\n\t\t\tconst lat = MathUtils.lerp( minLat, maxLat, v );\n\n\t\t\tellipsoid.getCartographicToPosition( lat, lon, height + heightOffset, target );\n\n\t\t\treturn target;\n\n\t\t}\n\n\t\tfunction constructEdgeStrip( indices ) {\n\n\t\t\tconst topUvs = [];\n\t\t\tconst topPos = [];\n\t\t\tconst botUvs = [];\n\t\t\tconst botPos = [];\n\t\t\tconst sideIndices = [];\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\treadUVHeight( indices[ i ], _uvh );\n\t\t\t\ttopUvs.push( _uvh.x, _uvh.y );\n\t\t\t\tbotUvs.push( _uvh.x, _uvh.y );\n\n\t\t\t\treadPosition( _uvh.x, _uvh.y, _uvh.z, _pos );\n\t\t\t\ttopPos.push( ..._pos );\n\n\t\t\t\treadPosition( _uvh.x, _uvh.y, _uvh.z, _pos, - skirtLength );\n\t\t\t\tbotPos.push( ..._pos );\n\n\t\t\t}\n\n\t\t\tconst triCount = ( indices.length - 1 );\n\t\t\tfor ( let i = 0; i < triCount; i ++ ) {\n\n\t\t\t\tconst t0 = i;\n\t\t\t\tconst t1 = i + 1;\n\t\t\t\tconst b0 = i + indices.length;\n\t\t\t\tconst b1 = i + indices.length + 1;\n\n\t\t\t\tsideIndices.push( t0, b0, t1 );\n\t\t\t\tsideIndices.push( t1, b0, b1 );\n\n\t\t\t}\n\n\t\t\tlet normals = null;\n\t\t\tif ( includeNormals ) {\n\n\t\t\t\tconst total = ( topPos.length + botPos.length ) / 3;\n\n\t\t\t\tif ( smoothSkirtNormals ) {\n\n\t\t\t\t\tnormals = new Array( total * 3 );\n\n\t\t\t\t\tconst extNormals = extensions[ 'octvertexnormals' ].normals;\n\t\t\t\t\tconst botOffset = normals.length / 2;\n\t\t\t\t\tfor ( let i = 0, l = total / 2; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst index = indices[ i ];\n\t\t\t\t\t\tconst i3 = 3 * i;\n\t\t\t\t\t\tconst nx = extNormals[ 3 * index + 0 ];\n\t\t\t\t\t\tconst ny = extNormals[ 3 * index + 1 ];\n\t\t\t\t\t\tconst nz = extNormals[ 3 * index + 2 ];\n\n\t\t\t\t\t\tnormals[ i3 + 0 ] = nx;\n\t\t\t\t\t\tnormals[ i3 + 1 ] = ny;\n\t\t\t\t\t\tnormals[ i3 + 2 ] = nz;\n\n\t\t\t\t\t\tnormals[ botOffset + i3 + 0 ] = nx;\n\t\t\t\t\t\tnormals[ botOffset + i3 + 1 ] = ny;\n\t\t\t\t\t\tnormals[ botOffset + i3 + 2 ] = nz;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnormals = [];\n\t\t\t\t\t_tri.a.fromArray( topPos, 0 );\n\t\t\t\t\t_tri.b.fromArray( botPos, 0 );\n\t\t\t\t\t_tri.c.fromArray( topPos, 3 );\n\t\t\t\t\t_tri.getNormal( _norm );\n\n\t\t\t\t\tfor ( let i = 0; i < total; i ++ ) {\n\n\t\t\t\t\t\tnormals.push( ..._norm );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tuv: [ ...topUvs, ...botUvs ],\n\t\t\t\tpositions: [ ...topPos, ...botPos ],\n\t\t\t\tindices: sideIndices,\n\t\t\t\tnormals,\n\t\t\t};\n\n\t\t}\n\n\t}\n\n}\n","import { MathUtils, Vector2, Vector3 } from 'three';\nimport { Ellipsoid } from '3d-tiles-renderer/three';\nimport { GeometryClipper, hashVertex } from './GeometryClipper.js';\n\nconst _cart = {};\nconst _vec = /* @__PURE__ */ new Vector3();\nconst _pos0 = /* @__PURE__ */ new Vector3();\nconst _pos1 = /* @__PURE__ */ new Vector3();\nconst _pos2 = /* @__PURE__ */ new Vector3();\nconst _pos3 = /* @__PURE__ */ new Vector3();\nconst _temp = /* @__PURE__ */ new Vector3();\nconst _temp2 = /* @__PURE__ */ new Vector3();\n\nconst _uv0 = /* @__PURE__ */ new Vector2();\nconst _uv1 = /* @__PURE__ */ new Vector2();\nconst _uv2 = /* @__PURE__ */ new Vector2();\n\nexport class QuantizedMeshClipper extends GeometryClipper {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis.ellipsoid = new Ellipsoid();\n\t\tthis.skirtLength = 1000;\n\t\tthis.smoothSkirtNormals = true;\n\t\tthis.solid = false;\n\n\t\tthis.minLat = - Math.PI / 2;\n\t\tthis.maxLat = Math.PI / 2;\n\t\tthis.minLon = - Math.PI;\n\t\tthis.maxLon = Math.PI;\n\n\t\tthis.attributeList = [ 'position', 'normal', 'uv' ];\n\n\t}\n\n\tclipToQuadrant( sourceMesh, left, bottom ) {\n\n\t\tconst { solid, skirtLength, ellipsoid, smoothSkirtNormals } = this;\n\n\t\tthis.clearSplitOperations();\n\t\tthis.addSplitOperation( getUvSplitOperation( 'x' ), ! left );\n\t\tthis.addSplitOperation( getUvSplitOperation( 'y' ), ! bottom );\n\n\t\tlet botResult, skirtResult;\n\t\tconst capGroup = sourceMesh.geometry.groups[ 0 ];\n\t\tconst capResult = this.getClippedData( sourceMesh, capGroup );\n\t\tthis.adjustVertices( capResult, sourceMesh.position, 0 );\n\n\t\tif ( solid ) {\n\n\t\t\tbotResult = {\n\t\t\t\tindex: capResult.index.slice().reverse(),\n\t\t\t\tattributes: {},\n\t\t\t};\n\n\t\t\tfor ( const key in capResult.attributes ) {\n\n\t\t\t\tbotResult.attributes[ key ] = capResult.attributes[ key ].slice();\n\n\t\t\t}\n\n\t\t\tconst normal = botResult.attributes.normal;\n\t\t\tif ( normal ) {\n\n\t\t\t\tfor ( let i = 0; i < normal.length; i += 3 ) {\n\n\t\t\t\t\tnormal[ i + 0 ] *= - 1;\n\t\t\t\t\tnormal[ i + 1 ] *= - 1;\n\t\t\t\t\tnormal[ i + 2 ] *= - 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.adjustVertices( botResult, sourceMesh.position, - skirtLength );\n\n\t\t}\n\n\t\tif ( skirtLength > 0 ) {\n\n\t\t\tskirtResult = {\n\t\t\t\tindex: [],\n\t\t\t\tattributes: {\n\t\t\t\t\tposition: [],\n\t\t\t\t\tnormal: [],\n\t\t\t\t\tuv: [],\n\t\t\t\t},\n\t\t\t};\n\n\t\t\t// push data onto the\n\t\t\tlet nextIndex = 0;\n\t\t\tconst vertToNewIndexMap = {};\n\t\t\tconst pushVertex = ( pos, uv, norm ) => {\n\n\t\t\t\tconst hash = hashVertex( ...pos, ...norm, ...uv );\n\t\t\t\tif ( ! ( hash in vertToNewIndexMap ) ) {\n\n\t\t\t\t\tvertToNewIndexMap[ hash ] = nextIndex;\n\t\t\t\t\tnextIndex ++;\n\n\t\t\t\t\tskirtResult.attributes.position.push( ...pos );\n\t\t\t\t\tskirtResult.attributes.normal.push( ...norm );\n\t\t\t\t\tskirtResult.attributes.uv.push( ...uv );\n\n\t\t\t\t}\n\n\t\t\t\tskirtResult.index.push( vertToNewIndexMap[ hash ] );\n\n\t\t\t};\n\n\t\t\t// TODO: this seems to have some problematic cases at the root tiles near the poles\n\t\t\tconst capIndex = capResult.index;\n\t\t\tconst capUv = capResult.attributes.uv;\n\t\t\tconst capPosition = capResult.attributes.position;\n\t\t\tconst capNormal = capResult.attributes.normal;\n\t\t\tconst capTriangles = capResult.index.length / 3;\n\t\t\tfor ( let i = 0; i < capTriangles; i ++ ) {\n\n\t\t\t\tconst triOffset = 3 * i;\n\t\t\t\tfor ( let e = 0; e < 3; e ++ ) {\n\n\t\t\t\t\tconst ne = ( e + 1 ) % 3;\n\t\t\t\t\tconst i0 = capIndex[ triOffset + e ];\n\t\t\t\t\tconst i1 = capIndex[ triOffset + ne ];\n\n\t\t\t\t\t_uv0.fromArray( capUv, i0 * 2 );\n\t\t\t\t\t_uv1.fromArray( capUv, i1 * 2 );\n\n\t\t\t\t\t// find the vertices that lie on the edge\n\t\t\t\t\tif (\n\t\t\t\t\t\t_uv0.x === _uv1.x && ( _uv0.x === 0 || _uv0.x === 0.5 || _uv0.x === 1.0 ) ||\n\t\t\t\t\t\t_uv0.y === _uv1.y && ( _uv0.y === 0 || _uv0.y === 0.5 || _uv0.y === 1.0 )\n\t\t\t\t\t) {\n\n\t\t\t\t\t\t_pos0.fromArray( capPosition, i0 * 3 );\n\t\t\t\t\t\t_pos1.fromArray( capPosition, i1 * 3 );\n\n\t\t\t\t\t\tconst u0 = _pos0;\n\t\t\t\t\t\tconst u1 = _pos1;\n\n\t\t\t\t\t\tconst b0 = _pos2.copy( _pos0 );\n\t\t\t\t\t\tconst b1 = _pos3.copy( _pos1 );\n\n\t\t\t\t\t\t_temp.copy( b0 ).add( sourceMesh.position );\n\t\t\t\t\t\tellipsoid.getPositionToNormal( _temp, _temp );\n\t\t\t\t\t\tb0.addScaledVector( _temp, - skirtLength );\n\n\t\t\t\t\t\t_temp.copy( b1 ).add( sourceMesh.position );\n\t\t\t\t\t\tellipsoid.getPositionToNormal( _temp, _temp );\n\t\t\t\t\t\tb1.addScaledVector( _temp, - skirtLength );\n\n\t\t\t\t\t\tif ( smoothSkirtNormals && capNormal ) {\n\n\t\t\t\t\t\t\t_temp.fromArray( capNormal, i0 * 3 );\n\t\t\t\t\t\t\t_temp2.fromArray( capNormal, i1 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t_temp.subVectors( u0, u1 );\n\t\t\t\t\t\t\t_temp2.subVectors( u0, b0 ).cross( _temp ).normalize();\n\t\t\t\t\t\t\t_temp.copy( _temp2 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpushVertex( u1, _uv1, _temp2 );\n\t\t\t\t\t\tpushVertex( u0, _uv0, _temp );\n\t\t\t\t\t\tpushVertex( b0, _uv0, _temp );\n\n\t\t\t\t\t\tpushVertex( u1, _uv1, _temp2 );\n\t\t\t\t\t\tpushVertex( b0, _uv0, _temp );\n\t\t\t\t\t\tpushVertex( b1, _uv1, _temp2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst capLength = capResult.index.length;\n\t\tconst result = capResult;\n\t\tif ( botResult ) {\n\n\t\t\tconst { index, attributes } = botResult;\n\t\t\tconst offset = result.attributes.position.length / 3;\n\t\t\tfor ( let i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\tresult.index.push( index[ i ] + offset );\n\n\t\t\t}\n\n\t\t\tfor ( const key in capResult.attributes ) {\n\n\t\t\t\tresult.attributes[ key ].push( ...attributes[ key ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( skirtResult ) {\n\n\t\t\tconst { index, attributes } = skirtResult;\n\t\t\tconst offset = result.attributes.position.length / 3;\n\t\t\tfor ( let i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\tresult.index.push( index[ i ] + offset );\n\n\t\t\t}\n\n\t\t\tfor ( const key in capResult.attributes ) {\n\n\t\t\t\tresult.attributes[ key ].push( ...attributes[ key ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// offset the uvs\n\t\tconst xUvOffset = left ? 0 : - 0.5;\n\t\tconst yUvOffset = bottom ? 0 : - 0.5;\n\t\tconst uv = result.attributes.uv;\n\t\tfor ( let i = 0, l = uv.length; i < l; i += 2 ) {\n\n\t\t\tuv[ i ] = ( uv[ i ] + xUvOffset ) * 2.0;\n\t\t\tuv[ i + 1 ] = ( uv[ i + 1 ] + yUvOffset ) * 2.0;\n\n\t\t}\n\n\t\t// construct the result\n\t\tconst resultMesh = this.constructMesh( result.attributes, result.index, sourceMesh );\n\t\tresultMesh.userData.minHeight = sourceMesh.userData.minHeight;\n\t\tresultMesh.userData.maxHeight = sourceMesh.userData.maxHeight;\n\n\t\tlet materialIndex = 0;\n\t\tlet start = 0;\n\t\tresultMesh.geometry.addGroup( start, capLength, materialIndex );\n\t\tstart += capLength;\n\t\tmaterialIndex ++;\n\n\t\tif ( botResult ) {\n\n\t\t\tresultMesh.geometry.addGroup( start, botResult.index.length, materialIndex );\n\t\t\tstart += botResult.index.length;\n\t\t\tmaterialIndex ++;\n\n\t\t}\n\n\t\tif ( skirtResult ) {\n\n\t\t\tresultMesh.geometry.addGroup( start, skirtResult.index.length, materialIndex );\n\t\t\tstart += skirtResult.index.length;\n\t\t\tmaterialIndex ++;\n\n\t\t}\n\n\t\treturn resultMesh;\n\n\t}\n\n\tadjustVertices( info, position, offset ) {\n\n\t\tconst { ellipsoid, minLat, maxLat, minLon, maxLon } = this;\n\t\tconst { attributes, vertexIsClipped } = info;\n\t\tconst posArr = attributes.position;\n\t\tconst uvArr = attributes.uv;\n\n\t\tconst vertexCount = posArr.length / 3;\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tconst uv = _uv0.fromArray( uvArr, i * 2 );\n\t\t\tif ( vertexIsClipped && vertexIsClipped[ i ] ) {\n\n\t\t\t\tif ( Math.abs( uv.x - 0.5 ) < 1e-10 ) {\n\n\t\t\t\t\tuv.x = 0.5;\n\n\t\t\t\t}\n\n\t\t\t\tif ( Math.abs( uv.y - 0.5 ) < 1e-10 ) {\n\n\t\t\t\t\tuv.y = 0.5;\n\n\t\t\t\t}\n\n\t\t\t\t_uv0.toArray( uvArr, i * 2 );\n\n\t\t\t}\n\n\t\t\tconst lat = MathUtils.lerp( minLat, maxLat, uv.y );\n\t\t\tconst lon = MathUtils.lerp( minLon, maxLon, uv.x );\n\t\t\tconst point = _vec.fromArray( posArr, i * 3 ).add( position );\n\t\t\tellipsoid.getPositionToCartographic( point, _cart );\n\t\t\tellipsoid.getCartographicToPosition( lat, lon, _cart.height + offset, point );\n\t\t\tpoint.sub( position );\n\t\t\tpoint.toArray( posArr, i * 3 );\n\n\t\t}\n\n\t}\n\n}\n\nfunction getUvSplitOperation( axis ) {\n\n\treturn ( geometry, i0, i1, i2, barycoord ) => {\n\n\t\tconst uv = geometry.attributes.uv;\n\t\t_uv0.fromBufferAttribute( uv, i0 );\n\t\t_uv1.fromBufferAttribute( uv, i1 );\n\t\t_uv2.fromBufferAttribute( uv, i2 );\n\n\t\treturn _uv0[ axis ] * barycoord.x + _uv1[ axis ] * barycoord.y + _uv2[ axis ] * barycoord.z - 0.5;\n\n\t};\n\n}\n","import { Vector3 } from 'three';\nimport { QuantizedMeshLoader } from './loaders/QuantizedMeshLoader.js';\nimport { TilingScheme } from './images/utils/TilingScheme.js';\nimport { ProjectionScheme } from './images/utils/ProjectionScheme.js';\nimport { QuantizedMeshClipper } from './utilities/QuantizedMeshClipper.js';\n\nconst TILE_X = Symbol( 'TILE_X' );\nconst TILE_Y = Symbol( 'TILE_Y' );\nconst TILE_LEVEL = Symbol( 'TILE_LEVEL' );\nconst TILE_AVAILABLE = Symbol( 'TILE_AVAILABLE' );\n\n// We don't know the height ranges for the tileset on load so assume a large range and\n// adjust it once the tiles have actually loaded based on the min and max height\nconst INITIAL_HEIGHT_RANGE = 1e4;\nconst _vec = /* @__PURE__ */ new Vector3();\n\n// Checks if the given tile is available\nfunction isTileAvailable( available, level, x, y ) {\n\n\tif ( available && level < available.length ) {\n\n\t\t// TODO: consider a binary search\n\t\tconst availableSet = available[ level ];\n\t\tfor ( let i = 0, l = availableSet.length; i < l; i ++ ) {\n\n\t\t\tconst { startX, startY, endX, endY } = availableSet[ i ];\n\t\t\tif ( x >= startX && x <= endX && y >= startY && y <= endY ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\n// Calculates the max level that can be loaded.\nfunction getMaxLevel( layer ) {\n\n\tconst { available = null, maxzoom = null } = layer;\n\treturn maxzoom === null ? available.length - 1 : maxzoom;\n\n}\n\n// Calculates whether metadata availability is present - returns -1 if not.\nfunction getMetadataAvailability( layer ) {\n\n\tconst { metadataAvailability = - 1 } = layer;\n\treturn metadataAvailability;\n\n}\n\n// Calculates whether the given tile should have metadata availability\nfunction getTileHasMetadata( tile, layer ) {\n\n\tconst level = tile[ TILE_LEVEL ];\n\tconst metadataAvailability = getMetadataAvailability( layer );\n\tconst maxLevel = getMaxLevel( layer );\n\n\treturn level < maxLevel && metadataAvailability !== - 1 && ( level % metadataAvailability ) === 0;\n\n}\n\n// Constructs the url for the given tile content\nfunction getContentUrl( x, y, level, version, layer ) {\n\n\treturn layer.tiles[ 0 ]\n\t\t.replace( /{\\s*z\\s*}/g, level )\n\t\t.replace( /{\\s*x\\s*}/g, x )\n\t\t.replace( /{\\s*y\\s*}/g, y )\n\t\t.replace( /{\\s*version\\s*}/g, version );\n\n}\n\nexport class QuantizedMeshPlugin {\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\tuseRecommendedSettings = true,\n\t\t\tskirtLength = null,\n\t\t\tsmoothSkirtNormals = true,\n\t\t\tgenerateNormals = true,\n\t\t\tsolid = false,\n\t\t} = options;\n\n\t\t// plugin needs to run before other plugins that fetch data since content\n\t\t// is handled and loaded in a custom way\n\t\tthis.name = 'QUANTIZED_MESH_PLUGIN';\n\t\tthis.priority = - 1000;\n\n\t\tthis.tiles = null;\n\t\tthis.layer = null;\n\t\tthis.useRecommendedSettings = useRecommendedSettings;\n\t\tthis.skirtLength = skirtLength;\n\t\tthis.smoothSkirtNormals = smoothSkirtNormals;\n\t\tthis.solid = solid;\n\t\tthis.generateNormals = generateNormals;\n\t\tthis.attribution = null;\n\n\t\tthis.tiling = new TilingScheme();\n\t\tthis.projection = new ProjectionScheme();\n\n\t}\n\n\t// Plugin function\n\tinit( tiles ) {\n\n\t\t// TODO: should we avoid setting this globally?\n\t\ttiles.fetchOptions.headers = tiles.fetchOptions.headers || {};\n\t\ttiles.fetchOptions.headers.Accept = 'application/vnd.quantized-mesh,application/octet-stream;q=0.9';\n\n\t\tif ( this.useRecommendedSettings ) {\n\n\t\t\ttiles.errorTarget = 2;\n\n\t\t}\n\n\t\tthis.tiles = tiles;\n\n\t}\n\n\tloadRootTileset() {\n\n\t\tconst { tiles } = this;\n\n\t\t// initialize href to resolve the root in case it's specified as a relative url\n\t\tlet url = new URL( 'layer.json', new URL( tiles.rootURL, location.href ) );\n\t\ttiles.invokeAllPlugins( plugin => url = plugin.preprocessURL ? plugin.preprocessURL( url, null ) : url );\n\n\t\treturn tiles\n\t\t\t.invokeOnePlugin( plugin => plugin.fetchData && plugin.fetchData( url, this.tiles.fetchOptions ) )\n\t\t\t.then( res => res.json() )\n\t\t\t.then( json => {\n\n\t\t\t\tthis.layer = json;\n\t\t\t\tconst {\n\t\t\t\t\tprojection: layerProjection = 'EPSG:4326',\n\t\t\t\t\textensions = [],\n\t\t\t\t\tattribution = '',\n\t\t\t\t\tavailable = null,\n\t\t\t\t} = json;\n\n\t\t\t\tconst {\n\t\t\t\t\ttiling,\n\t\t\t\t\ttiles,\n\t\t\t\t\tprojection,\n\t\t\t\t} = this;\n\n\t\t\t\t// attribution\n\t\t\t\tif ( attribution ) {\n\n\t\t\t\t\tthis.attribution = {\n\t\t\t\t\t\tvalue: attribution,\n\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\tcollapsible: true,\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\t// extensions\n\t\t\t\tif ( extensions.length > 0 ) {\n\n\t\t\t\t\ttiles.fetchOptions.headers[ 'Accept' ] += `;extensions=${ extensions.join( '-' ) }`;\n\n\t\t\t\t}\n\n\t\t\t\t// initialize tiling, projection\n\t\t\t\tprojection.setScheme( layerProjection );\n\n\t\t\t\tconst { tileCountX, tileCountY } = projection;\n\t\t\t\ttiling.setProjection( projection );\n\t\t\t\ttiling.generateLevels( getMaxLevel( json ) + 1, tileCountX, tileCountY );\n\n\t\t\t\t// initialize children\n\t\t\t\tconst children = [];\n\t\t\t\tfor ( let x = 0; x < tileCountX; x ++ ) {\n\n\t\t\t\t\tconst child = this.createChild( 0, x, 0, available );\n\t\t\t\t\tif ( child ) {\n\n\t\t\t\t\t\tchildren.push( child );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// produce the tileset root\n\t\t\t\tconst tileset = {\n\t\t\t\t\tasset: {\n\t\t\t\t\t\tversion: '1.1'\n\t\t\t\t\t},\n\t\t\t\t\tgeometricError: Infinity,\n\t\t\t\t\troot: {\n\t\t\t\t\t\trefine: 'REPLACE',\n\t\t\t\t\t\tgeometricError: Infinity,\n\t\t\t\t\t\tboundingVolume: {\n\t\t\t\t\t\t\tregion: [ ...this.tiling.getContentBounds(), - INITIAL_HEIGHT_RANGE, INITIAL_HEIGHT_RANGE ],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tchildren: children,\n\n\t\t\t\t\t\t[ TILE_AVAILABLE ]: available,\n\t\t\t\t\t\t[ TILE_LEVEL ]: - 1,\n\t\t\t\t\t},\n\t\t\t\t};\n\n\t\t\t\tlet baseUrl = tiles.rootURL;\n\t\t\t\ttiles.invokeAllPlugins( plugin => baseUrl = plugin.preprocessURL ? plugin.preprocessURL( baseUrl, null ) : baseUrl );\n\t\t\t\ttiles.preprocessTileset( tileset, baseUrl );\n\n\t\t\t\treturn tileset;\n\n\t\t\t} );\n\n\t}\n\n\tparseToMesh( buffer, tile, extension, uri ) {\n\n\t\tconst {\n\t\t\tskirtLength,\n\t\t\tsolid,\n\t\t\tsmoothSkirtNormals,\n\t\t\tgenerateNormals,\n\t\t\ttiles,\n\t\t} = this;\n\n\t\t// set up loader\n\t\tconst ellipsoid = tiles.ellipsoid;\n\n\t\t// split the parent tile if needed\n\t\tlet result;\n\t\tif ( extension === 'quantized_tile_split' ) {\n\n\t\t\t// split the parent tile\n\t\t\tconst searchParams = new URL( uri ).searchParams;\n\t\t\tconst left = searchParams.get( 'left' ) === 'true';\n\t\t\tconst bottom = searchParams.get( 'bottom' ) === 'true';\n\n\t\t\t// parse the tile data\n\t\t\tconst clipper = new QuantizedMeshClipper();\n\t\t\tclipper.ellipsoid.copy( ellipsoid );\n\t\t\tclipper.solid = solid;\n\t\t\tclipper.smoothSkirtNormals = smoothSkirtNormals;\n\t\t\tclipper.skirtLength = skirtLength === null ? tile.geometricError : skirtLength;\n\n\t\t\tconst [ west, south, east, north ] = tile.parent.boundingVolume.region;\n\t\t\tclipper.minLat = south;\n\t\t\tclipper.maxLat = north;\n\t\t\tclipper.minLon = west;\n\t\t\tclipper.maxLon = east;\n\n\t\t\tresult = clipper.clipToQuadrant( tile.parent.engineData.scene, left, bottom );\n\n\t\t} else if ( extension === 'terrain' ) {\n\n\t\t\tconst loader = new QuantizedMeshLoader( tiles.manager );\n\t\t\tloader.ellipsoid.copy( ellipsoid );\n\t\t\tloader.solid = solid;\n\t\t\tloader.smoothSkirtNormals = smoothSkirtNormals;\n\t\t\tloader.generateNormals = generateNormals;\n\t\t\tloader.skirtLength = skirtLength === null ? tile.geometricError : skirtLength;\n\n\t\t\tconst [ west, south, east, north ] = tile.boundingVolume.region;\n\t\t\tloader.minLat = south;\n\t\t\tloader.maxLat = north;\n\t\t\tloader.minLon = west;\n\t\t\tloader.maxLon = east;\n\n\t\t\tresult = loader.parse( buffer );\n\n\t\t} else {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// adjust the bounding region to be more accurate based on the contents of the terrain file\n\t\t// NOTE: The debug region bounds are only created after the tile is first shown so the debug\n\t\t// region bounding volume will have the correct dimensions.\n\t\tconst { minHeight, maxHeight, metadata } = result.userData;\n\t\ttile.boundingVolume.region[ 4 ] = minHeight;\n\t\ttile.boundingVolume.region[ 5 ] = maxHeight;\n\t\ttile.engineData.boundingVolume.setRegionData( ellipsoid, ...tile.boundingVolume.region );\n\n\t\t// use the geometric error value if it's present\n\t\tif ( metadata ) {\n\n\t\t\tif ( 'geometricerror' in metadata ) {\n\n\t\t\t\ttile.geometricError = metadata.geometricerror;\n\n\t\t\t}\n\n\t\t\t// if the tile hasn't been expanded yet and isn't in the queue to do so then\n\t\t\t// mark it for expansion again\n\t\t\tconst hasMetadata = getTileHasMetadata( tile, this.layer );\n\t\t\tif ( hasMetadata && 'available' in metadata && tile.children.length === 0 ) {\n\n\t\t\t\t// add an offset to account for the current and previous layers\n\t\t\t\ttile[ TILE_AVAILABLE ] = [\n\t\t\t\t\t...new Array( tile[ TILE_LEVEL ] + 1 ).fill( null ),\n\t\t\t\t\t...metadata.available,\n\t\t\t\t];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// NOTE: we expand children only once the parent mesh data is loaded to ensure the mesh\n\t\t// data is ready for clipping. It's possible that this child data gets to the parse stage\n\t\t// first, otherwise, while the parent is still downloading.\n\t\t// Ideally we would be able to guarantee parents are loaded first but this is an odd case.\n\t\tthis.expandChildren( tile );\n\n\t\treturn result;\n\n\t}\n\n\tgetAttributions( target ) {\n\n\t\tif ( this.attribution ) {\n\n\t\t\ttarget.push( this.attribution );\n\n\t\t}\n\n\t}\n\n\t// Local functions\n\tcreateChild( level, x, y, available ) {\n\n\t\tconst { tiles, layer, tiling, projection } = this;\n\t\tconst ellipsoid = tiles.ellipsoid;\n\n\t\t// metadata availability will return \"null\" if there are no more children but we\n\t\t// have to always load the root tile data.\n\t\tconst isAvailable = available === null && level === 0 || isTileAvailable( available, level, x, y );\n\t\tconst url = getContentUrl( x, y, level, 1, layer );\n\t\tconst region = [ ...tiling.getTileBounds( x, y, level ), - INITIAL_HEIGHT_RANGE, INITIAL_HEIGHT_RANGE ];\n\t\tconst [ /* west */, south, /* east */, north, /* minHeight */, maxHeight ] = region;\n\t\tconst midLat = ( south > 0 ) !== ( north > 0 ) ? 0 : Math.min( Math.abs( south ), Math.abs( north ) );\n\n\t\t// get the projected perimeter\n\t\tellipsoid.getCartographicToPosition( midLat, 0, maxHeight, _vec );\n\t\t_vec.z = 0;\n\n\t\t// https://github.com/CesiumGS/cesium/blob/53889cbed2a91d38e0fae4b6f2dcf6783632fc92/packages/engine/Source/Scene/QuadtreeTileProvider.js#L24-L31\n\t\t// Implicit quantized mesh tile error halves with every layer\n\t\tconst tileCountX = projection.tileCountX;\n\t\tconst maxRadius = Math.max( ...ellipsoid.radius );\n\t\tconst rootGeometricError = maxRadius * 2 * Math.PI * 0.25 / ( 65 * tileCountX );\n\t\tconst geometricError = rootGeometricError / ( 2 ** level );\n\n\t\t// Create the child\n\t\tconst tile = {\n\t\t\t[ TILE_AVAILABLE ]: null,\n\t\t\t[ TILE_LEVEL ]: level,\n\t\t\t[ TILE_X ]: x,\n\t\t\t[ TILE_Y ]: y,\n\t\t\trefine: 'REPLACE',\n\t\t\tgeometricError: geometricError,\n\t\t\tboundingVolume: { region },\n\t\t\tcontent: isAvailable ? { uri: url } : null,\n\t\t\tchildren: []\n\t\t};\n\n\t\t// if we're relying on tile metadata availability then skip storing the tile metadata\n\t\tif ( ! getTileHasMetadata( tile, layer ) ) {\n\n\t\t\ttile[ TILE_AVAILABLE ] = available;\n\n\t\t}\n\n\t\treturn tile;\n\n\t}\n\n\texpandChildren( tile ) {\n\n\t\tconst level = tile[ TILE_LEVEL ];\n\t\tconst x = tile[ TILE_X ];\n\t\tconst y = tile[ TILE_Y ];\n\t\tconst available = tile[ TILE_AVAILABLE ];\n\n\t\t// only expand down to the highest level\n\t\tif ( level >= this.tiling.maxLevel ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tlet hasChildren = false;\n\t\tfor ( let cx = 0; cx < 2; cx ++ ) {\n\n\t\t\tfor ( let cy = 0; cy < 2; cy ++ ) {\n\n\t\t\t\tconst child = this.createChild( level + 1, 2 * x + cx, 2 * y + cy, available );\n\t\t\t\tif ( child.content !== null ) {\n\n\t\t\t\t\ttile.children.push( child );\n\t\t\t\t\thasChildren = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttile.children.push( child );\n\t\t\t\t\tchild.content = { uri: `tile.quantized_tile_split?bottom=${ cy === 0 }&left=${ cx === 0 }` };\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ! hasChildren ) {\n\n\t\t\ttile.children.length = 0;\n\n\t\t}\n\n\t}\n\n\tfetchData( uri, options ) {\n\n\t\t// if this is our custom url indicating a tile split then return fake response\n\t\tif ( /quantized_tile_split/.test( uri ) ) {\n\n\t\t\treturn new ArrayBuffer();\n\n\t\t}\n\n\t}\n\n\tdisposeTile( tile ) {\n\n\t\t// dispose of the available array since we will get it again if this tile is loaded\n\t\tif ( getTileHasMetadata( tile, this.layer ) ) {\n\n\t\t\ttile[ TILE_AVAILABLE ] = null;\n\n\t\t}\n\n\t\t// Note: we remove all children always because child tiles can rely on splitting parent tiles\n\t\t// and we can find ourselves in a situation where a child tile is ready first but the parent tile\n\t\t// hasn't loaded, causing a stall / race condition in the parsing queue. To avoid this dependency\n\t\t// we just remove all children and generate them again one the parent is loaded.\n\t\t// Only get rid of the children if this plugin was responsible for them.\n\t\tif ( TILE_AVAILABLE in tile ) {\n\n\t\t\ttile.children.forEach( child => {\n\n\t\t\t\t// TODO: there should be a reliable way for removing children like this.\n\t\t\t\tthis.tiles.processNodeQueue.remove( child );\n\n\t\t\t} );\n\t\t\ttile.children.length = 0;\n\n\t\t}\n\n\t}\n\n}\n","import { CesiumIonAuthPlugin as CesiumIonAuthPluginImpl } from '3d-tiles-renderer/core/plugins';\nimport { TMSTilesPlugin } from './images/EPSGTilesPlugin.js';\nimport { QuantizedMeshPlugin } from './QuantizedMeshPlugin.js';\n\nexport class CesiumIonAuthPlugin extends CesiumIonAuthPluginImpl {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( {\n\t\t\tassetTypeHandler: ( type, tiles, asset ) => {\n\n\t\t\t\tif ( type === 'TERRAIN' && tiles.getPluginByName( 'QUANTIZED_MESH_PLUGIN' ) === null ) {\n\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t'CesiumIonAuthPlugin: CesiumIonAuthPlugin plugin auto-registration has been deprecated. ' +\n\t\t\t\t\t\t'Please implement a custom \"assetTypeHandler\" for \"TERRAIN\" using \"QuantizedMeshPlugin\", instead.'\n\t\t\t\t\t);\n\t\t\t\t\ttiles.registerPlugin( new QuantizedMeshPlugin( {\n\t\t\t\t\t\tuseRecommendedSettings: this.useRecommendedSettings,\n\t\t\t\t\t} ) );\n\n\t\t\t\t} else if ( type === 'IMAGERY' && tiles.getPluginByName( 'TMS_TILES_PLUGIN' ) === null ) {\n\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t'CesiumIonAuthPlugin: CesiumIonAuthPlugin plugin auto-registration has been deprecated. ' +\n\t\t\t\t\t\t'Please implement a custom \"assetTypeHandler\" for \"IMAGERY\" using \"TMSTilesPlugin\", instead.'\n\t\t\t\t\t);\n\t\t\t\t\ttiles.registerPlugin( new TMSTilesPlugin( {\n\t\t\t\t\t\tuseRecommendedSettings: this.useRecommendedSettings,\n\t\t\t\t\t\tshape: 'ellipsoid',\n\t\t\t\t\t} ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( `CesiumIonAuthPlugin: Cesium Ion asset type \"${ type }\" unhandled.` );\n\n\t\t\t\t}\n\n\t\t\t},\n\t\t\t...options,\n\t\t} );\n\n\t\tif ( options.__suppress_warning__ ) {\n\n\t\t\tconsole.warn(\n\t\t\t\t'CesiumIonAuthPlugin: Plugin has been moved to \"3d-tiles-renderer/core/plugins\".'\n\t\t\t);\n\n\t\t}\n\n\t}\n\n}\n","// Export all core plugins\nexport * from '3d-tiles-renderer/core/plugins';\n\n// Export all three.js plugins\nexport * from '3d-tiles-renderer/three/plugins';\n\n// Override with backward compatible version (no constructor warning)\nimport { CesiumIonAuthPlugin as CesiumIonAuthPluginDeprecated } from '3d-tiles-renderer/three/plugins';\nexport class CesiumIonAuthPlugin extends CesiumIonAuthPluginDeprecated {\n\n\tconstructor( options ) {\n\n\t\tsuper( {\n\t\t\t...options,\n\t\t\t__suppress_warning__: true,\n\t\t} );\n\n\t}\n\n}\n"],"names":["zigZagDecode","value","QuantizedMeshLoaderBase","LoaderBase","args","fetchOptions","buffer","pointer","view","readFloat64","result","readFloat32","readInt","readByte","readBuffer","count","type","header","vertexCount","uBuffer","vBuffer","hBuffer","uResult","vResult","hResult","u","v","h","MAX_VALUE","i","is32","bufferType","triangleCount","indices","highest","code","vSort","a","b","vSortReverse","uSort","uSortReverse","westVertexCount","westIndices","southVertexCount","southIndices","eastVertexCount","eastIndices","northVertexCount","northIndices","edgeIndices","extensions","extensionId","extensionLength","xy","normals","x","y","z","oldVX","signNotZero","len","size","mask","jsonLength","jsonBuffer","json","_norm","Vector3","_tri","Triangle","_uvh","_pos","QuantizedMeshLoader","manager","DefaultLoadingManager","Ellipsoid","ellipsoid","solid","skirtLength","smoothSkirtNormals","generateNormals","minLat","maxLat","minLon","maxLon","vertexData","geometry","BufferGeometry","material","MeshStandardMaterial","mesh","Mesh","hasNormalExtension","includeNormals","positions","uvs","indexArr","groupOffset","materialIndex","readUVHeight","readPosition","l","extNormals","tempGeometry","tempIndexBuffer","BufferAttribute","generatedNormals","indexOffset","offset","westStrip","constructEdgeStrip","eastStrip","southStrip","northStrip","indexBuffer","maskBuffer","map","DataTexture","RGFormat","UnsignedByteType","LinearMipMapLinearFilter","LinearFilter","index","target","heightOffset","height","MathUtils","lon","lat","topUvs","topPos","botUvs","botPos","sideIndices","triCount","t0","t1","b0","b1","total","botOffset","i3","nx","ny","nz","_cart","_vec","_pos0","_pos1","_pos2","_pos3","_temp","_temp2","_uv0","Vector2","_uv1","_uv2","QuantizedMeshClipper","GeometryClipper","sourceMesh","left","bottom","getUvSplitOperation","botResult","skirtResult","capGroup","capResult","key","normal","nextIndex","vertToNewIndexMap","pushVertex","pos","uv","norm","hash","hashVertex","capIndex","capUv","capPosition","capNormal","capTriangles","triOffset","e","ne","i0","i1","u0","u1","capLength","attributes","xUvOffset","yUvOffset","resultMesh","start","info","position","vertexIsClipped","posArr","uvArr","point","axis","i2","barycoord","TILE_X","TILE_Y","TILE_LEVEL","TILE_AVAILABLE","INITIAL_HEIGHT_RANGE","isTileAvailable","available","level","availableSet","startX","startY","endX","endY","getMaxLevel","layer","maxzoom","getMetadataAvailability","metadataAvailability","getTileHasMetadata","tile","maxLevel","getContentUrl","version","QuantizedMeshPlugin","options","useRecommendedSettings","TilingScheme","ProjectionScheme","tiles","url","plugin","res","layerProjection","attribution","tiling","projection","tileCountX","tileCountY","children","child","tileset","baseUrl","extension","uri","searchParams","clipper","west","south","east","north","loader","minHeight","maxHeight","metadata","isAvailable","region","midLat","geometricError","hasChildren","cx","cy","CesiumIonAuthPluginImpl","asset","TMSTilesPlugin","CesiumIonAuthPlugin","CesiumIonAuthPluginDeprecated"],"mappings":"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"}