{"version":3,"file":"TilesFadePlugin-BRcOjUD_.js","sources":["../../../src/three/plugins/fade/FadeManager.js","../../../src/three/plugins/fade/wrapFadeMaterial.js","../../../src/three/plugins/fade/FadeMaterialManager.js","../../../src/three/plugins/fade/PassThroughBatchedMesh.js","../../../src/three/plugins/fade/FadeBatchedMesh.js","../../../src/three/plugins/fade/TilesFadePlugin.js"],"sourcesContent":["import { MathUtils } from 'three';\n\nconst { clamp } = MathUtils;\nexport class FadeManager {\n\n\tconstructor() {\n\n\t\tthis.duration = 250;\n\t\tthis.fadeCount = 0;\n\t\tthis._lastTick = - 1;\n\t\tthis._fadeState = new Map();\n\t\tthis.onFadeComplete = null;\n\t\tthis.onFadeStart = null;\n\t\tthis.onFadeSetComplete = null;\n\t\tthis.onFadeSetStart = null;\n\n\t}\n\n\t// delete the object from the fade, reset the material data\n\tdeleteObject( object ) {\n\n\t\tif ( ! object ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.completeFade( object );\n\n\t}\n\n\t// Ensure we're storing a fade timer for the provided object\n\t// Returns whether a new state had to be added\n\tguaranteeState( object ) {\n\n\t\tconst fadeState = this._fadeState;\n\t\tif ( fadeState.has( object ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst state = {\n\t\t\tfadeInTarget: 0,\n\t\t\tfadeOutTarget: 0,\n\t\t\tfadeIn: 0,\n\t\t\tfadeOut: 0,\n\t\t};\n\n\t\tfadeState.set( object, state );\n\n\t\treturn true;\n\n\t}\n\n\t// Force the fade to complete in the direction it is already trending\n\tcompleteFade( object ) {\n\n\t\tconst fadeState = this._fadeState;\n\t\tif ( ! fadeState.has( object ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst visible = fadeState.get( object ).fadeOutTarget === 0;\n\n\t\tfadeState.delete( object );\n\n\t\t// fire events\n\t\tthis.fadeCount --;\n\n\t\tif ( this.onFadeComplete ) {\n\n\t\t\tthis.onFadeComplete( object, visible );\n\n\t\t}\n\n\t\tif ( this.fadeCount === 0 && this.onFadeSetComplete ) {\n\n\t\t\tthis.onFadeSetComplete();\n\n\t\t}\n\n\t}\n\n\tcompleteAllFades() {\n\n\t\tthis._fadeState.forEach( ( value, key ) => {\n\n\t\t\tthis.completeFade( key );\n\n\t\t} );\n\n\t}\n\n\tforEachObject( cb ) {\n\n\t\tthis._fadeState.forEach( ( info, object ) => {\n\n\t\t\tcb( object, info );\n\n\t\t} );\n\n\t}\n\n\t// Fade the object in\n\tfadeIn( object ) {\n\n\t\tconst noState = this.guaranteeState( object );\n\t\tconst state = this._fadeState.get( object );\n\t\tstate.fadeInTarget = 1;\n\t\tstate.fadeOutTarget = 0;\n\t\tstate.fadeOut = 0;\n\n\t\t// Fire events\n\t\tif ( noState ) {\n\n\t\t\tthis.fadeCount ++;\n\t\t\tif ( this.fadeCount === 1 && this.onFadeSetStart ) {\n\n\t\t\t\tthis.onFadeSetStart();\n\n\t\t\t}\n\n\t\t\tif ( this.onFadeStart ) {\n\n\t\t\t\tthis.onFadeStart( object );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Fade the object out\n\tfadeOut( object ) {\n\n\t\tconst noState = this.guaranteeState( object );\n\t\tconst state = this._fadeState.get( object );\n\t\tstate.fadeOutTarget = 1;\n\n\t\t// Fire events and initialize state\n\t\tif ( noState ) {\n\n\t\t\tstate.fadeInTarget = 1;\n\t\t\tstate.fadeIn = 1;\n\n\t\t\tthis.fadeCount ++;\n\t\t\tif ( this.fadeCount === 1 && this.onFadeSetStart ) {\n\n\t\t\t\tthis.onFadeSetStart();\n\n\t\t\t}\n\n\t\t\tif ( this.onFadeStart ) {\n\n\t\t\t\tthis.onFadeStart( object );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tisFading( object ) {\n\n\t\treturn this._fadeState.has( object );\n\n\t}\n\n\tisFadingOut( object ) {\n\n\t\tconst state = this._fadeState.get( object );\n\t\treturn state && state.fadeOutTarget === 1;\n\n\t}\n\n\t// Tick the fade timer for each actively fading object\n\tupdate() {\n\n\t\t// clamp delta in case duration is really small or 0\n\t\tconst time = window.performance.now();\n\t\tif ( this._lastTick === - 1 ) {\n\n\t\t\tthis._lastTick = time;\n\n\t\t}\n\n\t\tconst delta = clamp( ( time - this._lastTick ) / this.duration, 0, 1 );\n\t\tthis._lastTick = time;\n\n\t\tconst fadeState = this._fadeState;\n\t\tfadeState.forEach( ( state, object ) => {\n\n\t\t\t// tick the fade values\n\t\t\tconst {\n\t\t\t\tfadeOutTarget,\n\t\t\t\tfadeInTarget,\n\t\t\t} = state;\n\n\t\t\tlet {\n\t\t\t\tfadeOut,\n\t\t\t\tfadeIn,\n\t\t\t} = state;\n\n\t\t\tconst fadeInSign = Math.sign( fadeInTarget - fadeIn );\n\t\t\tfadeIn = clamp( fadeIn + fadeInSign * delta, 0, 1 );\n\n\t\t\tconst fadeOutSign = Math.sign( fadeOutTarget - fadeOut );\n\t\t\tfadeOut = clamp( fadeOut + fadeOutSign * delta, 0, 1 );\n\n\t\t\tstate.fadeIn = fadeIn;\n\t\t\tstate.fadeOut = fadeOut;\n\n\t\t\t// Check if the fade in and fade out animations are complete\n\t\t\tconst fadeOutComplete = fadeOut === 1 || fadeOut === 0;\n\t\t\tconst fadeInComplete = fadeIn === 1 || fadeIn === 0;\n\n\t\t\t// If they are or the fade out animation is further along than the\n\t\t\t// fade in animation then mark the fade as completed for this tile\n\t\t\tif ( ( fadeOutComplete && fadeInComplete ) || fadeOut >= fadeIn ) {\n\n\t\t\t\tthis.completeFade( object );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n}\n","// Adjusts the provided material to support fading in and out using a bayer pattern. Providing a \"previous\"\n// before compile can be used to chain shader adjustments. Returns the added uniforms used for fading.\nconst FADE_PARAMS = Symbol( 'FADE_PARAMS' );\nexport function wrapFadeMaterial( material, previousOnBeforeCompile ) {\n\n\t// if the material has already been wrapped then return the params\n\tif ( material[ FADE_PARAMS ] ) {\n\n\t\treturn material[ FADE_PARAMS ];\n\n\t}\n\n\tconst params = {\n\t\tfadeIn: { value: 0 },\n\t\tfadeOut: { value: 0 },\n\t\tfadeTexture: { value: null },\n\t};\n\n\tmaterial[ FADE_PARAMS ] = params;\n\n\tmaterial.defines = {\n\t\t...( material.defines || {} ),\n\t\tFEATURE_FADE: 0,\n\t};\n\n\tmaterial.onBeforeCompile = shader => {\n\n\t\tif ( previousOnBeforeCompile ) {\n\n\t\t\tpreviousOnBeforeCompile( shader );\n\n\t\t}\n\n\t\tshader.uniforms = {\n\t\t\t...shader.uniforms,\n\t\t\t...params,\n\t\t};\n\n\t\tshader.vertexShader = shader.vertexShader\n\t\t\t.replace(\n\t\t\t\t/void\\s+main\\(\\)\\s+{/,\n\t\t\t\tvalue => /* glsl */`\n\t\t\t\t\t#ifdef USE_BATCHING_FRAG\n\n\t\t\t\t\tvarying float vBatchId;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t${ value }\n\n\t\t\t\t\t\t#ifdef USE_BATCHING_FRAG\n\n\t\t\t\t\t\t// add 0.5 to the value to avoid floating error that may cause flickering\n\t\t\t\t\t\tvBatchId = getIndirectIndex( gl_DrawID ) + 0.5;\n\n\t\t\t\t\t\t#endif\n\t\t\t\t`\n\t\t\t);\n\n\t\tshader.fragmentShader = shader.fragmentShader\n\t\t\t.replace( /void main\\(/, value => /* glsl */`\n\t\t\t\t#if FEATURE_FADE\n\n\t\t\t\t// adapted from https://www.shadertoy.com/view/Mlt3z8\n\t\t\t\tfloat bayerDither2x2( vec2 v ) {\n\n\t\t\t\t\treturn mod( 3.0 * v.y + 2.0 * v.x, 4.0 );\n\n\t\t\t\t}\n\n\t\t\t\tfloat bayerDither4x4( vec2 v ) {\n\n\t\t\t\t\tvec2 P1 = mod( v, 2.0 );\n\t\t\t\t\tvec2 P2 = floor( 0.5 * mod( v, 4.0 ) );\n\t\t\t\t\treturn 4.0 * bayerDither2x2( P1 ) + bayerDither2x2( P2 );\n\n\t\t\t\t}\n\n\t\t\t\t// the USE_BATCHING define is not available in fragment shaders\n\t\t\t\t#ifdef USE_BATCHING_FRAG\n\n\t\t\t\t// functions for reading the fade state of a given batch id\n\t\t\t\tuniform sampler2D fadeTexture;\n\t\t\t\tvarying float vBatchId;\n\t\t\t\tvec2 getFadeValues( const in float i ) {\n\n\t\t\t\t\tint size = textureSize( fadeTexture, 0 ).x;\n\t\t\t\t\tint j = int( i );\n\t\t\t\t\tint x = j % size;\n\t\t\t\t\tint y = j / size;\n\t\t\t\t\treturn texelFetch( fadeTexture, ivec2( x, y ), 0 ).rg;\n\n\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\tuniform float fadeIn;\n\t\t\t\tuniform float fadeOut;\n\n\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t${ value }\n\t\t\t` )\n\t\t\t.replace( /#include <dithering_fragment>/, value => /* glsl */`\n\n\t\t\t\t${ value }\n\n\t\t\t\t#if FEATURE_FADE\n\n\t\t\t\t#ifdef USE_BATCHING_FRAG\n\n\t\t\t\tvec2 fadeValues = getFadeValues( vBatchId );\n\t\t\t\tfloat fadeIn = fadeValues.r;\n\t\t\t\tfloat fadeOut = fadeValues.g;\n\n\t\t\t\t#endif\n\n\t\t\t\tfloat bayerValue = bayerDither4x4( floor( mod( gl_FragCoord.xy, 4.0 ) ) );\n\t\t\t\tfloat bayerBins = 16.0;\n\t\t\t\tfloat dither = ( 0.5 + bayerValue ) / bayerBins;\n\t\t\t\tif ( dither >= fadeIn ) {\n\n\t\t\t\t\tdiscard;\n\n\t\t\t\t}\n\n\t\t\t\tif ( dither < fadeOut ) {\n\n\t\t\t\t\tdiscard;\n\n\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t` );\n\n\t};\n\n\treturn params;\n\n}\n","import { wrapFadeMaterial } from './wrapFadeMaterial.js';\n\n// Class for managing and updating extended fade parameters\nexport class FadeMaterialManager {\n\n\tconstructor() {\n\n\t\tthis._fadeParams = new WeakMap();\n\t\tthis.fading = 0;\n\n\t}\n\n\t// Set the fade parameters for the given scene\n\tsetFade( scene, fadeIn, fadeOut ) {\n\n\t\tif ( ! scene ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// traverse the scene and update the fade parameters of all materials\n\t\tconst fadeParams = this._fadeParams;\n\t\tscene.traverse( child => {\n\n\t\t\tconst material = child.material;\n\t\t\tif ( material && fadeParams.has( material ) ) {\n\n\t\t\t\tconst params = fadeParams.get( material );\n\t\t\t\tparams.fadeIn.value = fadeIn;\n\t\t\t\tparams.fadeOut.value = fadeOut;\n\n\t\t\t\tconst fadeInComplete = fadeIn === 0 || fadeIn === 1;\n\t\t\t\tconst fadeOutComplete = fadeOut === 0 || fadeOut === 1;\n\t\t\t\tconst value = Number( ! fadeInComplete || ! fadeOutComplete );\n\t\t\t\tif ( material.defines.FEATURE_FADE !== value ) {\n\n\t\t\t\t\tthis.fading += value === 1 ? 1 : - 1;\n\t\t\t\t\tmaterial.defines.FEATURE_FADE = value;\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t// initialize materials in the object\n\tprepareScene( scene ) {\n\n\t\tscene.traverse( child => {\n\n\t\t\tif ( child.material ) {\n\n\t\t\t\tthis.prepareMaterial( child.material );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t// delete the object from the fade, reset the material data\n\tdeleteScene( scene ) {\n\n\t\tif ( ! scene ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// mark the materials such that they are displayed at full value\n\t\tthis.setFade( scene, 1, 0 );\n\n\t\t// revert the materials\n\t\tconst fadeParams = this._fadeParams;\n\t\tscene.traverse( child => {\n\n\t\t\tconst material = child.material;\n\t\t\tif ( material ) {\n\n\t\t\t\tfadeParams.delete( material );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t// initialize the material\n\tprepareMaterial( material ) {\n\n\t\tconst fadeParams = this._fadeParams;\n\t\tif ( fadeParams.has( material ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tfadeParams.set( material, wrapFadeMaterial( material, material.onBeforeCompile ) );\n\n\t}\n\n}\n","import { MeshBasicMaterial } from 'three';\n\n// A hacky version of BatchedMesh that passes through functions and geometry and other fields from the underlying\n// BatchedMesh. Calls to \"this\" or \"super\" will not work in subfunctions.\nexport class PassThroughBatchedMesh {\n\n\tconstructor( other, material = new MeshBasicMaterial() ) {\n\n\t\t// the other batched mesh\n\t\tthis.other = other;\n\n\t\t// guarded fields\n\t\tthis.material = material;\n\t\tthis.visible = true;\n\t\tthis.parent = null;\n\t\tthis._instanceInfo = [];\n\t\tthis._visibilityChanged = true;\n\n\t\t// the proxy instance tht pass through arguments to the underlying mesh\n\t\tconst proxyTarget = new Proxy( this, {\n\n\t\t\tget( target, key ) {\n\n\t\t\t\tif ( key in target ) {\n\n\t\t\t\t\treturn target[ key ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// sync instances on function call and call functions on \"this\" instance\n\t\t\t\t\tconst value = other[ key ];\n\t\t\t\t\tif ( value instanceof Function ) {\n\n\t\t\t\t\t\treturn ( ...args ) => {\n\n\t\t\t\t\t\t\ttarget.syncInstances();\n\t\t\t\t\t\t\treturn value.call( proxyTarget, ...args );\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn other[ key ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tset( target, key, value ) {\n\n\t\t\t\tif ( key in target ) {\n\n\t\t\t\t\ttarget[ key ] = value;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tother[ key ] = value;\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t},\n\n\t\t\tdeleteProperty( target, key ) {\n\n\t\t\t\tif ( key in target ) {\n\n\t\t\t\t\treturn delete target[ key ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn delete other[ key ];\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\t// ownKeys() {},\n\t\t\t// has(target, key) {},\n\t\t\t// defineProperty(target, key, descriptor) {},\n\t\t\t// getOwnPropertyDescriptor(target, key) {},\n\n\t\t} );\n\n\t\treturn proxyTarget;\n\n\t}\n\n\tsyncInstances() {\n\n\t\tconst instanceInfo = this._instanceInfo;\n\t\tconst otherInstanceInfo = this.other._instanceInfo;\n\t\twhile ( otherInstanceInfo.length > instanceInfo.length ) {\n\n\t\t\tconst index = instanceInfo.length;\n\t\t\tinstanceInfo.push( new Proxy( { visible: false }, {\n\n\t\t\t\tget( target, key ) {\n\n\t\t\t\t\tif ( key in target ) {\n\n\t\t\t\t\t\treturn target[ key ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn otherInstanceInfo[ index ][ key ];\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tset( target, key, value ) {\n\n\t\t\t\t\tif ( key in target ) {\n\n\t\t\t\t\t\ttarget[ key ] = value;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\totherInstanceInfo[ index ][ key ] = value;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t} ) );\n\n\t\t}\n\n\t}\n\n}\n","import { PassThroughBatchedMesh } from './PassThroughBatchedMesh.js';\nimport { RGFormat, UnsignedByteType, DataTexture } from 'three';\nimport { wrapFadeMaterial } from './wrapFadeMaterial.js';\n\n// BatchedMesh instance that can fade materials\nexport class FadeBatchedMesh extends PassThroughBatchedMesh {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\t// construct a version of the material that supports fading\n\t\tconst material = this.material;\n\t\tconst params = wrapFadeMaterial( material, material.onBeforeCompile );\n\t\tmaterial.defines.FEATURE_FADE = 1;\n\t\tmaterial.defines.USE_BATCHING_FRAG = 1;\n\t\tmaterial.needsUpdate = true;\n\n\t\t// fade parameters\n\t\tthis.fadeTexture = null;\n\t\tthis._fadeParams = params;\n\n\t}\n\n\t// Set the fade state\n\tsetFadeAt( index, fadeIn, fadeOut ) {\n\n\t\tthis._initFadeTexture();\n\t\tthis.fadeTexture.setValueAt( index, fadeIn * 255, fadeOut * 255 );\n\n\t}\n\n\t// initialize the texture and resize it if needed\n\t_initFadeTexture() {\n\n\t\t// calculate the new size\n\t\tlet size = Math.sqrt( this._maxInstanceCount );\n\t\tsize = Math.ceil( size );\n\n\t\tconst length = size * size * 2;\n\t\tconst oldFadeTexture = this.fadeTexture;\n\t\tif ( ! oldFadeTexture || oldFadeTexture.image.data.length !== length ) {\n\n\t\t\t// 2 bytes per RG pixel\n\t\t\tconst fadeArray = new Uint8Array( length );\n\t\t\tconst fadeTexture = new InstanceDataTexture( fadeArray, size, size, RGFormat, UnsignedByteType );\n\n\t\t\t// copy the data from the old fade texture if it exists\n\t\t\tif ( oldFadeTexture ) {\n\n\t\t\t\toldFadeTexture.dispose();\n\n\t\t\t\tconst src = oldFadeTexture.image.data;\n\t\t\t\tconst dst = this.fadeTexture.image.data;\n\t\t\t\tconst len = Math.min( src.length, dst.length );\n\t\t\t\tdst.set( new src.constructor( src.buffer, 0, len ) );\n\n\t\t\t}\n\n\t\t\t// assign the new fade texture to the uniform, member variable\n\t\t\tthis.fadeTexture = fadeTexture;\n\t\t\tthis._fadeParams.fadeTexture.value = fadeTexture;\n\t\t\tfadeTexture.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\t// dispose the fade texture. Super cannot be used here due to proxy\n\tdispose() {\n\n\t\tif ( this.fadeTexture ) {\n\n\t\t\tthis.fadeTexture.dispose();\n\n\t\t}\n\n\t}\n\n}\n\n// Version of data texture that can assign pixel values\nclass InstanceDataTexture extends DataTexture {\n\n\tsetValueAt( instance, ...values ) {\n\n\t\tconst { data, width, height } = this.image;\n\t\tconst itemSize = Math.floor( data.length / ( width * height ) );\n\t\tlet needsUpdate = false;\n\t\tfor ( let i = 0; i < itemSize; i ++ ) {\n\n\t\t\tconst index = instance * itemSize + i;\n\t\t\tconst prevValue = data[ index ];\n\t\t\tconst newValue = values[ i ] || 0;\n\t\t\tif ( prevValue !== newValue ) {\n\n\t\t\t\tdata[ index ] = newValue;\n\t\t\t\tneedsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( needsUpdate ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n}\n","import { Matrix4, Vector3, Quaternion } from 'three';\nimport { FadeManager } from './FadeManager.js';\nimport { FadeMaterialManager } from './FadeMaterialManager.js';\nimport { FadeBatchedMesh } from './FadeBatchedMesh.js';\n\nconst HAS_POPPED_IN = Symbol( 'HAS_POPPED_IN' );\nconst _fromPos = /* @__PURE__ */ new Vector3();\nconst _toPos = /* @__PURE__ */ new Vector3();\nconst _fromQuat = /* @__PURE__ */ new Quaternion();\nconst _toQuat = /* @__PURE__ */ new Quaternion();\nconst _scale = /* @__PURE__ */ new Vector3();\n\nfunction onUpdateBefore() {\n\n\tconst fadeManager = this._fadeManager;\n\tconst tiles = this.tiles;\n\n\t// store the tiles renderer state before the tiles update so we can check\n\t// whether fading started or stopped completely\n\tthis._fadingBefore = fadeManager.fadeCount;\n\tthis._displayActiveTiles = tiles.displayActiveTiles;\n\n\t// we need to display all active tiles in this case so we don't fade tiles in\n\t// when moving from off screen\n\ttiles.displayActiveTiles = true;\n\n}\n\nfunction onUpdateAfter() {\n\n\tconst fadeManager = this._fadeManager;\n\tconst fadeMaterialManager = this._fadeMaterialManager;\n\tconst displayActiveTiles = this._displayActiveTiles;\n\tconst fadingBefore = this._fadingBefore;\n\tconst prevCameraTransforms = this._prevCameraTransforms;\n\tconst { tiles, maximumFadeOutTiles, batchedMesh } = this;\n\tconst { cameras } = tiles;\n\n\t// reset the active tiles flag\n\ttiles.displayActiveTiles = displayActiveTiles;\n\n\t// update fade step\n\tfadeManager.update();\n\n\t// fire an event\n\tconst fadingAfter = fadeManager.fadeCount;\n\tif ( fadingBefore !== 0 && fadingAfter !== 0 ) {\n\n\t\ttiles.dispatchEvent( { type: 'fade-change' } );\n\t\ttiles.dispatchEvent( { type: 'needs-render' } );\n\n\t}\n\n\t// update the visibility of tiles based on visibility since we must use\n\t// the active tiles for rendering fade\n\tif ( ! displayActiveTiles ) {\n\n\t\ttiles.visibleTiles.forEach( t => {\n\n\t\t\t// if a tile is fading out then it may not be traversed and thus will not have\n\t\t\t// the frustum flag set correctly.\n\t\t\tconst scene = t.engineData.scene;\n\t\t\tif ( scene ) {\n\n\t\t\t\tscene.visible = t.traversal.inFrustum;\n\n\t\t\t}\n\n\t\t\tthis.forEachBatchIds( t, ( id, batchedMesh, plugin ) => {\n\n\t\t\t\tbatchedMesh.setVisibleAt( id, t.traversal.inFrustum );\n\t\t\t\tplugin.batchedMesh.setVisibleAt( id, t.traversal.inFrustum );\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\tif ( maximumFadeOutTiles < this._fadingOutCount ) {\n\n\t\t// determine whether all the rendering cameras are moving\n\t\t// quickly so we can adjust how tiles fade accordingly\n\t\tlet isMovingFast = true;\n\t\tcameras.forEach( camera => {\n\n\t\t\tif ( ! prevCameraTransforms.has( camera ) ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst currMatrix = camera.matrixWorld;\n\t\t\tconst prevMatrix = prevCameraTransforms.get( camera );\n\n\t\t\tcurrMatrix.decompose( _toPos, _toQuat, _scale );\n\t\t\tprevMatrix.decompose( _fromPos, _fromQuat, _scale );\n\n\t\t\tconst angleTo = _toQuat.angleTo( _fromQuat );\n\t\t\tconst positionTo = _toPos.distanceTo( _fromPos );\n\n\t\t\t// if rotation is moving > 0.25 radians per frame or position is moving > 0.1 units\n\t\t\t// then we are considering the camera to be moving too fast to notice a faster / abrupt fade\n\t\t\tisMovingFast = isMovingFast && ( angleTo > 0.25 || positionTo > 0.1 );\n\n\t\t} );\n\n\t\tif ( isMovingFast ) {\n\n\t\t\tfadeManager.completeAllFades();\n\n\t\t}\n\n\t}\n\n\t// track the camera movement so we can use it for next frame\n\tcameras.forEach( camera => {\n\n\t\tprevCameraTransforms.get( camera ).copy( camera.matrixWorld );\n\n\t} );\n\n\t// update the fade state for each tile\n\tfadeManager.forEachObject( ( tile, { fadeIn, fadeOut } ) => {\n\n\t\t// prevent faded tiles from being unloaded\n\t\tconst scene = tile.engineData.scene;\n\t\tconst isFadingOut = fadeManager.isFadingOut( tile );\n\t\ttiles.markTileUsed( tile );\n\t\tif ( scene ) {\n\n\t\t\tfadeMaterialManager.setFade( scene, fadeIn, fadeOut );\n\t\t\tif ( isFadingOut ) {\n\n\t\t\t\tscene.visible = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// fade the tiles and toggle the visibility appropriately\n\t\tthis.forEachBatchIds( tile, ( id, batchedMesh, plugin ) => {\n\n\t\t\tbatchedMesh.setFadeAt( id, fadeIn, fadeOut );\n\t\t\tbatchedMesh.setVisibleAt( id, true );\n\t\t\tplugin.batchedMesh.setVisibleAt( id, false );\n\n\t\t} );\n\n\t} );\n\n\t// update the batched mesh fields\n\tif ( batchedMesh ) {\n\n\t\tconst material = tiles.getPluginByName( 'BATCHED_TILES_PLUGIN' ).batchedMesh.material;\n\t\tbatchedMesh.material.map = material.map;\n\n\t}\n\n}\n\nexport class TilesFadePlugin {\n\n\tget fadeDuration() {\n\n\t\treturn this._fadeManager.duration;\n\n\t}\n\n\tset fadeDuration( value ) {\n\n\t\tthis._fadeManager.duration = Number( value );\n\n\t}\n\n\tget fadingTiles() {\n\n\t\treturn this._fadeManager.fadeCount;\n\n\t}\n\n\tconstructor( options ) {\n\n\t\toptions = {\n\n\t\t\tmaximumFadeOutTiles: 50,\n\t\t\tfadeRootTiles: false,\n\t\t\tfadeDuration: 250,\n\t\t\t...options,\n\n\t\t};\n\n\t\tthis.name = 'FADE_TILES_PLUGIN';\n\t\tthis.priority = - 2;\n\n\t\tthis.tiles = null;\n\t\tthis.batchedMesh = null;\n\t\tthis._quickFadeTiles = new Set();\n\t\tthis._fadeManager = new FadeManager();\n\t\tthis._fadeMaterialManager = new FadeMaterialManager();\n\t\tthis._prevCameraTransforms = null;\n\t\tthis._fadingOutCount = 0;\n\n\t\tthis.maximumFadeOutTiles = options.maximumFadeOutTiles;\n\t\tthis.fadeRootTiles = options.fadeRootTiles;\n\t\tthis.fadeDuration = options.fadeDuration;\n\n\t}\n\n\tinit( tiles ) {\n\n\t\t// event callback initialization\n\t\tthis._onLoadModel = ( { scene } )=> {\n\n\t\t\t// initialize all the scene materials to fade\n\t\t\tthis._fadeMaterialManager.prepareScene( scene );\n\n\t\t};\n\n\t\tthis._onDisposeModel = ( { tile, scene } ) => {\n\n\t\t\tif ( this.tiles.visibleTiles.has( tile ) ) {\n\n\t\t\t\t// mark the parent as needing to fade in quickly to accommodate the children disappearing.\n\t\t\t\t// this can happen when a tile is forcefully disposed or removed from the lru cache while visible.\n\t\t\t\tthis._quickFadeTiles.add( tile.parent );\n\n\t\t\t}\n\n\t\t\t// delete the fade info from the managers on disposal of model\n\t\t\tthis._fadeManager.deleteObject( tile );\n\t\t\tthis._fadeMaterialManager.deleteScene( scene );\n\n\t\t};\n\n\t\tthis._onAddCamera = ( { camera } ) => {\n\n\t\t\t// track the camera transform\n\t\t\tthis._prevCameraTransforms.set( camera, new Matrix4() );\n\n\t\t};\n\n\t\tthis._onDeleteCamera = ( { camera } )=> {\n\n\t\t\t// remove the camera transform\n\t\t\tthis._prevCameraTransforms.delete( camera );\n\n\t\t};\n\n\t\tthis._onTileVisibilityChange = ( { tile, visible } ) => {\n\n\t\t\t// this function gets fired _after_ all set visible callbacks including the batched meshes\n\n\t\t\t// revert the scene and fade to the initial state when toggling\n\t\t\tconst scene = tile.engineData.scene;\n\t\t\tif ( scene ) {\n\n\t\t\t\tscene.visible = true;\n\n\t\t\t}\n\n\t\t\tthis.forEachBatchIds( tile, ( id, batchedMesh, plugin ) => {\n\n\t\t\t\tbatchedMesh.setFadeAt( id, 0, 0 );\n\t\t\t\tbatchedMesh.setVisibleAt( id, false );\n\t\t\t\tplugin.batchedMesh.setVisibleAt( id, false );\n\n\t\t\t} );\n\n\t\t};\n\n\t\tthis._onUpdateBefore = () => {\n\n\t\t\tonUpdateBefore.call( this );\n\n\t\t};\n\n\t\tthis._onUpdateAfter = () => {\n\n\t\t\tonUpdateAfter.call( this );\n\n\t\t};\n\n\t\ttiles.addEventListener( 'load-model', this._onLoadModel );\n\t\ttiles.addEventListener( 'dispose-model', this._onDisposeModel );\n\t\ttiles.addEventListener( 'add-camera', this._onAddCamera );\n\t\ttiles.addEventListener( 'delete-camera', this._onDeleteCamera );\n\t\ttiles.addEventListener( 'update-before', this._onUpdateBefore );\n\t\ttiles.addEventListener( 'update-after', this._onUpdateAfter );\n\t\ttiles.addEventListener( 'tile-visibility-change', this._onTileVisibilityChange );\n\n\t\t// initialize fade manager\n\t\tconst fadeManager = this._fadeManager;\n\t\tfadeManager.onFadeSetStart = () => {\n\n\t\t\ttiles.dispatchEvent( { type: 'fade-start' } );\n\t\t\ttiles.dispatchEvent( { type: 'needs-render' } );\n\n\t\t};\n\n\t\tfadeManager.onFadeSetComplete = () => {\n\n\t\t\ttiles.dispatchEvent( { type: 'fade-end' } );\n\t\t\ttiles.dispatchEvent( { type: 'needs-render' } );\n\n\t\t};\n\n\t\tfadeManager.onFadeComplete = ( tile, visible ) => {\n\n\t\t\t// mark the fade as finished and reset the fade parameters\n\t\t\tthis._fadeMaterialManager.setFade( tile.engineData.scene, 0, 0 );\n\n\t\t\tthis.forEachBatchIds( tile, ( id, batchedMesh, plugin ) => {\n\n\t\t\t\tbatchedMesh.setFadeAt( id, 0, 0 );\n\t\t\t\tbatchedMesh.setVisibleAt( id, false );\n\t\t\t\tplugin.batchedMesh.setVisibleAt( id, visible );\n\n\t\t\t} );\n\n\t\t\tif ( ! visible ) {\n\n\t\t\t\t// now that the tile is hidden we can run the built-in setTileVisible function for the tile\n\t\t\t\ttiles.invokeOnePlugin( plugin => plugin !== this && plugin.setTileVisible && plugin.setTileVisible( tile, false ) );\n\t\t\t\tthis._fadingOutCount --;\n\n\t\t\t}\n\n\t\t};\n\n\t\t// initialize the state based on what's already present\n\t\tconst prevCameraTransforms = new Map();\n\t\ttiles.cameras.forEach( camera => {\n\n\t\t\tprevCameraTransforms.set( camera, new Matrix4() );\n\n\t\t} );\n\n\t\ttiles.forEachLoadedModel( ( scene, tile ) => {\n\n\t\t\tthis._onLoadModel( { scene } );\n\n\t\t} );\n\n\t\tthis.tiles = tiles;\n\t\tthis._fadeManager = fadeManager;\n\t\tthis._prevCameraTransforms = prevCameraTransforms;\n\n\t}\n\n\t// initializes the batched mesh if it needs to be, dispose if it it's no longer needed\n\tinitBatchedMesh() {\n\n\t\tconst otherBatchedMesh = this.tiles.getPluginByName( 'BATCHED_TILES_PLUGIN' )?.batchedMesh;\n\t\tif ( otherBatchedMesh ) {\n\n\t\t\tif ( this.batchedMesh === null ) {\n\n\t\t\t\tthis._onBatchedMeshDispose = () => {\n\n\t\t\t\t\tthis.batchedMesh.dispose();\n\t\t\t\t\tthis.batchedMesh.removeFromParent();\n\t\t\t\t\tthis.batchedMesh = null;\n\t\t\t\t\totherBatchedMesh.removeEventListener( 'dispose', this._onBatchedMeshDispose );\n\n\t\t\t\t};\n\n\t\t\t\tconst material = otherBatchedMesh.material.clone();\n\t\t\t\tmaterial.onBeforeCompile = otherBatchedMesh.material.onBeforeCompile;\n\n\t\t\t\tthis.batchedMesh = new FadeBatchedMesh( otherBatchedMesh, material );\n\t\t\t\tthis.tiles.group.add( this.batchedMesh );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this.batchedMesh !== null ) {\n\n\t\t\t\tthis._onBatchedMeshDispose();\n\t\t\t\tthis._onBatchedMeshDispose = null;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// callback for fading to prevent tiles from being removed until the fade effect has completed\n\tsetTileVisible( tile, visible ) {\n\n\t\tconst fadeManager = this._fadeManager;\n\n\t\t// track the fade state\n\t\tconst wasFading = fadeManager.isFading( tile );\n\t\tif ( fadeManager.isFadingOut( tile ) ) {\n\n\t\t\tthis._fadingOutCount --;\n\n\t\t}\n\n\t\t// trigger any necessary fades\n\t\tif ( ! visible ) {\n\n\t\t\tthis._fadingOutCount ++;\n\t\t\tfadeManager.fadeOut( tile );\n\n\t\t} else {\n\n\t\t\t// if this is a root renderable tile and this is the first time rendering in\n\t\t\t// then pop it in\n\t\t\tconst isRootRenderableTile = tile.internal.depthFromRenderedParent === 1;\n\t\t\tif ( isRootRenderableTile ) {\n\n\t\t\t\tif ( tile[ HAS_POPPED_IN ] || this.fadeRootTiles ) {\n\n\t\t\t\t\tthis._fadeManager.fadeIn( tile );\n\n\t\t\t\t}\n\n\t\t\t\ttile[ HAS_POPPED_IN ] = true;\n\n\t\t\t} else {\n\n\t\t\t\tthis._fadeManager.fadeIn( tile );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// if a tile needs to be jumped in then complete the fade here\n\t\tif ( this._quickFadeTiles.has( tile ) ) {\n\n\t\t\tthis._fadeManager.completeFade( tile );\n\t\t\tthis._quickFadeTiles.delete( tile );\n\n\t\t}\n\n\t\t// if a tile was already fading then it's already marked as visible and in the scene\n\t\tif ( wasFading ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t// cancel the visibility change trigger because we're fading and will call this after\n\t\t// fade completes.\n\t\tconst isFading = this._fadeManager.isFading( tile );\n\t\tif ( ! visible && isFading ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tdispose() {\n\n\t\tconst tiles = this.tiles;\n\n\t\tthis._fadeManager.completeAllFades();\n\n\t\tif ( this.batchedMesh !== null ) {\n\n\t\t\tthis._onBatchedMeshDispose();\n\n\t\t}\n\n\t\ttiles.removeEventListener( 'load-model', this._onLoadModel );\n\t\ttiles.removeEventListener( 'dispose-model', this._onDisposeModel );\n\t\ttiles.removeEventListener( 'add-camera', this._onAddCamera );\n\t\ttiles.removeEventListener( 'delete-camera', this._onDeleteCamera );\n\t\ttiles.removeEventListener( 'update-before', this._onUpdateBefore );\n\t\ttiles.removeEventListener( 'update-after', this._onUpdateAfter );\n\t\ttiles.removeEventListener( 'tile-visibility-change', this._onTileVisibilityChange );\n\t\ttiles.forEachLoadedModel( ( scene, tile ) => {\n\n\t\t\tthis._fadeManager.deleteObject( tile );\n\t\t\tif ( scene ) {\n\n\t\t\t\tscene.visible = true; // TODO\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t// helper for iterating over the batch ids for a given tile\n\tforEachBatchIds( tile, cb ) {\n\n\t\tthis.initBatchedMesh();\n\n\t\tif ( this.batchedMesh ) {\n\n\t\t\tconst batchedPlugin = this.tiles.getPluginByName( 'BATCHED_TILES_PLUGIN' );\n\t\t\tconst instanceIds = batchedPlugin.getTileBatchIds( tile );\n\t\t\tif ( instanceIds ) {\n\n\t\t\t\tinstanceIds.forEach( id => {\n\n\t\t\t\t\tcb( id, this.batchedMesh, batchedPlugin );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n"],"names":["clamp","MathUtils","FadeManager","object","fadeState","state","visible","value","key","cb","info","noState","time","delta","fadeOutTarget","fadeInTarget","fadeOut","fadeIn","fadeInSign","fadeOutSign","FADE_PARAMS","wrapFadeMaterial","material","previousOnBeforeCompile","params","shader","FadeMaterialManager","scene","fadeParams","child","PassThroughBatchedMesh","other","MeshBasicMaterial","proxyTarget","target","args","instanceInfo","otherInstanceInfo","index","FadeBatchedMesh","size","length","oldFadeTexture","fadeArray","fadeTexture","InstanceDataTexture","RGFormat","UnsignedByteType","src","dst","len","DataTexture","instance","values","data","width","height","itemSize","needsUpdate","i","prevValue","newValue","HAS_POPPED_IN","_fromPos","Vector3","_toPos","_fromQuat","Quaternion","_toQuat","_scale","onUpdateBefore","fadeManager","tiles","onUpdateAfter","fadeMaterialManager","displayActiveTiles","fadingBefore","prevCameraTransforms","maximumFadeOutTiles","batchedMesh","cameras","fadingAfter","t","id","plugin","isMovingFast","camera","currMatrix","prevMatrix","angleTo","positionTo","tile","isFadingOut","TilesFadePlugin","options","Matrix4","otherBatchedMesh","_a","wasFading","isFading","batchedPlugin","instanceIds"],"mappings":"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"}