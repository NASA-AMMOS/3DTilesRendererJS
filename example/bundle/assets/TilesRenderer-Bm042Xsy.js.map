{"version":3,"file":"TilesRenderer-Bm042Xsy.js","sources":["../../../src/three/renderer/tiles/TilesGroup.js","../../../src/three/renderer/tiles/raycastTraverse.js","../../../src/three/renderer/math/OBB.js","../../../src/three/renderer/math/TileBoundingVolume.js","../../../src/three/renderer/math/ExtendedFrustum.js","../../../src/three/renderer/utils/MemoryUtils.js","../../../src/three/renderer/tiles/TilesRenderer.js"],"sourcesContent":["import { Group, Matrix4 } from 'three';\n\n// Specialization of \"Group\" that only updates world matrices of children if\n// the transform has changed since the last update and ignores the \"force\"\n// parameter under the assumption that the children tiles will not move.\nconst tempMat = /* @__PURE__ */ new Matrix4();\nexport class TilesGroup extends Group {\n\n\tconstructor( tilesRenderer ) {\n\n\t\tsuper();\n\t\tthis.isTilesGroup = true;\n\t\tthis.name = 'TilesRenderer.TilesGroup';\n\t\tthis.tilesRenderer = tilesRenderer;\n\t\tthis.matrixWorldInverse = new Matrix4();\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\t// returning \"false\" ends raycast traversal\n\t\tif ( this.tilesRenderer.optimizeRaycast ) {\n\n\t\t\tthis.tilesRenderer.raycast( raycaster, intersects );\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tif ( this.matrixAutoUpdate ) {\n\n\t\t\tthis.updateMatrix();\n\n\t\t}\n\n\t\tif ( this.matrixWorldNeedsUpdate || force ) {\n\n\t\t\tif ( this.parent === null ) {\n\n\t\t\t\ttempMat.copy( this.matrix );\n\n\t\t\t} else {\n\n\t\t\t\ttempMat.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t}\n\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\t// check if the matrix changed relative to what it was.\n\t\t\tconst elA = tempMat.elements;\n\t\t\tconst elB = this.matrixWorld.elements;\n\t\t\tlet isDifferent = false;\n\t\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\t\tconst itemA = elA[ i ];\n\t\t\t\tconst itemB = elB[ i ];\n\t\t\t\tconst diff = Math.abs( itemA - itemB );\n\n\t\t\t\tif ( diff > Number.EPSILON ) {\n\n\t\t\t\t\tisDifferent = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( isDifferent ) {\n\n\t\t\t\tthis.matrixWorld.copy( tempMat );\n\t\t\t\tthis.matrixWorldInverse.copy( tempMat ).invert();\n\n\t\t\t\t// update children\n\t\t\t\t// the children will not have to change unless the parent group has updated\n\t\t\t\tconst children = this.children;\n\t\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\t\tchildren[ i ].updateMatrixWorld();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdateWorldMatrix( updateParents, updateChildren ) {\n\n\t\tif ( this.parent && updateParents ) {\n\n\t\t\tthis.parent.updateWorldMatrix( updateParents, false );\n\n\t\t}\n\n\t\t// run the normal update function to ensure children and inverse matrices are in sync\n\t\tthis.updateMatrixWorld( true );\n\n\t}\n\n}\n","import { Ray, Vector3 } from 'three';\n\n// In three.js r165 and higher raycast traversal can be ended early\nconst _localRay = /* @__PURE__ */ new Ray();\nconst _vec = /* @__PURE__ */ new Vector3();\nconst _hitArray = [];\n\nfunction distanceSort( a, b ) {\n\n\treturn a.distance - b.distance;\n\n}\n\nfunction intersectTileScene( tile, raycaster, renderer, intersects ) {\n\n\tconst { scene } = tile.engineData;\n\tconst didRaycast = renderer.invokeOnePlugin( plugin => plugin.raycastTile && plugin.raycastTile( tile, scene, raycaster, intersects ) );\n\tif ( ! didRaycast ) {\n\n\t\traycaster.intersectObject( scene, true, intersects );\n\n\t}\n\n}\n\nfunction intersectTileSceneFirstHist( tile, raycaster, renderer ) {\n\n\tintersectTileScene( tile, raycaster, renderer, _hitArray );\n\t_hitArray.sort( distanceSort );\n\n\tconst hit = _hitArray[ 0 ] || null;\n\t_hitArray.length = 0;\n\treturn hit;\n\n}\n\nfunction isTileInitialized( tile ) {\n\n\treturn 'traversal' in tile;\n\n}\n\n// Returns the closest hit when traversing the tree\nexport function raycastTraverseFirstHit( renderer, tile, raycaster, localRay = null ) {\n\n\tconst { group, activeTiles } = renderer;\n\n\t// get the ray in the local group frame\n\tif ( localRay === null ) {\n\n\t\tlocalRay = _localRay;\n\t\tlocalRay.copy( raycaster.ray ).applyMatrix4( group.matrixWorldInverse );\n\n\t}\n\n\t// get a set of intersections so we intersect the nearest one first\n\tconst array = [];\n\tconst children = tile.children;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\tconst child = children[ i ];\n\t\tif ( ! isTileInitialized( child ) || ! child.traversal.used ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\t// track the tile and hit distance for sorting\n\t\tconst boundingVolume = child.engineData.boundingVolume;\n\t\tif ( boundingVolume.intersectRay( localRay, _vec ) !== null ) {\n\n\t\t\t_vec.applyMatrix4( group.matrixWorld );\n\t\t\tarray.push( {\n\t\t\t\tdistance: _vec.distanceToSquared( raycaster.ray.origin ),\n\t\t\t\ttile: child,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t// sort them by ascending distance\n\tarray.sort( distanceSort );\n\n\t// If the root is active make sure we've checked it\n\tlet bestHit = null;\n\tlet bestHitDistSq = Infinity;\n\tif ( activeTiles.has( tile ) ) {\n\n\t\tconst hit = intersectTileSceneFirstHist( tile, raycaster, renderer );\n\t\tif ( hit ) {\n\n\t\t\tbestHit = hit;\n\t\t\tbestHitDistSq = hit.distance * hit.distance;\n\n\t\t}\n\n\t}\n\n\t// traverse until we find the best hit and early out if a tile bounds\n\t// couldn't possible include a best hit\n\tfor ( let i = 0, l = array.length; i < l; i ++ ) {\n\n\t\tconst data = array[ i ];\n\t\tconst boundingVolumeDistSq = data.distance;\n\t\tconst tile = data.tile;\n\t\tif ( boundingVolumeDistSq > bestHitDistSq ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t\tconst hit = raycastTraverseFirstHit( renderer, tile, raycaster, localRay );\n\t\tif ( hit ) {\n\n\t\t\tconst hitDistSq = hit.distance * hit.distance;\n\t\t\tif ( hitDistSq < bestHitDistSq ) {\n\n\t\t\t\tbestHit = hit;\n\t\t\t\tbestHitDistSq = hitDistSq;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn bestHit;\n\n}\n\nexport function raycastTraverse( renderer, tile, raycaster, intersects, localRay = null ) {\n\n\t// if the tile has not been asynchronously initialized then there's no point in\n\t// traversing the tiles to check intersections.\n\tif ( ! isTileInitialized( tile ) ) {\n\n\t\treturn;\n\n\t}\n\n\tconst { group, activeTiles } = renderer;\n\tconst { boundingVolume } = tile.engineData;\n\n\t// get the ray in the local group frame\n\tif ( localRay === null ) {\n\n\t\tlocalRay = _localRay;\n\t\tlocalRay.copy( raycaster.ray ).applyMatrix4( group.matrixWorldInverse );\n\n\t}\n\n\t// exit early if the tile isn't used or the bounding volume is not intersected\n\tif ( ! tile.traversal.used || ! boundingVolume.intersectsRay( localRay ) ) {\n\n\t\treturn;\n\n\t}\n\n\t// only intersect the tile geometry if it's active\n\tif ( activeTiles.has( tile ) ) {\n\n\t\tintersectTileScene( tile, raycaster, renderer, intersects );\n\n\t}\n\n\tconst children = tile.children;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\traycastTraverse( renderer, children[ i ], raycaster, intersects, localRay );\n\n\t}\n\n}\n","import { Matrix4, Box3, Vector3, Plane, Ray } from 'three';\n\nconst _worldMin = /* @__PURE__ */ new Vector3();\nconst _worldMax = /* @__PURE__ */ new Vector3();\nconst _norm = /* @__PURE__ */ new Vector3();\nconst _ray = /* @__PURE__ */ new Ray();\n\nexport class OBB {\n\n\tconstructor( box = new Box3(), transform = new Matrix4() ) {\n\n\t\tthis.box = box.clone();\n\t\tthis.transform = transform.clone();\n\t\tthis.inverseTransform = new Matrix4();\n\t\tthis.points = new Array( 8 ).fill().map( () => new Vector3() );\n\t\tthis.planes = new Array( 6 ).fill().map( () => new Plane() );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.box.copy( source.box );\n\t\tthis.transform.copy( source.transform );\n\t\tthis.update();\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\t/**\n\t * Clamps the given point within the bounds of this OBB\n\t * @param {Vector3} point\n\t * @param {Vector3} result\n\t * @returns {Vector3}\n\t */\n\tclampPoint( point, result ) {\n\n\t\treturn result.copy( point )\n\t\t\t.applyMatrix4( this.inverseTransform )\n\t\t\t.clamp( this.box.min, this.box.max )\n\t\t\t.applyMatrix4( this.transform );\n\n\t}\n\n\t/**\n\t * Returns the distance from any edge of this OBB to the specified point.\n\t * If the point lies inside of this box, the distance will be 0.\n\t * @param {Vector3} point\n\t * @returns {number}\n\t */\n\tdistanceToPoint( point ) {\n\n\t\treturn this.clampPoint( point, _norm ).distanceTo( point );\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\t_norm.copy( point ).applyMatrix4( this.inverseTransform );\n\t\treturn this.box.containsPoint( _norm );\n\n\t}\n\n\t// returns boolean indicating whether the ray has intersected the obb\n\tintersectsRay( ray ) {\n\n\t\t_ray.copy( ray ).applyMatrix4( this.inverseTransform );\n\t\treturn _ray.intersectsBox( this.box );\n\n\t}\n\n\t// Sets \"target\" equal to the intersection point.\n\t// Returns \"null\" if no intersection found.\n\tintersectRay( ray, target ) {\n\n\t\t_ray.copy( ray ).applyMatrix4( this.inverseTransform );\n\t\tif ( _ray.intersectBox( this.box, target ) ) {\n\n\t\t\ttarget.applyMatrix4( this.transform );\n\t\t\treturn target;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\tconst { points, inverseTransform, transform, box } = this;\n\t\tinverseTransform.copy( transform ).invert();\n\n\t\tconst { min, max } = box;\n\t\tlet index = 0;\n\t\tfor ( let x = - 1; x <= 1; x += 2 ) {\n\n\t\t\tfor ( let y = - 1; y <= 1; y += 2 ) {\n\n\t\t\t\tfor ( let z = - 1; z <= 1; z += 2 ) {\n\n\t\t\t\t\tpoints[ index ].set(\n\t\t\t\t\t\tx < 0 ? min.x : max.x,\n\t\t\t\t\t\ty < 0 ? min.y : max.y,\n\t\t\t\t\t\tz < 0 ? min.z : max.z,\n\t\t\t\t\t).applyMatrix4( transform );\n\t\t\t\t\tindex ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.updatePlanes();\n\n\t}\n\n\tupdatePlanes() {\n\n\t\t_worldMin.copy( this.box.min ).applyMatrix4( this.transform );\n\t\t_worldMax.copy( this.box.max ).applyMatrix4( this.transform );\n\n\t\t_norm.set( 0, 0, 1 ).transformDirection( this.transform );\n\t\tthis.planes[ 0 ].setFromNormalAndCoplanarPoint( _norm, _worldMin );\n\t\tthis.planes[ 1 ].setFromNormalAndCoplanarPoint( _norm, _worldMax ).negate();\n\n\t\t_norm.set( 0, 1, 0 ).transformDirection( this.transform );\n\t\tthis.planes[ 2 ].setFromNormalAndCoplanarPoint( _norm, _worldMin );\n\t\tthis.planes[ 3 ].setFromNormalAndCoplanarPoint( _norm, _worldMax ).negate();\n\n\t\t_norm.set( 1, 0, 0 ).transformDirection( this.transform );\n\t\tthis.planes[ 4 ].setFromNormalAndCoplanarPoint( _norm, _worldMin );\n\t\tthis.planes[ 5 ].setFromNormalAndCoplanarPoint( _norm, _worldMax ).negate();\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\tthis.clampPoint( sphere.center, _norm );\n\t\treturn _norm.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t}\n\n\tintersectsFrustum( frustum ) {\n\n\t\treturn this._intersectsPlaneShape( frustum.planes, frustum.points );\n\n\t}\n\n\tintersectsOBB( obb ) {\n\n\t\treturn this._intersectsPlaneShape( obb.planes, obb.points );\n\n\t}\n\n\t// takes a series of 6 planes that define and enclosed shape and the 8 points that lie at the corners\n\t// of that shape to determine whether the OBB is intersected with.\n\t_intersectsPlaneShape( otherPlanes, otherPoints ) {\n\n\t\tconst thisPoints = this.points;\n\t\tconst thisPlanes = this.planes;\n\n\t\t// based on three.js' Box3 \"intersects frustum\" function\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst plane = otherPlanes[ i ];\n\t\t\tlet maxDistance = - Infinity;\n\t\t\tfor ( let j = 0; j < 8; j ++ ) {\n\n\t\t\t\tconst v = thisPoints[ j ];\n\t\t\t\tconst dist = plane.distanceToPoint( v );\n\t\t\t\tmaxDistance = maxDistance < dist ? dist : maxDistance;\n\n\t\t\t}\n\n\t\t\tif ( maxDistance < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// do the opposite check using the obb planes to avoid false positives\n\t\t// this check is not performed by three.js' AABB logic but helps prevent a lot incorrect intersection reports\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst plane = thisPlanes[ i ];\n\t\t\tlet maxDistance = - Infinity;\n\t\t\tfor ( let j = 0; j < 8; j ++ ) {\n\n\t\t\t\tconst v = otherPoints[ j ];\n\t\t\t\tconst dist = plane.distanceToPoint( v );\n\t\t\t\tmaxDistance = maxDistance < dist ? dist : maxDistance;\n\n\t\t\t}\n\n\t\t\tif ( maxDistance < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n}\n","import { Vector3, Sphere } from 'three';\nimport { OBB } from './OBB.js';\nimport { EllipsoidRegion } from './EllipsoidRegion.js';\n\nconst _vecX = /* @__PURE__ */ new Vector3();\nconst _vecY = /* @__PURE__ */ new Vector3();\nconst _vecZ = /* @__PURE__ */ new Vector3();\nconst _sphereVec = /* @__PURE__ */ new Vector3();\nconst _obbVec = /* @__PURE__ */ new Vector3();\n\n// TODO: check region more precisely in all functions\nexport class TileBoundingVolume {\n\n\tconstructor() {\n\n\t\tthis.sphere = null;\n\t\tthis.obb = null;\n\t\tthis.region = null;\n\n\t\tthis.regionObb = null;\n\n\t}\n\n\tintersectsRay( ray ) {\n\n\t\tconst sphere = this.sphere;\n\t\tconst obb = this.obb || this.regionObb;\n\n\t\t// Early out if we don't hit this tile sphere\n\t\tif ( sphere && ! ray.intersectsSphere( sphere ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// Early out if we don't this this tile box\n\t\tif ( obb && ! obb.intersectsRay( ray ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tintersectRay( ray, target = null ) {\n\n\t\tconst sphere = this.sphere;\n\t\tconst obb = this.obb || this.regionObb;\n\n\t\tlet sphereDistSq = - Infinity;\n\t\tlet obbDistSq = - Infinity;\n\n\t\tif ( sphere ) {\n\n\t\t\tif ( ray.intersectSphere( sphere, _sphereVec ) ) {\n\n\t\t\t\tsphereDistSq = sphere.containsPoint( ray.origin ) ? 0 : ray.origin.distanceToSquared( _sphereVec );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( obb ) {\n\n\t\t\tif ( obb.intersectRay( ray, _obbVec ) ) {\n\n\t\t\t\tobbDistSq = obb.containsPoint( ray.origin ) ? 0 : ray.origin.distanceToSquared( _obbVec );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// if we didn't hit anything then exit\n\t\tconst furthestDist = Math.max( sphereDistSq, obbDistSq );\n\t\tif ( furthestDist === - Infinity ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// get the furthest hit point if needed\n\t\tray.at( Math.sqrt( furthestDist ), target );\n\t\treturn target;\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\tconst sphere = this.sphere;\n\t\tconst obb = this.obb || this.regionObb;\n\n\t\tlet sphereDistance = - Infinity;\n\t\tlet obbDistance = - Infinity;\n\n\t\tif ( sphere ) {\n\n\t\t\t// Sphere#distanceToPoint is negative inside the sphere, whereas Box3#distanceToPoint is\n\t\t\t// zero inside the box. Clipping the distance to a minimum of zero ensures that both\n\t\t\t// types of bounding volume behave the same way.\n\t\t\tsphereDistance = Math.max( sphere.distanceToPoint( point ), 0 );\n\n\t\t}\n\n\t\tif ( obb ) {\n\n\t\t\tobbDistance = obb.distanceToPoint( point );\n\n\t\t}\n\n\t\t// return the further distance of the two volumes\n\t\treturn sphereDistance > obbDistance ? sphereDistance : obbDistance;\n\n\t}\n\n\tintersectsFrustum( frustum ) {\n\n\t\tconst obb = this.obb || this.regionObb;\n\t\tconst sphere = this.sphere;\n\t\tif ( sphere && ! frustum.intersectsSphere( sphere ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( obb && ! obb.intersectsFrustum( frustum ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// if we don't have a sphere or obb then just say we did intersect\n\t\treturn Boolean( sphere || obb );\n\n\t}\n\n\tintersectsSphere( otherSphere ) {\n\n\t\tconst obb = this.obb || this.regionObb;\n\t\tconst sphere = this.sphere;\n\t\tif ( sphere && ! sphere.intersectsSphere( otherSphere ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( obb && ! obb.intersectsSphere( otherSphere ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn Boolean( sphere || obb );\n\n\t}\n\n\tintersectsOBB( otherObb ) {\n\n\t\tconst obb = this.obb || this.regionObb;\n\t\tconst sphere = this.sphere;\n\t\tif ( sphere && ! otherObb.intersectsSphere( sphere ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( obb && ! obb.intersectsOBB( otherObb ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn Boolean( sphere || obb );\n\n\t}\n\n\tgetOBB( targetBox, targetMatrix ) {\n\n\t\tconst obb = this.obb || this.regionObb;\n\t\tif ( obb ) {\n\n\t\t\ttargetBox.copy( obb.box );\n\t\t\ttargetMatrix.copy( obb.transform );\n\n\t\t} else {\n\n\t\t\tthis.getAABB( targetBox );\n\t\t\ttargetMatrix.identity();\n\n\t\t}\n\n\t}\n\n\tgetAABB( target ) {\n\n\t\tif ( this.sphere ) {\n\n\t\t\tthis.sphere.getBoundingBox( target );\n\n\t\t} else {\n\n\t\t\tconst obb = this.obb || this.regionObb;\n\t\t\ttarget.copy( obb.box ).applyMatrix4( obb.transform );\n\n\t\t}\n\n\t}\n\n\tgetSphere( target ) {\n\n\t\tif ( this.sphere ) {\n\n\t\t\ttarget.copy( this.sphere );\n\n\t\t} else if ( this.region ) {\n\n\t\t\tthis.region.getBoundingSphere( target );\n\n\t\t} else {\n\n\t\t\tconst obb = this.obb || this.regionObb;\n\t\t\tobb.box.getBoundingSphere( target );\n\t\t\ttarget.applyMatrix4( obb.transform );\n\n\t\t}\n\n\t}\n\n\tsetObbData( data, transform ) {\n\n\t\tconst obb = new OBB();\n\n\t\t// get the extents of the bounds in each axis\n\t\t_vecX.set( data[ 3 ], data[ 4 ], data[ 5 ] );\n\t\t_vecY.set( data[ 6 ], data[ 7 ], data[ 8 ] );\n\t\t_vecZ.set( data[ 9 ], data[ 10 ], data[ 11 ] );\n\n\t\tconst scaleX = _vecX.length();\n\t\tconst scaleY = _vecY.length();\n\t\tconst scaleZ = _vecZ.length();\n\n\t\t_vecX.normalize();\n\t\t_vecY.normalize();\n\t\t_vecZ.normalize();\n\n\t\t// handle the case where the box has a dimension of 0 in one axis\n\t\tif ( scaleX === 0 ) {\n\n\t\t\t_vecX.crossVectors( _vecY, _vecZ );\n\n\t\t}\n\n\t\tif ( scaleY === 0 ) {\n\n\t\t\t_vecY.crossVectors( _vecX, _vecZ );\n\n\t\t}\n\n\t\tif ( scaleZ === 0 ) {\n\n\t\t\t_vecZ.crossVectors( _vecX, _vecY );\n\n\t\t}\n\n\t\t// create the oriented frame that the box exists in\n\t\tobb.transform\n\t\t\t.set(\n\t\t\t\t_vecX.x, _vecY.x, _vecZ.x, data[ 0 ],\n\t\t\t\t_vecX.y, _vecY.y, _vecZ.y, data[ 1 ],\n\t\t\t\t_vecX.z, _vecY.z, _vecZ.z, data[ 2 ],\n\t\t\t\t0, 0, 0, 1\n\t\t\t)\n\t\t\t.premultiply( transform );\n\n\t\t// scale the box by the extents\n\t\tobb.box.min.set( - scaleX, - scaleY, - scaleZ );\n\t\tobb.box.max.set( scaleX, scaleY, scaleZ );\n\t\tobb.update();\n\t\tthis.obb = obb;\n\n\t}\n\n\tsetSphereData( x, y, z, radius, transform ) {\n\n\t\tconst sphere = new Sphere();\n\t\tsphere.center.set( x, y, z );\n\t\tsphere.radius = radius;\n\t\tsphere.applyMatrix4( transform );\n\t\tthis.sphere = sphere;\n\n\t}\n\n\tsetRegionData( ellipsoid, west, south, east, north, minHeight, maxHeight ) {\n\n\t\tconst region = new EllipsoidRegion(\n\t\t\t...ellipsoid.radius,\n\t\t\tsouth, north,\n\t\t\twest, east,\n\t\t\tminHeight, maxHeight,\n\t\t);\n\n\t\tconst obb = new OBB();\n\t\tregion.getBoundingBox( obb.box, obb.transform );\n\t\tobb.update();\n\n\t\tthis.region = region;\n\t\tthis.regionObb = obb;\n\n\t}\n\n}\n","import { Frustum, Matrix3, Vector3 } from 'three';\n\nconst _mat3 = /* @__PURE__ */ new Matrix3();\n\n// Solve a system of equations to find the point where the three planes intersect\nfunction findIntersectionPoint( plane1, plane2, plane3, target ) {\n\n\t// Create the matrix A using the normals of the planes as rows\n\tconst A = _mat3.set(\n\t\tplane1.normal.x, plane1.normal.y, plane1.normal.z,\n\t\tplane2.normal.x, plane2.normal.y, plane2.normal.z,\n\t\tplane3.normal.x, plane3.normal.y, plane3.normal.z\n\t);\n\n\t// Create the vector B using the constants of the planes\n\ttarget.set( - plane1.constant, - plane2.constant, - plane3.constant );\n\n\t// Solve for X by applying the inverse matrix to B\n\ttarget.applyMatrix3( A.invert() );\n\n\treturn target;\n\n}\n\nclass ExtendedFrustum extends Frustum {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis.points = Array( 8 ).fill().map( () => new Vector3() );\n\n\t}\n\n\tsetFromProjectionMatrix( m, coordinateSystem ) {\n\n\t\tsuper.setFromProjectionMatrix( m, coordinateSystem );\n\t\tthis.calculateFrustumPoints();\n\t\treturn this;\n\n\t}\n\n\tcalculateFrustumPoints() {\n\n\t\tconst { planes, points } = this;\n\t\tconst planeIntersections = [\n\t\t\t[ planes[ 0 ], planes[ 3 ], planes[ 4 ] ], // Near top left\n\t\t\t[ planes[ 1 ], planes[ 3 ], planes[ 4 ] ], // Near top right\n\t\t\t[ planes[ 0 ], planes[ 2 ], planes[ 4 ] ], // Near bottom left\n\t\t\t[ planes[ 1 ], planes[ 2 ], planes[ 4 ] ], // Near bottom right\n\t\t\t[ planes[ 0 ], planes[ 3 ], planes[ 5 ] ], // Far top left\n\t\t\t[ planes[ 1 ], planes[ 3 ], planes[ 5 ] ], // Far top right\n\t\t\t[ planes[ 0 ], planes[ 2 ], planes[ 5 ] ], // Far bottom left\n\t\t\t[ planes[ 1 ], planes[ 2 ], planes[ 5 ] ], // Far bottom right\n\t\t];\n\n\t\tplaneIntersections.forEach( ( planes, index ) => {\n\n\t\t\tfindIntersectionPoint( planes[ 0 ], planes[ 1 ], planes[ 2 ], points[ index ] );\n\n\t\t} );\n\n\t}\n\n}\n\nexport { ExtendedFrustum };\n","import { estimateBytesUsed as _estimateBytesUsed } from 'three/examples/jsm/utils/BufferGeometryUtils.js';\nimport { TextureUtils } from 'three';\n\nexport function getTextureByteLength( tex ) {\n\n\tif ( ! tex ) {\n\n\t\treturn 0;\n\n\t}\n\n\tconst { format, type, image } = tex;\n\tconst { width, height } = image;\n\n\tlet bytes = TextureUtils.getByteLength( width, height, format, type );\n\tbytes *= tex.generateMipmaps ? 4 / 3 : 1;\n\n\treturn bytes;\n\n}\n\n// Returns the estimated number of bytes used by the object\nexport function estimateBytesUsed( object ) {\n\n\tconst dedupeSet = new Set();\n\n\tlet totalBytes = 0;\n\tobject.traverse( c => {\n\n\t\t// get geometry bytes\n\t\tif ( c.geometry && ! dedupeSet.has( c.geometry ) ) {\n\n\t\t\ttotalBytes += _estimateBytesUsed( c.geometry );\n\t\t\tdedupeSet.add( c.geometry );\n\n\t\t}\n\n\t\t// get material bytes\n\t\tif ( c.material ) {\n\n\t\t\tconst material = c.material;\n\t\t\tfor ( const key in material ) {\n\n\t\t\t\tconst value = material[ key ];\n\t\t\t\tif ( value && value.isTexture && ! dedupeSet.has( value ) ) {\n\n\t\t\t\t\ttotalBytes += getTextureByteLength( value );\n\t\t\t\t\tdedupeSet.add( value );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\treturn totalBytes;\n\n}\n","import { TilesRendererBase, LoaderUtils } from '3d-tiles-renderer/core';\nimport { B3DMLoader } from '../loaders/B3DMLoader.js';\nimport { PNTSLoader } from '../loaders/PNTSLoader.js';\nimport { I3DMLoader } from '../loaders/I3DMLoader.js';\nimport { CMPTLoader } from '../loaders/CMPTLoader.js';\nimport { TilesGroup } from './TilesGroup.js';\nimport {\n\tMatrix4,\n\tVector3,\n\tVector2,\n\tEuler,\n\tLoadingManager,\n\tEventDispatcher,\n\tGroup,\n} from 'three';\nimport { raycastTraverse, raycastTraverseFirstHit } from './raycastTraverse.js';\nimport { TileBoundingVolume } from '../math/TileBoundingVolume.js';\nimport { ExtendedFrustum } from '../math/ExtendedFrustum.js';\nimport { estimateBytesUsed } from '../utils/MemoryUtils.js';\nimport { WGS84_ELLIPSOID } from '../math/GeoConstants.js';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\n\nconst _mat = /* @__PURE__ */ new Matrix4();\nconst _euler = /* @__PURE__ */ new Euler();\n\n// In three.js r165 and higher raycast traversal can be ended early\nconst INITIAL_FRUSTUM_CULLED = Symbol( 'INITIAL_FRUSTUM_CULLED' );\nconst tempMat = /* @__PURE__ */ new Matrix4();\nconst tempVector = /* @__PURE__ */ new Vector3();\nconst tempVector2 = /* @__PURE__ */ new Vector2();\n\nconst X_AXIS = /* @__PURE__ */ new Vector3( 1, 0, 0 );\nconst Y_AXIS = /* @__PURE__ */ new Vector3( 0, 1, 0 );\n\nfunction updateFrustumCulled( object, toInitialValue ) {\n\n\tobject.traverse( c => {\n\n\t\tc.frustumCulled = c[ INITIAL_FRUSTUM_CULLED ] && toInitialValue;\n\n\t} );\n\n}\n\nexport class TilesRenderer extends TilesRendererBase {\n\n\tget autoDisableRendererCulling() {\n\n\t\treturn this._autoDisableRendererCulling;\n\n\t}\n\n\tset autoDisableRendererCulling( value ) {\n\n\t\tif ( this._autoDisableRendererCulling !== value ) {\n\n\t\t\tsuper._autoDisableRendererCulling = value;\n\t\t\tthis.forEachLoadedModel( ( scene ) => {\n\n\t\t\t\tupdateFrustumCulled( scene, ! value );\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\tget optimizeRaycast() {\n\n\t\treturn this._optimizeRaycast;\n\n\t}\n\n\tset optimizeRaycast( v ) {\n\n\t\tconsole.warn( 'TilesRenderer: The \"optimizeRaycast\" option has been deprecated.' );\n\t\tthis._optimizeRaycast = v;\n\n\t}\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\t\tthis.group = new TilesGroup( this );\n\t\tthis.ellipsoid = WGS84_ELLIPSOID.clone();\n\t\tthis.cameras = [];\n\t\tthis.cameraMap = new Map();\n\t\tthis.cameraInfo = [];\n\t\tthis._optimizeRaycast = true;\n\t\tthis._upRotationMatrix = new Matrix4();\n\t\tthis._bytesUsed = new WeakMap();\n\n\t\t// flag indicating whether frustum culling should be disabled\n\t\tthis._autoDisableRendererCulling = true;\n\n\t\tthis.manager = new LoadingManager();\n\n\t\t// saved for event dispatcher functions\n\t\tthis._listeners = {};\n\n\t}\n\n\taddEventListener( type, listener ) {\n\n\t\tif ( type === 'load-tile-set' ) {\n\n\t\t\tconsole.warn( 'TilesRenderer: \"load-tile-set\" event has been deprecated. Use \"load-tileset\" instead.' );\n\t\t\ttype = 'load-tileset';\n\n\t\t}\n\n\t\tEventDispatcher.prototype.addEventListener.call( this, type, listener );\n\n\t}\n\n\thasEventListener( type, listener ) {\n\n\t\tif ( type === 'load-tile-set' ) {\n\n\t\t\tconsole.warn( 'TilesRenderer: \"load-tile-set\" event has been deprecated. Use \"load-tileset\" instead.' );\n\t\t\ttype = 'load-tileset';\n\n\t\t}\n\n\t\treturn EventDispatcher.prototype.hasEventListener.call( this, type, listener );\n\n\t}\n\n\tremoveEventListener( type, listener ) {\n\n\t\tif ( type === 'load-tile-set' ) {\n\n\t\t\tconsole.warn( 'TilesRenderer: \"load-tile-set\" event has been deprecated. Use \"load-tileset\" instead.' );\n\t\t\ttype = 'load-tileset';\n\n\t\t}\n\n\t\tEventDispatcher.prototype.removeEventListener.call( this, type, listener );\n\n\t}\n\n\tdispatchEvent( e ) {\n\n\t\tif ( 'tileset' in e ) {\n\n\t\t\tObject.defineProperty( e, 'tileSet', {\n\t\t\t\tget() {\n\n\t\t\t\t\tconsole.warn( 'TilesRenderer: \"event.tileSet\" has been deprecated. Use \"event.tileset\" instead.' );\n\t\t\t\t\treturn e.tileset;\n\n\t\t\t\t},\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: true,\n\t\t\t} );\n\n\t\t}\n\n\t\tEventDispatcher.prototype.dispatchEvent.call( this, e );\n\n\t}\n\n\t/* Public API */\n\tgetBoundingBox( target ) {\n\n\t\tif ( ! this.root ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst boundingVolume = this.root.engineData.boundingVolume;\n\t\tif ( boundingVolume ) {\n\n\t\t\tboundingVolume.getAABB( target );\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\tgetOrientedBoundingBox( targetBox, targetMatrix ) {\n\n\t\tif ( ! this.root ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst boundingVolume = this.root.engineData.boundingVolume;\n\t\tif ( boundingVolume ) {\n\n\t\t\tboundingVolume.getOBB( targetBox, targetMatrix );\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\tgetBoundingSphere( target ) {\n\n\t\tif ( ! this.root ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst boundingVolume = this.root.engineData.boundingVolume;\n\t\tif ( boundingVolume ) {\n\n\t\t\tboundingVolume.getSphere( target );\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\tforEachLoadedModel( callback ) {\n\n\t\tthis.traverse( tile => {\n\n\t\t\tconst scene = tile.engineData && tile.engineData.scene;\n\t\t\tif ( scene ) {\n\n\t\t\t\tcallback( scene, tile );\n\n\t\t\t}\n\n\t\t}, null, false );\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tif ( ! this.root ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( raycaster.firstHitOnly ) {\n\n\t\t\tconst hit = raycastTraverseFirstHit( this, this.root, raycaster );\n\t\t\tif ( hit ) {\n\n\t\t\t\tintersects.push( hit );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\traycastTraverse( this, this.root, raycaster, intersects );\n\n\t\t}\n\n\t}\n\n\thasCamera( camera ) {\n\n\t\treturn this.cameraMap.has( camera );\n\n\t}\n\n\tsetCamera( camera ) {\n\n\t\tconst cameras = this.cameras;\n\t\tconst cameraMap = this.cameraMap;\n\t\tif ( ! cameraMap.has( camera ) ) {\n\n\t\t\tcameraMap.set( camera, new Vector2() );\n\t\t\tcameras.push( camera );\n\t\t\tthis.dispatchEvent( { type: 'add-camera', camera } );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tsetResolution( camera, xOrVec, y ) {\n\n\t\tconst cameraMap = this.cameraMap;\n\t\tif ( ! cameraMap.has( camera ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst width = xOrVec.isVector2 ? xOrVec.x : xOrVec;\n\t\tconst height = xOrVec.isVector2 ? xOrVec.y : y;\n\t\tconst cameraVec = cameraMap.get( camera );\n\n\t\tif ( cameraVec.width !== width || cameraVec.height !== height ) {\n\n\t\t\tcameraVec.set( width, height );\n\t\t\tthis.dispatchEvent( { type: 'camera-resolution-change' } );\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tsetResolutionFromRenderer( camera, renderer ) {\n\n\t\trenderer.getSize( tempVector2 );\n\n\t\treturn this.setResolution( camera, tempVector2.x, tempVector2.y );\n\n\t}\n\n\tdeleteCamera( camera ) {\n\n\t\tconst cameras = this.cameras;\n\t\tconst cameraMap = this.cameraMap;\n\t\tif ( cameraMap.has( camera ) ) {\n\n\t\t\tconst index = cameras.indexOf( camera );\n\t\t\tcameras.splice( index, 1 );\n\t\t\tcameraMap.delete( camera );\n\t\t\tthis.dispatchEvent( { type: 'delete-camera', camera } );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/* Overriden */\n\tloadRootTileset( ...args ) {\n\n\t\treturn super.loadRootTileset( ...args )\n\t\t\t.then( root => {\n\n\t\t\t\t// cache the gltf tileset rotation matrix\n\t\t\t\tconst { asset, extensions = {} } = root;\n\t\t\t\tconst upAxis = asset && asset.gltfUpAxis || 'y';\n\t\t\t\tswitch ( upAxis.toLowerCase() ) {\n\n\t\t\t\t\tcase 'x':\n\t\t\t\t\t\tthis._upRotationMatrix.makeRotationAxis( Y_AXIS, - Math.PI / 2 );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'y':\n\t\t\t\t\t\tthis._upRotationMatrix.makeRotationAxis( X_AXIS, Math.PI / 2 );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// update the ellipsoid based on the extension\n\t\t\t\tif ( '3DTILES_ellipsoid' in extensions ) {\n\n\t\t\t\t\tconst ext = extensions[ '3DTILES_ellipsoid' ];\n\t\t\t\t\tconst { ellipsoid } = this;\n\t\t\t\t\tellipsoid.name = ext.body;\n\t\t\t\t\tif ( ext.radii ) {\n\n\t\t\t\t\t\tellipsoid.radius.set( ...ext.radii );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tellipsoid.radius.set( 1, 1, 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn root;\n\n\t\t\t} );\n\n\t}\n\n\tprepareForTraversal() {\n\n\t\tconst group = this.group;\n\t\tconst cameras = this.cameras;\n\t\tconst cameraMap = this.cameraMap;\n\t\tconst cameraInfo = this.cameraInfo;\n\n\t\t// automatically scale the array of cameraInfo to match the cameras\n\t\twhile ( cameraInfo.length > cameras.length ) {\n\n\t\t\tcameraInfo.pop();\n\n\t\t}\n\n\t\twhile ( cameraInfo.length < cameras.length ) {\n\n\t\t\tcameraInfo.push( {\n\n\t\t\t\tfrustum: new ExtendedFrustum(),\n\t\t\t\tisOrthographic: false,\n\t\t\t\tsseDenominator: - 1, // used if isOrthographic:false\n\t\t\t\tposition: new Vector3(),\n\t\t\t\tinvScale: - 1,\n\t\t\t\tpixelSize: 0, // used if isOrthographic:true\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// extract scale of group container\n\t\ttempVector.setFromMatrixScale( group.matrixWorldInverse );\n\t\tif ( Math.abs( Math.max( tempVector.x - tempVector.y, tempVector.x - tempVector.z ) ) > 1e-6 ) {\n\n\t\t\tconsole.warn( 'ThreeTilesRenderer : Non uniform scale used for tile which may cause issues when calculating screen space error.' );\n\n\t\t}\n\n\t\t// store the camera cameraInfo in the 3d tiles root frame\n\t\tfor ( let i = 0, l = cameraInfo.length; i < l; i ++ ) {\n\n\t\t\tconst camera = cameras[ i ];\n\t\t\tconst info = cameraInfo[ i ];\n\t\t\tconst frustum = info.frustum;\n\t\t\tconst position = info.position;\n\t\t\tconst resolution = cameraMap.get( camera );\n\n\t\t\tif ( resolution.width === 0 || resolution.height === 0 ) {\n\n\t\t\t\tconsole.warn( 'TilesRenderer: resolution for camera error calculation is not set.' );\n\n\t\t\t}\n\n\t\t\t// Read the calculated projection matrix directly to support custom Camera implementations\n\t\t\tconst projection = camera.projectionMatrix.elements;\n\n\t\t\t// The last element of the projection matrix is 1 for orthographic, 0 for perspective\n\t\t\tinfo.isOrthographic = projection[ 15 ] === 1;\n\n\t\t\tif ( info.isOrthographic ) {\n\n\t\t\t\t// See OrthographicCamera.updateProjectionMatrix and Matrix4.makeOrthographic:\n\t\t\t\t// the view width and height are used to populate matrix elements 0 and 5.\n\t\t\t\tconst w = 2 / projection[ 0 ];\n\t\t\t\tconst h = 2 / projection[ 5 ];\n\t\t\t\tinfo.pixelSize = Math.max( h / resolution.height, w / resolution.width );\n\n\t\t\t} else {\n\n\t\t\t\t// See PerspectiveCamera.updateProjectionMatrix and Matrix4.makePerspective:\n\t\t\t\t// the vertical FOV is used to populate matrix element 5.\n\t\t\t\tinfo.sseDenominator = ( 2 / projection[ 5 ] ) / resolution.height;\n\n\t\t\t}\n\n\t\t\t// get frustum in group root frame\n\t\t\ttempMat.copy( group.matrixWorld );\n\t\t\ttempMat.premultiply( camera.matrixWorldInverse );\n\t\t\ttempMat.premultiply( camera.projectionMatrix );\n\n\t\t\tfrustum.setFromProjectionMatrix( tempMat );\n\n\t\t\t// get transform position in group root frame\n\t\t\tposition.set( 0, 0, 0 );\n\t\t\tposition.applyMatrix4( camera.matrixWorld );\n\t\t\tposition.applyMatrix4( group.matrixWorldInverse );\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\tsuper.update();\n\n\t\t// check for cameras _after_ base update so we can enable pre-loading the root tileset\n\t\tif ( this.cameras.length === 0 && this.root ) {\n\n\t\t\tlet found = false;\n\t\t\tthis.invokeAllPlugins( plugin => found = found || Boolean( plugin !== this && plugin.calculateTileViewError ) );\n\t\t\tif ( found === false ) {\n\n\t\t\t\tconsole.warn( 'TilesRenderer: no cameras defined. Cannot update 3d tiles.' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tpreprocessNode( tile, tilesetDir, parentTile = null ) {\n\n\t\tsuper.preprocessNode( tile, tilesetDir, parentTile );\n\n\t\tconst transform = new Matrix4();\n\t\tif ( tile.transform ) {\n\n\t\t\tconst transformArr = tile.transform;\n\t\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\t\ttransform.elements[ i ] = transformArr[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( parentTile ) {\n\n\t\t\ttransform.premultiply( parentTile.engineData.transform );\n\n\t\t}\n\n\t\tconst transformInverse = new Matrix4().copy( transform ).invert();\n\t\tconst boundingVolume = new TileBoundingVolume();\n\t\tif ( 'sphere' in tile.boundingVolume ) {\n\n\t\t\tboundingVolume.setSphereData( ...tile.boundingVolume.sphere, transform );\n\n\t\t}\n\n\t\tif ( 'box' in tile.boundingVolume ) {\n\n\t\t\tboundingVolume.setObbData( tile.boundingVolume.box, transform );\n\n\t\t}\n\n\t\tif ( 'region' in tile.boundingVolume ) {\n\n\t\t\tboundingVolume.setRegionData( this.ellipsoid, ...tile.boundingVolume.region );\n\n\t\t}\n\n\t\t// Extend the base engineData structure with Three.js-specific fields\n\t\t// Base class initializes: scene, metadata, boundingVolume\n\t\ttile.engineData.transform = transform;\n\t\ttile.engineData.transformInverse = transformInverse;\n\t\ttile.engineData.boundingVolume = boundingVolume;\n\t\ttile.engineData.geometry = null;\n\t\ttile.engineData.materials = null;\n\t\ttile.engineData.textures = null;\n\n\t}\n\n\tasync parseTile( buffer, tile, extension, uri, abortSignal ) {\n\n\t\tconst engineData = tile.engineData;\n\t\tconst workingPath = LoaderUtils.getWorkingPath( uri );\n\t\tconst fetchOptions = this.fetchOptions;\n\n\t\tconst manager = this.manager;\n\t\tlet promise = null;\n\n\t\tconst tileTransform = engineData.transform;\n\t\tconst upRotationMatrix = this._upRotationMatrix;\n\t\tconst fileType = ( LoaderUtils.readMagicBytes( buffer ) || extension ).toLowerCase();\n\t\tswitch ( fileType ) {\n\n\t\t\tcase 'b3dm': {\n\n\t\t\t\tconst loader = new B3DMLoader( manager );\n\t\t\t\tloader.workingPath = workingPath;\n\t\t\t\tloader.fetchOptions = fetchOptions;\n\n\t\t\t\tloader.adjustmentTransform.copy( upRotationMatrix );\n\n\t\t\t\tpromise = loader.parse( buffer );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcase 'pnts': {\n\n\t\t\t\tconst loader = new PNTSLoader( manager );\n\t\t\t\tloader.workingPath = workingPath;\n\t\t\t\tloader.fetchOptions = fetchOptions;\n\t\t\t\tpromise = loader.parse( buffer );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcase 'i3dm': {\n\n\t\t\t\tconst loader = new I3DMLoader( manager );\n\t\t\t\tloader.workingPath = workingPath;\n\t\t\t\tloader.fetchOptions = fetchOptions;\n\n\t\t\t\tloader.adjustmentTransform.copy( upRotationMatrix );\n\t\t\t\tloader.ellipsoid.copy( this.ellipsoid );\n\n\t\t\t\tpromise = loader.parse( buffer );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcase 'cmpt': {\n\n\t\t\t\tconst loader = new CMPTLoader( manager );\n\t\t\t\tloader.workingPath = workingPath;\n\t\t\t\tloader.fetchOptions = fetchOptions;\n\n\t\t\t\tloader.adjustmentTransform.copy( upRotationMatrix );\n\t\t\t\tloader.ellipsoid.copy( this.ellipsoid );\n\n\t\t\t\tpromise = loader\n\t\t\t\t\t.parse( buffer )\n\t\t\t\t\t.then( res => res.scene\t);\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// 3DTILES_content_gltf\n\t\t\tcase 'gltf':\n\t\t\tcase 'glb': {\n\n\t\t\t\tconst loader = manager.getHandler( 'path.gltf' ) || manager.getHandler( 'path.glb' ) || new GLTFLoader( manager );\n\t\t\t\tloader.setWithCredentials( fetchOptions.credentials === 'include' );\n\t\t\t\tloader.setRequestHeader( fetchOptions.headers || {} );\n\t\t\t\tif ( fetchOptions.credentials === 'include' && fetchOptions.mode === 'cors' ) {\n\n\t\t\t\t\tloader.setCrossOrigin( 'use-credentials' );\n\n\t\t\t\t}\n\n\t\t\t\t// assume any pre-registered loader has paths configured as the user desires, but if we're making\n\t\t\t\t// a new loader, use the working path during parse to support relative uris on other hosts\n\t\t\t\tlet resourcePath = loader.resourcePath || loader.path || workingPath;\n\t\t\t\tif ( ! /[\\\\/]$/.test( resourcePath ) && resourcePath.length ) {\n\n\t\t\t\t\tresourcePath += '/';\n\n\t\t\t\t}\n\n\t\t\t\tpromise = loader.parseAsync( buffer, resourcePath ).then( result => {\n\n\t\t\t\t\t// glTF files are not guaranteed to include a scene object\n\t\t\t\t\tresult.scene = result.scene || new Group();\n\n\t\t\t\t\t// apply the local up-axis correction rotation\n\t\t\t\t\t// GLTFLoader seems to never set a transformation on the root scene object so\n\t\t\t\t\t// any transformations applied to it can be assumed to be applied after load\n\t\t\t\t\t// (such as applying RTC_CENTER) meaning they should happen _after_ the z-up\n\t\t\t\t\t// rotation fix which is why \"multiply\" happens here.\n\t\t\t\t\tconst { scene } = result;\n\t\t\t\t\tscene.updateMatrix();\n\t\t\t\t\tscene.matrix\n\t\t\t\t\t\t.multiply( upRotationMatrix )\n\t\t\t\t\t\t.decompose( scene.position, scene.quaternion, scene.scale );\n\n\t\t\t\t\treturn result;\n\n\t\t\t\t} );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tdefault: {\n\n\t\t\t\tpromise = this.invokeOnePlugin( plugin => plugin.parseToMesh && plugin.parseToMesh( buffer, tile, extension, uri, abortSignal ) );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// wait for the tile to load\n\t\tconst result = await promise;\n\t\tif ( result === null ) {\n\n\t\t\tthrow new Error( `TilesRenderer: Content type \"${ fileType }\" not supported.` );\n\n\t\t}\n\n\t\t// get the scene data\n\t\tlet scene;\n\t\tlet metadata;\n\t\tif ( result.isObject3D ) {\n\n\t\t\tscene = result;\n\t\t\tmetadata = null;\n\n\t\t} else {\n\n\t\t\tscene = result.scene;\n\t\t\tmetadata = result;\n\n\t\t}\n\n\t\t// ensure the matrix is up to date in case the scene has a transform applied\n\t\tscene.updateMatrix();\n\t\tscene.matrix.premultiply( tileTransform );\n\t\tscene.matrix.decompose( scene.position, scene.quaternion, scene.scale );\n\n\t\t// wait for extra processing by plugins if needed\n\t\tawait this.invokeAllPlugins( plugin => {\n\n\t\t\treturn plugin.processTileModel && plugin.processTileModel( scene, tile );\n\n\t\t} );\n\n\t\t// frustum culling\n\t\tscene.traverse( c => {\n\n\t\t\tc[ INITIAL_FRUSTUM_CULLED ] = c.frustumCulled;\n\n\t\t} );\n\t\tupdateFrustumCulled( scene, ! this.autoDisableRendererCulling );\n\n\t\t// collect all original geometries, materials, etc to be disposed of later\n\t\tconst materials = [];\n\t\tconst geometry = [];\n\t\tconst textures = [];\n\t\tscene.traverse( c => {\n\n\t\t\tif ( c.geometry ) {\n\n\t\t\t\tgeometry.push( c.geometry );\n\n\t\t\t}\n\n\t\t\tif ( c.material ) {\n\n\t\t\t\tconst material = c.material;\n\t\t\t\tmaterials.push( c.material );\n\n\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\tconst value = material[ key ];\n\t\t\t\t\tif ( value && value.isTexture ) {\n\n\t\t\t\t\t\ttextures.push( value );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// exit early if a new request has already started\n\t\tif ( abortSignal.aborted ) {\n\n\t\t\t// dispose of any image bitmaps that have been opened.\n\t\t\t// TODO: share this code with the \"disposeTile\" code below, possibly allow for the tiles\n\t\t\t// renderer base to trigger a disposal of unneeded data\n\t\t\tfor ( let i = 0, l = textures.length; i < l; i ++ ) {\n\n\t\t\t\tconst texture = textures[ i ];\n\n\t\t\t\tif ( texture.image instanceof ImageBitmap ) {\n\n\t\t\t\t\ttexture.image.close();\n\n\t\t\t\t}\n\n\t\t\t\ttexture.dispose();\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tengineData.materials = materials;\n\t\tengineData.geometry = geometry;\n\t\tengineData.textures = textures;\n\t\tengineData.scene = scene;\n\t\tengineData.metadata = metadata;\n\n\t}\n\n\tdisposeTile( tile ) {\n\n\t\t// TODO: call this \"disposeTileModel\"?\n\t\tsuper.disposeTile( tile );\n\n\t\t// This could get called before the tile has finished downloading\n\t\tconst engineData = tile.engineData;\n\t\tif ( engineData.scene ) {\n\n\t\t\tconst materials = engineData.materials;\n\t\t\tconst geometry = engineData.geometry;\n\t\t\tconst textures = engineData.textures;\n\t\t\tconst parent = engineData.scene.parent;\n\n\t\t\t// dispose of any textures required by the mesh features extension\n\t\t\t// TODO: these are being discarded here to remove the image bitmaps -\n\t\t\t// can this be handled in another way? Or more generically?\n\t\t\tengineData.scene.traverse( child => {\n\n\t\t\t\tif ( child.userData.meshFeatures ) {\n\n\t\t\t\t\tchild.userData.meshFeatures.dispose();\n\n\t\t\t\t}\n\n\t\t\t\tif ( child.userData.structuralMetadata ) {\n\n\t\t\t\t\tchild.userData.structuralMetadata.dispose();\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tfor ( let i = 0, l = geometry.length; i < l; i ++ ) {\n\n\t\t\t\tgeometry[ i ].dispose();\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\t\tmaterials[ i ].dispose();\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, l = textures.length; i < l; i ++ ) {\n\n\t\t\t\tconst texture = textures[ i ];\n\n\t\t\t\tif ( texture.image instanceof ImageBitmap ) {\n\n\t\t\t\t\ttexture.image.close();\n\n\t\t\t\t}\n\n\t\t\t\ttexture.dispose();\n\n\t\t\t}\n\n\t\t\tif ( parent ) {\n\n\t\t\t\tparent.remove( engineData.scene );\n\n\t\t\t}\n\n\t\t\tengineData.scene = null;\n\t\t\tengineData.materials = null;\n\t\t\tengineData.textures = null;\n\t\t\tengineData.geometry = null;\n\t\t\tengineData.metadata = null;\n\n\t\t}\n\n\t}\n\n\tsetTileVisible( tile, visible ) {\n\n\t\tconst scene = tile.engineData.scene;\n\t\tconst group = this.group;\n\n\t\tif ( visible ) {\n\n\t\t\tif ( scene ) {\n\n\t\t\t\tgroup.add( scene );\n\t\t\t\tscene.updateMatrixWorld( true );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( scene ) {\n\n\t\t\t\tgroup.remove( scene );\n\n\t\t\t}\n\n\t\t}\n\n\t\tsuper.setTileVisible( tile, visible );\n\n\t}\n\n\tcalculateBytesUsed( tile, scene ) {\n\n\t\tconst bytesUsed = this._bytesUsed;\n\t\tif ( ! bytesUsed.has( tile ) && scene ) {\n\n\t\t\tbytesUsed.set( tile, estimateBytesUsed( scene ) );\n\n\t\t}\n\n\t\treturn bytesUsed.get( tile ) ?? null;\n\n\t}\n\n\tcalculateTileViewError( tile, target ) {\n\n\t\tconst engineData = tile.engineData;\n\t\tconst cameras = this.cameras;\n\t\tconst cameraInfo = this.cameraInfo;\n\t\tconst boundingVolume = engineData.boundingVolume;\n\n\t\tlet inView = false;\n\t\tlet inViewError = 0;\n\t\tlet inViewDistance = Infinity;\n\t\tlet maxCameraError = 0;\n\t\tlet minCameraDistance = Infinity;\n\n\t\tfor ( let i = 0, l = cameras.length; i < l; i ++ ) {\n\n\t\t\t// calculate the camera error\n\t\t\tconst info = cameraInfo[ i ];\n\t\t\tlet error;\n\t\t\tlet distance;\n\t\t\tif ( info.isOrthographic ) {\n\n\t\t\t\tconst pixelSize = info.pixelSize;\n\t\t\t\terror = tile.geometricError / pixelSize;\n\t\t\t\tdistance = Infinity;\n\n\t\t\t} else {\n\n\t\t\t\t// avoid dividing 0 by 0 which can result in NaN. If the distance to the tile is\n\t\t\t\t// 0 then the error should be infinity.\n\t\t\t\tconst sseDenominator = info.sseDenominator;\n\t\t\t\tdistance = boundingVolume.distanceToPoint( info.position );\n\t\t\t\terror = distance === 0 ? Infinity : tile.geometricError / ( distance * sseDenominator );\n\n\t\t\t}\n\n\t\t\t// Track which camera frustums this tile is in so we can use it\n\t\t\t// to ignore the error calculations for cameras that can't see it\n\t\t\tconst frustum = cameraInfo[ i ].frustum;\n\t\t\tif ( boundingVolume.intersectsFrustum( frustum ) ) {\n\n\t\t\t\tinView = true;\n\t\t\t\tinViewError = Math.max( inViewError, error );\n\t\t\t\tinViewDistance = Math.min( inViewDistance, distance );\n\n\t\t\t}\n\n\t\t\tmaxCameraError = Math.max( maxCameraError, error );\n\t\t\tminCameraDistance = Math.min( minCameraDistance, distance );\n\n\t\t}\n\n\t\tif ( inView ) {\n\n\t\t\t// write the in-camera error and distance parameters\n\t\t\ttarget.inView = true;\n\t\t\ttarget.error = inViewError;\n\t\t\ttarget.distanceFromCamera = inViewDistance;\n\n\t\t} else {\n\n\t\t\t// otherwise write variables for load priority\n\t\t\ttarget.inView = false;\n\t\t\ttarget.error = maxCameraError;\n\t\t\ttarget.distanceFromCamera = minCameraDistance;\n\n\t\t}\n\n\t}\n\n\t// adjust the rotation of the group such that Y is altitude, X is North, and Z is East\n\tsetLatLonToYUp( lat, lon ) {\n\n\t\tconsole.warn( 'TilesRenderer: setLatLonToYUp is deprecated. Use the ReorientationPlugin, instead.' );\n\n\t\tconst { ellipsoid, group } = this;\n\n\t\t_euler.set( Math.PI / 2, Math.PI / 2, 0 );\n\t\t_mat.makeRotationFromEuler( _euler );\n\n\t\tellipsoid.getEastNorthUpFrame( lat, lon, 0, group.matrix )\n\t\t\t.multiply( _mat )\n\t\t\t.invert()\n\t\t\t.decompose(\n\t\t\t\tgroup.position,\n\t\t\t\tgroup.quaternion,\n\t\t\t\tgroup.scale,\n\t\t\t);\n\n\t\tgroup.updateMatrixWorld( true );\n\n\t}\n\n\tdispose() {\n\n\t\tsuper.dispose();\n\t\tthis.group.removeFromParent();\n\n\t}\n\n}\n"],"names":["tempMat","Matrix4","TilesGroup","Group","tilesRenderer","raycaster","intersects","force","elA","elB","isDifferent","i","itemA","itemB","children","l","updateParents","updateChildren","_localRay","Ray","_vec","Vector3","_hitArray","distanceSort","a","b","intersectTileScene","tile","renderer","scene","plugin","intersectTileSceneFirstHist","hit","isTileInitialized","raycastTraverseFirstHit","localRay","group","activeTiles","array","child","bestHit","bestHitDistSq","data","boundingVolumeDistSq","hitDistSq","raycastTraverse","boundingVolume","_worldMin","_worldMax","_norm","_ray","OBB","box","Box3","transform","Plane","source","point","result","ray","target","points","inverseTransform","min","max","index","x","y","z","sphere","frustum","obb","otherPlanes","otherPoints","thisPoints","thisPlanes","plane","maxDistance","j","v","dist","_vecX","_vecY","_vecZ","_sphereVec","_obbVec","TileBoundingVolume","sphereDistSq","obbDistSq","furthestDist","sphereDistance","obbDistance","otherSphere","otherObb","targetBox","targetMatrix","scaleX","scaleY","scaleZ","radius","Sphere","ellipsoid","west","south","east","north","minHeight","maxHeight","region","EllipsoidRegion","_mat3","Matrix3","findIntersectionPoint","plane1","plane2","plane3","A","ExtendedFrustum","Frustum","m","coordinateSystem","planes","getTextureByteLength","tex","format","type","image","width","height","bytes","TextureUtils","estimateBytesUsed","object","dedupeSet","totalBytes","c","_estimateBytesUsed","material","key","value","_mat","_euler","Euler","INITIAL_FRUSTUM_CULLED","tempVector","tempVector2","Vector2","X_AXIS","Y_AXIS","updateFrustumCulled","toInitialValue","TilesRenderer","TilesRendererBase","args","WGS84_ELLIPSOID","LoadingManager","listener","EventDispatcher","callback","camera","cameras","cameraMap","xOrVec","cameraVec","root","asset","extensions","ext","cameraInfo","info","position","resolution","projection","w","h","found","tilesetDir","parentTile","transformArr","transformInverse","buffer","extension","uri","abortSignal","engineData","workingPath","LoaderUtils.getWorkingPath","fetchOptions","manager","promise","tileTransform","upRotationMatrix","fileType","LoaderUtils.readMagicBytes","loader","B3DMLoader","PNTSLoader","I3DMLoader","CMPTLoader","res","GLTFLoader","resourcePath","metadata","materials","geometry","textures","texture","parent","visible","bytesUsed","inView","inViewError","inViewDistance","maxCameraError","minCameraDistance","error","distance","pixelSize","sseDenominator","lat","lon"],"mappings":"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"}