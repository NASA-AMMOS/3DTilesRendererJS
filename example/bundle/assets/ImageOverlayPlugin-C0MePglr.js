import{n as V,M as T,o as w,aI as Y,N as F,B as j,aq as q,ao as K,C as Z}from"./three.module-D-uF--xd.js";import{P as ee,a as te}from"./TilesRendererBase-CFsQu8zV.js";import{C as ie}from"./CesiumIonAuth-ByA9ya_o.js";import{X as W,T as ne}from"./TMSImageSource-BIqdNmly.js";import{G as se}from"./GeometryClipper-7b525s21.js";import{g as ae}from"./TilesRenderer-Bm042Xsy.js";import{D as oe,P as re}from"./TiledImageSource-DmD64Gn9.js";import{W as le}from"./I3DMLoader-BWluRuWb.js";class he extends W{constructor(e={}){const{subdomains:t=["t0"],...i}=e;super(i),this.subdomains=t,this.subDomainIndex=0}getUrl(e,t,i){return this.url.replace(/{\s*subdomain\s*}/gi,this._getSubdomain()).replace(/{\s*quadkey\s*}/gi,this._tileToQuadKey(e,t,i))}_tileToQuadKey(e,t,i){let n="";for(let o=i;o>0;o--){let s=0;const a=1<<o-1;(e&a)!==0&&(s+=1),(t&a)!==0&&(s+=2),n+=s.toString()}return n}_getSubdomain(){return this.subDomainIndex=(this.subDomainIndex+1)%this.subdomains.length,this.subdomains[this.subDomainIndex]}}function D(y,e,t,i){let[n,o,s,a]=y;o+=1e-8,n+=1e-8,a-=1e-8,s-=1e-8;const r=Math.max(Math.min(e,t.maxLevel),t.minLevel),[l,h,c,u]=t.getTilesInRange(n,o,s,a,r,!0);for(let f=l;f<=c;f++)for(let m=h;m<=u;m++)i(f,m,r)}function ce(y,e,t){const i=new w,n={},o=[],s=y.getAttribute("position");y.computeBoundingBox(),y.boundingBox.getCenter(i).applyMatrix4(e),t.getPositionToCartographic(i,n);const a=n.lat,r=n.lon;let l=1/0,h=1/0,c=1/0,u=-1/0,f=-1/0,m=-1/0;for(let p=0;p<s.count;p++)i.fromBufferAttribute(s,p).applyMatrix4(e),t.getPositionToCartographic(i,n),Math.abs(Math.abs(n.lat)-Math.PI/2)<1e-5&&(n.lon=r),Math.abs(r-n.lon)>Math.PI&&(n.lon+=Math.sign(r-n.lon)*Math.PI*2),Math.abs(a-n.lat)>Math.PI&&(n.lat+=Math.sign(a-n.lat)*Math.PI*2),o.push(n.lon,n.lat,n.height),l=Math.min(l,n.lat),u=Math.max(u,n.lat),h=Math.min(h,n.lon),f=Math.max(f,n.lon),c=Math.min(c,n.height),m=Math.max(m,n.height);const d=[h,l,f,u],_=[...d,c,m];return{uv:o,range:d,region:_}}function z(y,e,t=null,i=null){let n=1/0,o=1/0,s=1/0,a=-1/0,r=-1/0,l=-1/0;const h=[],c=new V;y.forEach(f=>{c.copy(f.matrixWorld),t&&c.premultiply(t);const{uv:m,region:d}=ce(f.geometry,c,e);h.push(m),n=Math.min(n,d[1]),a=Math.max(a,d[3]),o=Math.min(o,d[0]),r=Math.max(r,d[2]),s=Math.min(s,d[4]),l=Math.max(l,d[5])});let u=[o,n,r,a];if(i!==null){u=i.clampToBounds([o,n,r,a]);const[f,m,d,_]=i.toNormalizedRange(u);h.forEach(p=>{for(let M=0,v=p.length;M<v;M+=3){const g=p[M+0],I=p[M+1],L=p[M+2],[S,x]=i.toNormalizedPoint(g,I);p[M+0]=T.mapLinear(S,f,d,0,1),p[M+1]=T.mapLinear(x,m,_,0,1),p[M+2]=T.mapLinear(L,s,l,0,1)}})}return{uvs:h,range:u,region:[o,n,r,a,s,l]}}function ue(y,e){const t=new w,i=[],n=y.getAttribute("position");let o=1/0,s=1/0,a=1/0,r=-1/0,l=-1/0,h=-1/0;for(let u=0;u<n.count;u++)t.fromBufferAttribute(n,u).applyMatrix4(e),i.push(t.x,t.y,t.z),o=Math.min(o,t.x),r=Math.max(r,t.x),s=Math.min(s,t.y),l=Math.max(l,t.y),a=Math.min(a,t.z),h=Math.max(h,t.z);return{uv:i,range:[o,s,r,l],heightRange:[a,h]}}function me(y,e){let t=1/0,i=1/0,n=1/0,o=-1/0,s=-1/0,a=-1/0;const r=[],l=new V;return y.forEach(h=>{l.copy(h.matrixWorld),e&&l.premultiply(e);const{uv:c,range:u,heightRange:f}=ue(h.geometry,l);r.push(c),t=Math.min(t,u[0]),o=Math.max(o,u[2]),i=Math.min(i,u[1]),s=Math.max(s,u[3]),n=Math.min(n,f[0]),a=Math.max(a,f[1])}),r.forEach(h=>{for(let c=0,u=h.length;c<u;c+=3){const f=h[c+0],m=h[c+1];h[c+0]=T.mapLinear(f,t,o,0,1),h[c+1]=T.mapLinear(m,i,s,0,1)}}),{uvs:r,range:[t,i,o,s],heightRange:[n,a]}}const k=Symbol("OVERLAY_PARAMS");function fe(y,e){if(y[k])return y[k];const t={layerMaps:{value:[]},layerInfo:{value:[]}};return y[k]=t,y.defines={...y.defines||{},LAYER_COUNT:0},y.onBeforeCompile=i=>{e&&e(i),i.uniforms={...i.uniforms,...t},i.vertexShader=i.vertexShader.replace(/void main\(\s*\)\s*{/,n=>`

				#pragma unroll_loop_start
					for ( int i = 0; i < 10; i ++ ) {

						#if UNROLLED_LOOP_INDEX < LAYER_COUNT

							attribute vec3 layer_uv_UNROLLED_LOOP_INDEX;
							varying vec3 v_layer_uv_UNROLLED_LOOP_INDEX;

						#endif


					}
				#pragma unroll_loop_end

				${n}

				#pragma unroll_loop_start
					for ( int i = 0; i < 10; i ++ ) {

						#if UNROLLED_LOOP_INDEX < LAYER_COUNT

							v_layer_uv_UNROLLED_LOOP_INDEX = layer_uv_UNROLLED_LOOP_INDEX;

						#endif

					}
				#pragma unroll_loop_end

			`),i.fragmentShader=i.fragmentShader.replace(/void main\(/,n=>`

				#if LAYER_COUNT != 0
					struct LayerInfo {
						vec3 color;
						float opacity;

						int alphaMask;
						int alphaInvert;
					};

					uniform sampler2D layerMaps[ LAYER_COUNT ];
					uniform LayerInfo layerInfo[ LAYER_COUNT ];
				#endif

				#pragma unroll_loop_start
					for ( int i = 0; i < 10; i ++ ) {

						#if UNROLLED_LOOP_INDEX < LAYER_COUNT

							varying vec3 v_layer_uv_UNROLLED_LOOP_INDEX;

						#endif

					}
				#pragma unroll_loop_end

				${n}

			`).replace(/#include <color_fragment>/,n=>`

				${n}

				#if LAYER_COUNT != 0
				{
					vec4 tint;
					vec3 layerUV;
					float layerOpacity;
					float wOpacity;
					float wDelta;
					#pragma unroll_loop_start
						for ( int i = 0; i < 10; i ++ ) {

							#if UNROLLED_LOOP_INDEX < LAYER_COUNT

								layerUV = v_layer_uv_UNROLLED_LOOP_INDEX;
								tint = texture( layerMaps[ i ], layerUV.xy );

								// discard texture outside 0, 1 on w - offset the stepped value by an epsilon to avoid cases
								// where wDelta is near 0 (eg a flat surface) at the w boundary, resulting in artifacts on some
								// hardware.
								wDelta = max( fwidth( layerUV.z ), 1e-7 );
								wOpacity =
									smoothstep( - wDelta, 0.0, layerUV.z ) *
									smoothstep( 1.0 + wDelta, 1.0, layerUV.z );

								// apply tint & opacity
								tint.rgb *= layerInfo[ i ].color;
								tint.rgba *= layerInfo[ i ].opacity * wOpacity;

								// invert the alpha
								if ( layerInfo[ i ].alphaInvert > 0 ) {

									tint.a = 1.0 - tint.a;

								}

								// apply the alpha across all existing layers if alpha mask is true
								if ( layerInfo[ i ].alphaMask > 0 ) {

									diffuseColor.a *= tint.a;

								} else {

									tint.rgb *= tint.a;
									diffuseColor = tint + diffuseColor * ( 1.0 - tint.a );

								}

							#endif

						}
					#pragma unroll_loop_end
				}
				#endif
			`)},t}class ${constructor(){this.canvas=null,this.context=null,this.range=[0,0,1,1]}setTarget(e,t){this.canvas=e.image,this.context=e.image.getContext("2d"),this.range=[...t]}draw(e,t){const{canvas:i,range:n,context:o}=this,{width:s,height:a}=i,{image:r}=e,l=Math.round(T.mapLinear(t[0],n[0],n[2],0,s)),h=Math.round(T.mapLinear(t[1],n[1],n[3],0,a)),c=Math.round(T.mapLinear(t[2],n[0],n[2],0,s)),u=Math.round(T.mapLinear(t[3],n[1],n[3],0,a)),f=c-l,m=u-h;r instanceof ImageBitmap?(o.save(),o.translate(l,a-h),o.scale(1,-1),o.drawImage(r,0,0,f,m),o.restore()):o.drawImage(r,l,a-h,f,-m)}clear(){const{context:e,canvas:t}=this;e.clearRect(0,0,t.width,t.height)}}class Q extends oe{hasContent(...e){return!0}}class de extends Q{constructor(e){super(),this.tiledImageSource=e,this.tileComposer=new $,this.resolution=256}hasContent(e,t,i,n,o){const s=this.tiledImageSource.tiling;let a=0;return D([e,t,i,n],o,s,()=>{a++}),a!==0}async fetchItem([e,t,i,n,o],s){const a=[e,t,i,n],r=this.tiledImageSource,l=this.tileComposer,h=r.tiling,c=document.createElement("canvas");c.width=this.resolution,c.height=this.resolution;const u=new Y(c);return u.colorSpace=F,u.generateMipmaps=!1,u.tokens=[...a,o],await this._markImages(a,o,!1),l.setTarget(u,a),l.clear(16777215,0),D(a,o,h,(f,m,d)=>{const _=h.getTileBounds(f,m,d,!0,!1),p=r.get(f,m,d);l.draw(p,_)}),u}disposeItem(e){e.dispose();const[t,i,n,o,s]=e.tokens;this._markImages([t,i,n,o],s,!0)}dispose(){super.dispose(),this.tiledImageSource.dispose()}_markImages(e,t,i=!1){const n=this.tiledImageSource,o=n.tiling,s=[];D(e,t,o,(r,l,h)=>{i?n.release(r,l,h):s.push(n.lock(r,l,h))});const a=s.filter(r=>r instanceof Promise);return a.length!==0?Promise.all(a):null}}const U=new w,O=new w;function pe(y,e,t){y.getCartographicToPosition(e,t,0,U),y.getCartographicToPosition(e+.01,t,0,O);const n=U.distanceTo(O);return y.getCartographicToPosition(e,t+.01,0,O),U.distanceTo(O)/n}class ge extends Q{constructor({geojson:e=null,url:t=null,resolution:i=256,pointRadius:n=6,strokeStyle:o="white",strokeWidth:s=2,fillStyle:a="rgba( 255, 255, 255, 0.5 )",...r}={}){super(r),this.geojson=e,this.url=t,this.resolution=i,this.pointRadius=n,this.strokeStyle=o,this.strokeWidth=s,this.fillStyle=a,this.features=null,this.featureBounds=new Map,this.contentBounds=null,this.projection=new re,this.fetchData=(...l)=>fetch(...l)}async init(){const{geojson:e,url:t}=this;if(!e&&t){const i=await this.fetchData(t);this.geojson=await i.json()}this._updateCache(!0)}hasContent(e,t,i,n){const o=[e,t,i,n].map(s=>s*Math.RAD2DEG);return this._boundsIntersectBounds(o,this.contentBounds)}async fetchItem(e,t){const i=document.createElement("canvas"),n=new Y(i);return n.colorSpace=F,n.generateMipmaps=!1,this._drawToCanvas(i,e),n.needsUpdate=!0,n}disposeItem(e){e.dispose()}redraw(){this._updateCache(!0),this.forEachItem((e,t)=>{this._drawToCanvas(e.image,t),e.needsUpdate=!0})}_updateCache(e=!1){const{geojson:t,featureBounds:i}=this;if(!t||this.features&&!e)return;i.clear();let n=1/0,o=1/0,s=-1/0,a=-1/0;this.features=this._featuresFromGeoJSON(t),this.features.forEach(r=>{const l=this._getFeatureBounds(r);i.set(r,l);const[h,c,u,f]=l;n=Math.min(n,h),o=Math.min(o,c),s=Math.max(s,u),a=Math.max(a,f)}),this.contentBounds=[n,o,s,a]}_drawToCanvas(e,t){this._updateCache();const[i,n,o,s]=t,{projection:a,resolution:r,features:l}=this;e.width=r,e.height=r;const h=a.convertNormalizedToLongitude(i),c=a.convertNormalizedToLatitude(n),u=a.convertNormalizedToLongitude(o),f=a.convertNormalizedToLatitude(s),m=[h*T.RAD2DEG,c*T.RAD2DEG,u*T.RAD2DEG,f*T.RAD2DEG],d=e.getContext("2d");for(let _=0;_<l.length;_++){const p=l[_];this._featureIntersectsTile(p,m)&&this._drawFeatureOnCanvas(d,p,m,e.width,e.height)}}_featureIntersectsTile(e,t){const i=this.featureBounds.get(e);return i?this._boundsIntersectBounds(i,t):!1}_boundsIntersectBounds(e,t){const[i,n,o,s]=e,[a,r,l,h]=t;return!(o<a||i>l||s<r||n>h)}_getFeatureBounds(e){const{geometry:t}=e;if(!t)return null;const{type:i,coordinates:n}=t;let o=1/0,s=1/0,a=-1/0,r=-1/0;const l=(h,c)=>{o=Math.min(o,h),a=Math.max(a,h),s=Math.min(s,c),r=Math.max(r,c)};return i==="Point"?l(n[0],n[1]):i==="MultiPoint"||i==="LineString"?n.forEach(h=>l(h[0],h[1])):i==="MultiLineString"||i==="Polygon"?n.forEach(h=>h.forEach(c=>l(c[0],c[1]))):i==="MultiPolygon"&&n.forEach(h=>h.forEach(c=>c.forEach(u=>l(u[0],u[1])))),[o,s,a,r]}_featuresFromGeoJSON(e){const t=e.type,i=new Set(["Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon"]);return t==="FeatureCollection"?e.features:t==="Feature"?[e]:t==="GeometryCollection"?e.geometries.map(n=>({type:"Feature",geometry:n,properties:{}})):i.has(t)?[{type:"Feature",geometry:e,properties:{}}]:[]}_drawFeatureOnCanvas(e,t,i,n,o){const{geometry:s=null,properties:a={}}=t;if(!s)return;const[r,l,h,c]=i,u=a.strokeStyle||this.strokeStyle,f=a.fillStyle||this.fillStyle,m=a.pointRadius||this.pointRadius,d=a.strokeWidth||this.strokeWidth;e.save(),e.strokeStyle=u,e.fillStyle=f,e.lineWidth=d;const _=new Array(2),p=(g,I,L=_)=>{const S=T.mapLinear(g,r,h,0,n),x=o-T.mapLinear(I,l,c,0,o);return L[0]=Math.round(S),L[1]=Math.round(x),L},M=(g,I)=>{const L=I*T.DEG2RAD,S=g*T.DEG2RAD,x=(c-l)/o;return(h-r)/n/x*pe(le,L,S)},v=s.type;if(v==="Point"){const[g,I]=s.coordinates,[L,S]=p(g,I),x=M(g,I);e.beginPath(),e.ellipse(L,S,m/x,m,0,0,Math.PI*2),e.fill(),e.stroke()}else v==="MultiPoint"?s.coordinates.forEach(([g,I])=>{const[L,S]=p(g,I),x=M(g,I);e.beginPath(),e.ellipse(L,S,m/x,m,0,0,Math.PI*2),e.fill(),e.stroke()}):v==="LineString"?(e.beginPath(),s.coordinates.forEach(([g,I],L)=>{const[S,x]=p(g,I);L===0?e.moveTo(S,x):e.lineTo(S,x)}),e.stroke()):v==="MultiLineString"?(e.beginPath(),s.coordinates.forEach(g=>{g.forEach(([I,L],S)=>{const[x,E]=p(I,L);S===0?e.moveTo(x,E):e.lineTo(x,E)})}),e.stroke()):v==="Polygon"?(e.beginPath(),s.coordinates.forEach((g,I)=>{g.forEach(([L,S],x)=>{const[E,R]=p(L,S);x===0?e.moveTo(E,R):e.lineTo(E,R)}),e.closePath()}),e.fill("evenodd"),e.stroke()):v==="MultiPolygon"&&s.coordinates.forEach(g=>{e.beginPath(),g.forEach((I,L)=>{I.forEach(([S,x],E)=>{const[R,X]=p(S,x);E===0?e.moveTo(R,X):e.lineTo(R,X)}),e.closePath()}),e.fill("evenodd"),e.stroke()});e.restore()}}const C=new V,P=new w,N=new w,B=new w,b=new w,ye=new j,G=Symbol("SPLIT_TILE_DATA"),A=Symbol("SPLIT_HASH");class be{get enableTileSplitting(){return this._enableTileSplitting}set enableTileSplitting(e){this._enableTileSplitting!==e&&(this._enableTileSplitting=e,this._markNeedsUpdate())}constructor(e={}){const{overlays:t=[],resolution:i=256,enableTileSplitting:n=!0}=e;this.name="IMAGE_OVERLAY_PLUGIN",this.priority=-15,this.resolution=i,this._enableTileSplitting=n,this.overlays=[],this.needsUpdate=!1,this.tiles=null,this.tileComposer=null,this.tileControllers=new Map,this.overlayInfo=new Map,this.meshParams=new WeakMap,this.pendingTiles=new Map,this.processedTiles=new Set,this.processQueue=null,this._onUpdateAfter=null,this._onTileDownloadStart=null,this._virtualChildResetId=0,this._bytesUsed=new WeakMap,t.forEach(o=>{this.addOverlay(o)})}init(e){const t=new $,i=new ee;i.maxJobs=10,i.priorityCallback=(n,o)=>{const s=n.tile,a=o.tile,r=e.visibleTiles.has(s),l=e.visibleTiles.has(a);return r!==l?r?1:-1:e.downloadQueue.priorityCallback(s,a)},this.tiles=e,this.tileComposer=t,this.processQueue=i,e.forEachLoadedModel((n,o)=>{this._processTileModel(n,o,!0)}),this._onUpdateAfter=async()=>{let n=!1;if(this.overlayInfo.forEach((o,s)=>{if(!!s.frame!=!!o.frame||s.frame&&o.frame&&!o.frame.equals(s.frame)){const a=o.order;this.deleteOverlay(s),this.addOverlay(s,a),n=!0}}),n){const o=i.maxJobs;let s=0;i.items.forEach(a=>{e.visibleTiles.has(a.tile)&&s++}),i.maxJobs=s+i.currJobs,i.tryRunJobs(),i.maxJobs=o,this.needsUpdate=!0}if(this.needsUpdate){this.needsUpdate=!1;const{overlays:o,overlayInfo:s}=this;o.sort((a,r)=>s.get(a).order-s.get(r).order),this.processedTiles.forEach(a=>{this._updateLayers(a)}),this.resetVirtualChildren(!this.enableTileSplitting),e.recalculateBytesUsed(),e.dispatchEvent({type:"needs-rerender"})}},this._onTileDownloadStart=({tile:n,url:o})=>{!/\.json$/i.test(o)&&!/\.subtree/i.test(o)&&(this.processedTiles.add(n),this._initTileOverlayInfo(n))},e.addEventListener("update-after",this._onUpdateAfter),e.addEventListener("tile-download-start",this._onTileDownloadStart),this.overlays.forEach(n=>{this._initOverlay(n)})}disposeTile(e){const{overlayInfo:t,tileControllers:i,processQueue:n,pendingTiles:o,processedTiles:s}=this;s.delete(e),i.has(e)&&(i.get(e).abort(),i.delete(e),o.delete(e)),t.forEach((({tileInfo:a},r)=>{if(a.has(e)){const{meshInfo:l,range:h}=a.get(e);h!==null&&r.releaseTexture(h,e),a.delete(e),l.clear()}})),n.removeByFilter(a=>a.tile===e)}calculateBytesUsed(e){const{overlayInfo:t}=this,i=this._bytesUsed;let n=null;return t.forEach(({tileInfo:o},s)=>{if(o.has(e)){const{target:a}=o.get(e);n=n||0,n+=ae(a)}}),n!==null?(i.set(e,n),n):i.has(e)?i.get(e):0}processTileModel(e,t){return this._processTileModel(e,t)}async _processTileModel(e,t,i=!1){const{tileControllers:n,processedTiles:o,pendingTiles:s}=this;n.set(t,new AbortController),i||s.set(t,e),o.add(t),this._wrapMaterials(e),this._initTileOverlayInfo(t),await this._initTileSceneOverlayInfo(e,t),this.expandVirtualChildren(e,t),this._updateLayers(t),s.delete(t)}dispose(){const{tiles:e}=this;[...this.overlays].forEach(i=>{this.deleteOverlay(i)}),this.processedTiles.forEach(i=>{this._updateLayers(i),this.disposeTile(i),delete i[A]}),e.removeEventListener("update-after",this._onUpdateAfter),this.resetVirtualChildren(!0)}getAttributions(e){this.overlays.forEach(t=>{t.opacity>0&&t.getAttributions(e)})}parseToMesh(e,t,i,n){if(i==="image_overlay_tile_split")return t[G]}async resetVirtualChildren(e=!1){this._virtualChildResetId++;const t=this._virtualChildResetId;if(await Promise.all(this.overlays.map(s=>s.whenReady())),t!==this._virtualChildResetId)return;const{tiles:i}=this,n=new Set;this.processedTiles.forEach(s=>{A in s&&n.add(s)}),n.forEach(s=>{if(s.parent===null)return;const a=s.engineData.scene.clone();if(a.updateMatrixWorld(),e||s[A]!==this._getSplitVectors(a,s).hash){const r=o(s);r.sort((l,h)=>(h.internal.depth||0)-(l.internal.depth||0)),r.forEach(l=>{i.processNodeQueue.remove(l),i.lruCache.remove(l),l.parent=null}),s.children.length=0}}),e||i.forEachLoadedModel((s,a)=>{this.expandVirtualChildren(s,a)});function o(s,a=[]){return s.children.forEach(r=>{a.push(r),o(r,a)}),a}}_getSplitVectors(e,t,i=N){const{tiles:n,overlayInfo:o}=this,s=new j;s.setFromObject(e),s.getCenter(i);const a=[],r=[];o.forEach(({tileInfo:h},c)=>{const u=h.get(t);if(u&&u.target&&c.shouldSplit(u.range,t)){c.frame?b.set(0,0,1).transformDirection(c.frame):(n.ellipsoid.getPositionToNormal(i,b),b.length()<1e-6&&b.set(1,0,0));const f=`${b.x.toFixed(3)},${b.y.toFixed(3)},${b.z.toFixed(3)}_`;r.includes(f)||r.push(f);const m=P.set(0,0,1);Math.abs(b.dot(m))>1-1e-4&&m.set(1,0,0);const d=new w().crossVectors(b,m).normalize(),_=new w().crossVectors(b,d).normalize();a.push(d,_)}});const l=[];for(;a.length!==0;){const h=a.pop().clone(),c=h.clone();for(let u=0;u<a.length;u++){const f=a[u],m=h.dot(f);Math.abs(m)>Math.cos(Math.PI/8)&&(c.addScaledVector(f,Math.sign(m)),h.copy(c).normalize(),a.splice(u,1),u--)}l.push(c.normalize())}return{directions:l,hash:r.join("")}}async expandVirtualChildren(e,t){if(t.children.length!==0||this.enableTileSplitting===!1)return;const i=e.clone();i.updateMatrixWorld();const{directions:n,hash:o}=this._getSplitVectors(i,t,N);if(t[A]=o,n.length===0)return;const s=new se;s.attributeList=r=>!/^layer_uv_\d+/.test(r),n.map(r=>{s.addSplitOperation((l,h,c,u,f,m)=>(q.getInterpolatedAttribute(l.attributes.position,h,c,u,f,P),P.applyMatrix4(m).sub(N).dot(r)))});const a=[];s.forEachSplitPermutation(()=>{const r=s.clipObject(i);r.matrix.premultiply(t.engineData.transformInverse).decompose(r.position,r.quaternion,r.scale);const l=[];if(r.traverse(c=>{if(c.isMesh){const u=c.material.clone();c.material=u;for(const f in u){const m=u[f];if(m&&m.isTexture&&m.source.data instanceof ImageBitmap){const d=document.createElement("canvas");d.width=m.image.width,d.height=m.image.height;const _=d.getContext("2d");_.scale(1,-1),_.drawImage(m.source.data,0,0,d.width,-d.height);const p=new Y(d);p.mapping=m.mapping,p.wrapS=m.wrapS,p.wrapT=m.wrapT,p.minFilter=m.minFilter,p.magFilter=m.magFilter,p.format=m.format,p.type=m.type,p.anisotropy=m.anisotropy,p.colorSpace=m.colorSpace,p.generateMipmaps=m.generateMipmaps,u[f]=p}}l.push(c)}}),l.length===0)return;const h={};if(t.boundingVolume.region&&(h.region=z(l,this.tiles.ellipsoid).region),t.boundingVolume.box||t.boundingVolume.sphere){ye.setFromObject(r,!0).getCenter(B);let c=0;r.traverse(u=>{const f=u.geometry;if(f){const m=f.attributes.position;for(let d=0,_=m.count;d<_;d++){const p=P.fromBufferAttribute(m,d).applyMatrix4(u.matrixWorld).distanceToSquared(B);c=Math.max(c,p)}}}),h.sphere=[...B,Math.sqrt(c)]}a.push({refine:"REPLACE",geometricError:t.geometricError*.5,boundingVolume:h,content:{uri:"./child.image_overlay_tile_split"},children:[],[G]:r})}),t.refine="REPLACE",t.children.push(...a)}fetchData(e,t){if(/image_overlay_tile_split/.test(e))return new ArrayBuffer}addOverlay(e,t=null){const{tiles:i,overlays:n,overlayInfo:o}=this;t===null&&(t=n.reduce((a,r)=>Math.max(a,r.order+1),0));const s=new AbortController;n.push(e),o.set(e,{order:t,uniforms:{},tileInfo:new Map,controller:s,frame:e.frame?e.frame.clone():null}),i!==null&&this._initOverlay(e)}setOverlayOrder(e,t){this.overlays.indexOf(e)!==-1&&(this.overlayInfo.get(e).order=t,this._markNeedsUpdate())}deleteOverlay(e){const{overlays:t,overlayInfo:i,processQueue:n,processedTiles:o}=this,s=t.indexOf(e);if(s!==-1){const{tileInfo:a,controller:r}=i.get(e);o.forEach(l=>{if(!a.has(l))return;const{meshInfo:h,range:c}=a.get(l);c!==null&&e.releaseTexture(c,l),a.delete(l),h.clear()}),a.clear(),i.delete(e),r.abort(),n.removeByFilter(l=>l.overlay===e),t.splice(s,1),o.forEach(l=>{this._updateLayers(l)}),this._markNeedsUpdate()}}_initOverlay(e){const{tiles:t}=this;e.isInitialized||(e.init(),e.whenReady().then(()=>{e.setResolution(this.resolution);const o=e.fetch.bind(e);e.fetch=(...s)=>t.downloadQueue.add({priority:-performance.now()},()=>o(...s))}));const i=[],n=async(o,s)=>{this._initTileOverlayInfo(s,e);const a=this._initTileSceneOverlayInfo(o,s,e);i.push(a),await a,this._updateLayers(s)};t.forEachLoadedModel((o,s)=>{n(o,s)}),this.pendingTiles.forEach((o,s)=>{n(o,s)}),Promise.all(i).then(()=>{this._markNeedsUpdate()})}_wrapMaterials(e){e.traverse(t=>{if(t.material){const i=fe(t.material,t.material.onBeforeCompile);this.meshParams.set(t,i)}})}_initTileOverlayInfo(e,t=this.overlays){if(Array.isArray(t)){t.forEach(o=>this._initTileOverlayInfo(e,o));return}const{overlayInfo:i}=this;if(i.get(t).tileInfo.has(e))return;const n={range:null,target:null,meshInfo:new Map};if(i.get(t).tileInfo.set(e,n),t.isReady&&!t.isPlanarProjection){if(e.boundingVolume.region){const[o,s,a,r]=e.boundingVolume.region,l=t.projection.toNormalizedRange([o,s,a,r]);n.range=l,t.lockTexture(l,e)}}}async _initTileSceneOverlayInfo(e,t,i=this.overlays){if(Array.isArray(i))return Promise.all(i.map(g=>this._initTileSceneOverlayInfo(e,t,g)));const{tiles:n,overlayInfo:o,tileControllers:s,processQueue:a}=this,{ellipsoid:r}=n,{controller:l,tileInfo:h}=o.get(i),c=s.get(t);if(i.isReady||await i.whenReady(),l.signal.aborted||c.signal.aborted)return;const u=[];e.updateMatrixWorld(),e.traverse(g=>{g.isMesh&&u.push(g)});const{aspectRatio:f,projection:m}=i,d=h.get(t);let _,p,M;if(i.isPlanarProjection){C.makeScale(1/f,1,1).multiply(i.frame),e.parent!==null&&C.multiply(n.group.matrixWorldInverse);let g;({range:_,uvs:p,heightRange:g}=me(u,C)),M=!(g[0]>1||g[1]<0)}else C.identity(),e.parent!==null&&C.copy(n.group.matrixWorldInverse),{range:_,uvs:p}=z(u,r,C,m),_=m.toNormalizedRange(_),M=!0;d.range===null?(d.range=_,i.lockTexture(_,t)):_=d.range;let v=null;M&&i.hasContent(_,t)&&(v=await a.add({tile:t,overlay:i},async()=>{if(l.signal.aborted||c.signal.aborted)return null;const g=await i.getTexture(_,t);return l.signal.aborted||c.signal.aborted?null:g}).catch(g=>{if(!(g instanceof te))throw g})),d.target=v,u.forEach((g,I)=>{const L=new Float32Array(p[I]),S=new K(L,3);d.meshInfo.set(g,{attribute:S})})}_updateLayers(e){const{overlayInfo:t,overlays:i,tileControllers:n}=this,o=n.get(e);this.tiles.recalculateBytesUsed(e),!(!o||o.signal.aborted)&&i.forEach((s,a)=>{const{tileInfo:r}=t.get(s),{meshInfo:l,target:h}=r.get(e);l.forEach(({attribute:c},u)=>{const{geometry:f,material:m}=u,d=this.meshParams.get(u),_=`layer_uv_${a}`;f.getAttribute(_)!==c&&(f.setAttribute(_,c),f.dispose()),d.layerMaps.length=i.length,d.layerInfo.length=i.length,d.layerMaps.value[a]=h!==null?h:null,d.layerInfo.value[a]=s,m.defines[`LAYER_${a}_EXISTS`]=+(h!==null),m.defines[`LAYER_${a}_ALPHA_INVERT`]=Number(s.alphaInvert),m.defines[`LAYER_${a}_ALPHA_MASK`]=Number(s.alphaMask),m.defines.LAYER_COUNT=i.length,m.needsUpdate=!0})})}_markNeedsUpdate(){this.needsUpdate===!1&&(this.needsUpdate=!0,this.tiles!==null&&this.tiles.dispatchEvent({type:"needs-update"}))}}class H{get isPlanarProjection(){return!!this.frame}constructor(e={}){const{opacity:t=1,color:i=16777215,frame:n=null,preprocessURL:o=null,alphaMask:s=!1,alphaInvert:a=!1}=e;this.preprocessURL=o,this.opacity=t,this.color=new Z(i),this.frame=n!==null?n.clone():null,this.alphaMask=s,this.alphaInvert=a,this._whenReady=null,this.isReady=!1,this.isInitialized=!1}init(){this.isInitialized=!0,this._whenReady=this._init().then(()=>this.isReady=!0)}whenReady(){return this._whenReady}_init(){}fetch(e,t={}){return this.preprocessURL&&(e=this.preprocessURL(e)),fetch(e,t)}getAttributions(e){}hasContent(e,t){return!1}async getTexture(e,t){return null}async lockTexture(e,t){return null}releaseTexture(e,t){}setResolution(e){}shouldSplit(e,t){return!1}}class J extends H{get tiling(){return this.imageSource.tiling}get projection(){return this.tiling.projection}get aspectRatio(){return this.tiling&&this.isReady?this.tiling.aspectRatio:1}get fetchOptions(){return this.imageSource.fetchOptions}set fetchOptions(e){this.imageSource.fetchOptions=e}constructor(e={}){const{imageSource:t=null,...i}=e;super(i),this.imageSource=t,this.regionImageSource=null}_init(){return this._initImageSource().then(()=>{this.imageSource.fetchData=(...e)=>this.fetch(...e),this.regionImageSource=new de(this.imageSource)})}_initImageSource(){return this.imageSource.init()}calculateLevel(e,t){if(this.isPlanarProjection){const[i,n,o,s]=e,a=o-i,r=s-n;let l=0;const h=this.regionImageSource.resolution,c=this.tiling.maxLevel;for(;l<c;l++){const u=h/a,f=h/r,{pixelWidth:m,pixelHeight:d}=this.tiling.getLevel(l);if(m>=u||d>=f)break}return l}else return t.internal.depthFromRenderedParent-1}hasContent(e,t){return this.regionImageSource.hasContent(...e,this.calculateLevel(e,t))}getTexture(e,t){return this.regionImageSource.get(...e,this.calculateLevel(e,t))}lockTexture(e,t){return this.regionImageSource.lock(...e,this.calculateLevel(e,t))}releaseTexture(e,t){this.regionImageSource.release(...e,this.calculateLevel(e,t))}setResolution(e){this.regionImageSource.resolution=e}shouldSplit(e,t){return this.tiling.maxLevel>this.calculateLevel(e,t)}}class we extends J{constructor(e={}){super(e),this.imageSource=new W(e)}}class Ee extends H{get projection(){return this.imageSource.projection}get aspectRatio(){return 2}get pointRadius(){return this.imageSource.pointRadius}set pointRadius(e){this.imageSource.pointRadius=e}get strokeStyle(){return this.imageSource.strokeStyle}set strokeStyle(e){this.imageSource.strokeStyle=e}get strokeWidth(){return this.imageSource.strokeWidth}set strokeWidth(e){this.imageSource.strokeWidth=e}get fillStyle(){return this.imageSource.fillStyle}set fillStyle(e){this.imageSource.fillStyle=e}get geojson(){return this.imageSource.geojson}set geojson(e){this.imageSource.geojson=e}constructor(e={}){super(e),this.imageSource=new ge(e)}_init(){return this.imageSource.init()}hasContent(e){return this.imageSource.hasContent(...e)}getTexture(e){return this.imageSource.get(...e)}lockTexture(e){return this.imageSource.lock(...e)}releaseTexture(e){this.imageSource.release(...e)}setResolution(e){this.imageSource.resolution=e}shouldSplit(e,t){return!0}redraw(){this.imageSource.redraw()}}class Re extends J{constructor(e={}){super(e);const{apiToken:t,autoRefreshToken:i,assetId:n}=e;this.options=e,this.assetId=n,this.auth=new ie({apiToken:t,autoRefreshToken:i}),this.auth.authURL=`https://api.cesium.com/v1/assets/${n}/endpoint`,this._attributions=[],this.externalType=!1}_initImageSource(){return this.auth.refreshToken().then(async e=>{if(this._attributions=e.attributions.map(t=>({value:t.html,type:"html",collapsible:t.collapsible})),e.type!=="IMAGERY")throw new Error("CesiumIonOverlay: Only IMAGERY is supported as overlay type.");switch(this.externalType=!!e.externalType,e.externalType){case"GOOGLE_2D_MAPS":{const{url:t,session:i,key:n,tileWidth:o}=e.options,s=`${t}/v1/2dtiles/{z}/{x}/{y}?session=${i}&key=${n}`;this.imageSource=new W({...this.options,url:s,tileDimension:o,levels:22});break}case"BING":{const{url:t,mapStyle:i,key:n}=e.options,o=`${t}/REST/v1/Imagery/Metadata/${i}?incl=ImageryProviders&key=${n}&uriScheme=https`,a=(await fetch(o).then(r=>r.json())).resourceSets[0].resources[0];this.imageSource=new he({...this.options,url:a.imageUrl,subdomains:a.imageUrlSubdomains,tileDimension:a.tileWidth,levels:a.zoomMax});break}default:this.imageSource=new ne({...this.options,url:e.url})}return this.imageSource.fetchData=(...t)=>this.fetch(...t),this.imageSource.init()})}fetch(...e){return this.externalType?super.fetch(...e):this.auth.fetch(...e)}getAttributions(e){e.push(...this._attributions)}}export{Re as C,Ee as G,be as I,we as X};
//# sourceMappingURL=ImageOverlayPlugin-C0MePglr.js.map
